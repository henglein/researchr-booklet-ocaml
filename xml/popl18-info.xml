<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE event [<!ELEMENT zip_code (#PCDATA)><!ELEMENT url_link_display (#PCDATA)><!ELEMENT url (#PCDATA)><!ELEMENT tracks (track+)><!ELEMENT track (#PCDATA)><!ELEMENT title (#PCDATA)><!ELEMENT timeslot (slot_id?, title, room, date, start_time, end_time, description?, acm_doi?, persons?, tracks?, tags?)><!ELEMENT tags (tag+)><!ELEMENT tag (#PCDATA)><!ELEMENT suffix (#PCDATA)><!ELEMENT subevent_logo_url (#PCDATA)><!ELEMENT subevent_id (#PCDATA)><!ELEMENT subevent (subevent_id?, title, acronym?, subevent_type, description?, room, date, url?, url_link_display?, subevent_logo_url?, acm_doi?, persons?, tracks?, tags?, sponsor?, timeslot*)><!ELEMENT state (#PCDATA)><!ELEMENT start_time (#PCDATA)><!ELEMENT start_date (#PCDATA)><!ELEMENT sponsor (#PCDATA)><!ELEMENT sort_key (#PCDATA)><!ELEMENT slot_id (#PCDATA)><!ELEMENT subevent_type EMPTY><!ATTLIST subevent_type	type (case_study | demonstration | poster | regular | tutorial | workshop) #IMPLIED><!ELEMENT room (#PCDATA)><!ELEMENT role (#PCDATA)><!ELEMENT picture_url (#PCDATA)><!ELEMENT persons (person+)><!ELEMENT person (role, sort_key, first_name, middle_name?, last_name, suffix?, affiliation, acm_profile_id?, email?, bio?, homepage_url?, picture_url?)><!ELEMENT middle_name (#PCDATA)><!ELEMENT location (facility_name, facility_map_url?, address, city, state?, country, zip_code?)><!ELEMENT last_name (#PCDATA)><!ELEMENT homepage_url (#PCDATA)><!ELEMENT first_name (#PCDATA)><!ELEMENT facility_name (#PCDATA)><!ELEMENT facility_map_url (#PCDATA)><!ELEMENT event_type EMPTY><!ATTLIST event_type	type (conference|workshop|symposium) #IMPLIED><!ELEMENT event (event_details, subevent*, timeslot*)><!ELEMENT event_logo_url (#PCDATA)><!ELEMENT event_details (title, acronym, event_type, start_date, end_date, location, description, url?, url_link_display?, event_logo_url?, persons?)><!ELEMENT end_time (#PCDATA)><!ELEMENT end_date (#PCDATA)><!ELEMENT email (#PCDATA)><!ELEMENT description (#PCDATA)><!ELEMENT date (#PCDATA)><!ELEMENT country (#PCDATA)><!ELEMENT city (#PCDATA)><!ELEMENT bio (#PCDATA)><!ELEMENT affiliation (#PCDATA)><!ELEMENT address (#PCDATA)><!ELEMENT acronym (#PCDATA)><!ELEMENT acm_profile_id (#PCDATA)><!ELEMENT acm_doi (#PCDATA)>]>
<event>
  <event_details>
    <title>POPL 2018</title>
    <acronym>POPL 2018</acronym>
    <event_type type="conference"/>
    <start_date>2018/01/07</start_date>
    <end_date>2018/01/13</end_date>
    <location>
      <facility_name>Omni Hotel</facility_name>
      <address>251 S Olive St</address>
      <city>Los Angeles</city>
      <state>California</state>
      <country>United States</country>
    </location>
    <description>Welcome to the website of The 45th ACM SIGPLAN Symposium on Principles of Programming Languages (POPL 2018)
The annual Symposium on Principles of Programming Languages is a forum for the discussion of all aspects of programming languages and programming systems. Both theoretical and experimental papers are welcome, on topics ranging from formal frameworks to experience reports. We seek submissions that make principled, enduring contributions to the theory, design, understanding, implementation or application of programming languages.
The symposium is sponsored by ACM SIGPLAN, in cooperation with ACM SIGACT and ACM SIGLOG.
The main POPL 2018 conference will be held from Wed 10 - Fri 12 January 2018.
Please visit the track pages of co-located conferences and workshops to find their schedules.
The schedule for POPL can be found here

Schedule At A Glance

</description>
    <url>https://popl18.sigplan.org/home</url>
    <url_link_display>POPL 2018</url_link_display>
    <persons>
      <person>
        <role>Chair in Steering Committee</role>
        <sort_key>1</sort_key>
        <first_name>Giuseppe</first_name>
        <last_name>Castagna</last_name>
        <affiliation>CNRS, France / University of Paris Diderot, France</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.irif.fr/~gc/</homepage_url>
        <picture_url>https://popl18.sigplan.org/getProfileImage/giuseppecastagna/ca2a9ac8-d149-4486-87ed-b55ceb154a17/small.jpg</picture_url>
      </person>
      <person>
        <role>General Chair in Organizing Committee, Committee Member in Steering Committee</role>
        <sort_key>2</sort_key>
        <first_name>Ranjit</first_name>
        <last_name>Jhala</last_name>
        <affiliation>University of California, San Diego</affiliation>
        <bio>Nom nom. Chomp. Burp.</bio>
        <homepage_url>http://ranjitjhala.github.io</homepage_url>
        <picture_url>https://popl18.sigplan.org/getProfileImage/ranjitjhala/afbdab69-ed23-4022-b7a4-2c57128f20ec/small.jpg</picture_url>
      </person>
      <person>
        <role>Program Chair in Organizing Committee, Committee Member in Steering Committee</role>
        <sort_key>3</sort_key>
        <first_name>Andrew</first_name>
        <last_name>Myers</last_name>
        <affiliation>Cornell University</affiliation>
        <bio>Andrew Myers is a Professor in the Department of Computer Science at Cornell University in Ithaca, NY. His research interests include programming languages, computer security, and distributed and persistent programming systems. Myers is an ACM Fellow. He has received awards for papers appearing in POPL’99, SOSP’01, SOSP’07, CIDR’13, PLDI’13, and PLDI’15. Myers is currently the Editor-in-Chief for ACM Transactions on Programming Languages and Systems (TOPLAS). He has also served as program chair or co-chair for a few conferences: ACM POPL 2018, ACM CCS 2016, POST 2014, IEEE CSF 2010, and IEEE S&amp;amp;P 2009.</bio>
        <homepage_url>http://www.cs.cornell.edu/andru</homepage_url>
        <picture_url>https://popl18.sigplan.org/getProfileImage/andrewmyers/88baadd2-5ed8-4687-b205-3cbbe8b1a848/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>4</sort_key>
        <first_name>Rastislav</first_name>
        <last_name>Bodik</last_name>
        <affiliation>University of Washington</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.berkeley.edu/~bodik</homepage_url>
        <picture_url>https://popl18.sigplan.org/getProfileImage/rastislavbodik/ae16ae8e-9d00-41c4-9067-0c37da65dde7/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>5</sort_key>
        <first_name>Jeremy</first_name>
        <last_name>Gibbons</last_name>
        <affiliation>Department of Computer Science, University of Oxford</affiliation>
        <bio>I am Professor of Computing in the Department of Computer Science at the University of Oxford. I am currently Director of the Software Engineering Programme, which offers part-time professional Masters’ degrees in Software Engineering and in Software and Systems Security. I also lead the Algebra of Programming research group. I am Editor-in-Chief of the Journal of Functional Programming, Past Vice Chair of ACM SIGPLAN, Past Chair of IFIP WG2.1. Before taking up this post in 1999, I held lectureships at Oxford Brookes University and the University of Auckland, New Zealand.</bio>
        <homepage_url>http://www.cs.ox.ac.uk/jeremy.gibbons/</homepage_url>
        <picture_url>https://popl18.sigplan.org/getProfileImage/jeremygibbons/17403e55-a926-41cf-ae21-08abecea187c/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>6</sort_key>
        <first_name>Andrew D.</first_name>
        <last_name>Gordon</last_name>
        <affiliation>Microsoft Research and University of Edinburgh</affiliation>
        <bio>I am a Principal Researcher at Microsoft Research, Cambridge, where I manage Programming Principles and Tools. As a part-time position, I also hold the Chair in Computer Security and am a member of the Laboratory for Foundations of Computer Science and the Security and Privacy group in the School of Informatics in the University of Edinburgh. I convene the University of Edinburgh Microsoft Research Joint Initiative in Informatics. I participate in the Data Science PhD programme. My current research is on probabilistic programming for machine learning.</bio>
        <homepage_url>https://www.microsoft.com/en-us/research/people/adg/</homepage_url>
        <picture_url>https://popl18.sigplan.org/getProfileImage/andrewdgordon/6a7c06a4-cf70-4529-ad02-55b979e93f82/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>7</sort_key>
        <first_name>Michael</first_name>
        <last_name>Hicks</last_name>
        <affiliation>University of Maryland, College Park</affiliation>
        <bio>Michael Hicks is a Professor in the Computer Science department and UMIACS at the University of Maryland, where he co-directs the laboratory for Programming Languages research (PLUM); he is the former Director of the Maryland Cybersecurity Center (MC2).
His research focuses on using programming languages and analyses to improve the security, reliability, and availability of software. He is perhaps best known for his work exploring dynamic software updating, which is a technique by which software can be updated without shutting it down. He has explored the design of new programming languages and analysis tools for helping programmers find bugs and software vulnerabilities, and for identifying suspicious or incorrect program executions.
His recent work has combined ideas from PL and cryptography, e.g., to ensure privacy preserving computations. He also leads the development of a new security-oriented programming contest, “build-it, break-it, fix-it,” which has been offered to the public and to students in his Coursera class on software security. He is the co-editor of the Programming Languages Enthusiast blog and Tweets at @michael_w_hicks.</bio>
        <homepage_url>http://www.cs.umd.edu/~mwh/</homepage_url>
        <picture_url>https://popl18.sigplan.org/getProfileImage/michaelhicks/aa64e3c6-3516-4e13-affe-77bc32c40565/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>8</sort_key>
        <first_name>Rupak</first_name>
        <last_name>Majumdar</last_name>
        <affiliation>MPI-SWS</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.mpi-sws.org/~rupak</homepage_url>
        <picture_url>https://popl18.sigplan.org/getProfileImage/rupakmajumdar/3289b197-9f9a-4880-94c5-d9cf6d764bb1/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>9</sort_key>
        <first_name>Brigitte</first_name>
        <last_name>Pientka</last_name>
        <affiliation>McGill University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.mcgill.ca/~bpientka/</homepage_url>
        <picture_url>https://popl18.sigplan.org/getProfileImage/brigittepientka/de1fcba2-a8fd-4b6e-a4f2-b7d397fef2cf/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>10</sort_key>
        <first_name>Peter</first_name>
        <last_name>Thiemann</last_name>
        <affiliation>University of Freiburg, Germany</affiliation>
        <bio>undefined</bio>
        <picture_url>https://popl18.sigplan.org/getProfileImage/peterthiemann/43fc0175-1745-4b3a-b626-86e10da76b86/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>11</sort_key>
        <first_name>Jan</first_name>
        <last_name>Vitek</last_name>
        <affiliation>Northeastern University</affiliation>
        <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
        <homepage_url>http://janvitek.org</homepage_url>
        <picture_url>https://popl18.sigplan.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
      </person>
      <person>
        <role>Industrial Relations Chair in Organizing Committee, Committee Member in Steering Committee</role>
        <sort_key>12</sort_key>
        <first_name>David</first_name>
        <last_name>Walker</last_name>
        <affiliation>Princeton University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.princeton.edu/~dpw/</homepage_url>
        <picture_url>https://popl18.sigplan.org/getProfileImage/davidwalker/8763137a-03a5-4963-8639-e9f2a3cc8ac9/small.jpg</picture_url>
      </person>
      <person>
        <role>Associated Events Chair in Organizing Committee</role>
        <sort_key>13</sort_key>
        <first_name>Marco</first_name>
        <last_name>Gaboardi</last_name>
        <affiliation>University at Buffalo, SUNY</affiliation>
        <bio>Marco Gaboardi is an assistant professor in the Department of Computer Science and Engineering at the University at Buffalo, SUNY. Previously, he was a faculty at the University of Dundee, Scotland. He received his PhD from the University of Torino, Italy, and the Institute National Polytechnique de Lorraine, France. He was a visitor scholar at the University of Pennsylvania and at Harvard’s CRCS center. He has been the recipient of a EU Marie Curie Fellowship. His research is in programming languages, differential privacy, and logic.</bio>
        <homepage_url>http://www.buffalo.edu/~gaboardi</homepage_url>
        <picture_url>https://popl18.sigplan.org/getProfileImage/marcogaboardi/76ff8963-9672-4f16-87bc-3f0d75ce589b/small.jpg</picture_url>
      </person>
      <person>
        <role>Remote Participation Chair in Organizing Committee</role>
        <sort_key>14</sort_key>
        <first_name>Michael</first_name>
        <last_name>Greenberg</last_name>
        <affiliation>Pomona College</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.pomona.edu/~michael/</homepage_url>
        <picture_url>https://popl18.sigplan.org/getProfileImage/michaelgreenberg/3c177ea6-ac3c-4ddb-9f4e-ac5d7b568e07/small.jpg</picture_url>
      </person>
      <person>
        <role>Artefact Evaluation Co-Chair in Organizing Committee, Publicity Chair in Organizing Committee</role>
        <sort_key>15</sort_key>
        <first_name>Jean</first_name>
        <last_name>Yang</last_name>
        <affiliation>Carnegie Mellon University</affiliation>
        <bio>undefined</bio>
        <homepage_url>jeanyang@csail.mit.edu </homepage_url>
        <picture_url>https://popl18.sigplan.org/getProfileImage/jeanyang/728ddfd8-02f1-426b-9006-87ba458c369f/small.jpg</picture_url>
      </person>
      <person>
        <role>Student Research Competition Chair in Organizing Committee</role>
        <sort_key>16</sort_key>
        <first_name>Benjamin</first_name>
        <last_name>Delaware</last_name>
        <affiliation>Purdue University</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://www.cs.purdue.edu/homes/bendy/</homepage_url>
        <picture_url>https://popl18.sigplan.org/getProfileImage/benjamindelaware/39bbf6b3-d145-435c-8956-8acf8cfcaffa/small.jpg</picture_url>
      </person>
      <person>
        <role>Artifact Evaluation Co-Chair in Organizing Committee</role>
        <sort_key>17</sort_key>
        <first_name>Cătălin</first_name>
        <last_name>Hriţcu</last_name>
        <affiliation>Inria Paris</affiliation>
        <bio>Catalin is a tenured Research Scientist at Inria Paris where he develops rigorous formal techniques for solving security problems. He is particularly interested in formal methods for security (memory safety, compartmentalization, dynamic monitoring, integrity, security protocols, information flow), programming languages (type systems, verification, proof assistants, property-based testing, semantics, formal metatheory, certified tools), and the design and verification of security-critical systems (reference monitors, secure compilers, microkernels, secure hardware). He is actively involved in the design of the F* verification system and was recently awarded an ERC Starting Grant on secure compilation. Catalin was a PhD student at Saarland University and a Research Associate at University of Pennsylvania before joining Inria Paris in 2013.</bio>
        <homepage_url>http://prosecco.gforge.inria.fr/personal/hritcu/</homepage_url>
        <picture_url>https://popl18.sigplan.org/getProfileImage/catalinhritcu/e262cec6-3e6b-47cc-ad61-b5c5b07953a1/small.jpg</picture_url>
      </person>
      <person>
        <role>Website Chair in Organizing Committee</role>
        <sort_key>18</sort_key>
        <first_name>Rohit</first_name>
        <last_name>Singh</last_name>
        <affiliation>CSAIL, MIT</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://rohitsingh.net</homepage_url>
        <picture_url>https://popl18.sigplan.org/getProfileImage/rohitsingh/126f8dee-6723-4b4d-8e88-b451c7dc5b62/small.jpg</picture_url>
      </person>
      <person>
        <role>Student Volunteer Co-Captain in Organizing Committee</role>
        <sort_key>19</sort_key>
        <first_name>Alex</first_name>
        <last_name>Sanchez-Stern</last_name>
        <affiliation>University of California, San Diego</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://cseweb.ucsd.edu/~alexss/</homepage_url>
        <picture_url>https://popl18.sigplan.org/getProfileImage/alexsanchezstern/8f8df577-1227-40b6-86e8-2b553ee0c66d/small.jpg</picture_url>
      </person>
      <person>
        <role>Student Volunteer Co-Captain in Organizing Committee</role>
        <sort_key>20</sort_key>
        <first_name>Jakub</first_name>
        <last_name>Zalewski</last_name>
        <affiliation>University of Edinburgh</affiliation>
        <bio>undefined</bio>
        <picture_url>https://popl18.sigplan.org/getProfileImage/jakubzalewski/af33cf0f-4802-4ef9-8f97-639a923b6960/small.jpg</picture_url>
      </person>
    </persons>
  </event_details>
  <subevent>
    <subevent_id>ff32b6b2-cded-4d34-87d2-74834ed33181</subevent_id>
    <title>PLMW: Talks I</title>
    <subevent_type type="regular"/>
    <room>PLMW</room>
    <date>2018/01/09</date>
    <url>https://popl18.sigplan.org/track/PLMW-POPL-2018</url>
    <url_link_display>Programming Languages Mentoring Workshop</url_link_display>
    <tracks>
      <track>Programming Languages Mentoring Workshop</track>
    </tracks>
    <timeslot>
      <slot_id>08a592b1-ed91-4d54-8ac3-650f6533dd66</slot_id>
      <title>How to Become a Researcher</title>
      <room>Omni Hotel | PLMW</room>
      <date>2018/01/09</date>
      <start_time>09:30</start_time>
      <end_time>10:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Armando</first_name>
          <last_name>Solar-Lezama</last_name>
          <affiliation>MIT CSAIL</affiliation>
          <bio>Armando Solar-Lezama is an associate professor at MIT where he leads the Computer Aided Programming Group. His research interests include software synthesis and its applications in diverse areas such as high-performance computing, information flow security and probabilistic programming.</bio>
          <picture_url>https://popl18.sigplan.org/getProfileImage/armandosolarlezama/7befe52d-6968-4786-9841-408800f80c71/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Programming Languages Mentoring Workshop</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>230ce4bf-3d22-42cd-8ef6-c9bd95c6f71d</slot_id>
      <title>LiquidHaskell Overview</title>
      <room>Omni Hotel | PLMW</room>
      <date>2018/01/09</date>
      <start_time>09:00</start_time>
      <end_time>09:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Niki</first_name>
          <last_name>Vazou</last_name>
          <affiliation>University of Maryland</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://nikivazou.github.io/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/nikivazou/8cc6ddec-154b-47e9-b40d-c66e78476391/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Programming Languages Mentoring Workshop</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>28b859ef-5bc8-47fa-9c1d-97e82fef644c</subevent_id>
    <title>NetPL 2018: Afternoon Session 1</title>
    <subevent_type type="regular"/>
    <room>NetPL</room>
    <date>2018/01/09</date>
    <url>https://popl18.sigplan.org/track/netpl-2018</url>
    <url_link_display>NetPL 2018</url_link_display>
    <tracks>
      <track>NetPL 2018</track>
    </tracks>
    <timeslot>
      <slot_id>60ae9917-e522-407a-b489-2e052c7526a1</slot_id>
      <title>Invited Talk 5</title>
      <room>Omni Hotel | NetPL</room>
      <date>2018/01/09</date>
      <start_time>15:00</start_time>
      <end_time>15:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>invited speaker</role>
          <sort_key>1</sort_key>
          <first_name>Peyman</first_name>
          <last_name>Kazemian</last_name>
          <affiliation>Forward Networks</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>NetPL 2018</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6ddeea1a-6653-4755-8e10-18e1868c1e27</slot_id>
      <title>Working Groups Debrief</title>
      <room>Omni Hotel | NetPL</room>
      <date>2018/01/09</date>
      <start_time>14:00</start_time>
      <end_time>14:30</end_time>
      <description>undefined</description>
      <tracks>
        <track>NetPL 2018</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c8b3c308-8724-48f8-b9fb-5f2d598a6fd6</slot_id>
      <title>Invited Talk 4</title>
      <room>Omni Hotel | NetPL</room>
      <date>2018/01/09</date>
      <start_time>14:30</start_time>
      <end_time>15:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>invited speaker</role>
          <sort_key>1</sort_key>
          <first_name>Sharon</first_name>
          <last_name>Shoham</last_name>
          <affiliation>Tel Aviv university</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.tau.ac.il/~sharonshoham/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/sharonshoham/52ca243a-805e-43b9-9f5a-bd1bae25fccb/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>NetPL 2018</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>14078b2d-6d0c-4e45-b97d-332010872326</subevent_id>
    <title>PriSC 2018: Session 1</title>
    <subevent_type type="regular"/>
    <room>PriSC</room>
    <date>2018/01/13</date>
    <url>https://popl18.sigplan.org/track/prisc-2018</url>
    <url_link_display>Principles of Secure Compilation</url_link_display>
    <tracks>
      <track>Principles of Secure Compilation</track>
    </tracks>
    <timeslot>
      <slot_id>a7dc7cb4-401c-40ee-838c-d7665ae9537f</slot_id>
      <title>Linear capabilities for modular fully-abstract compilation of verified code</title>
      <room>Omni Hotel | PriSC</room>
      <date>2018/01/13</date>
      <start_time>10:30</start_time>
      <end_time>11:00</end_time>
      <description>We contribute a new approach for secure compilation of verified C code that we conjecture to be fully abstract. The approach relies on target language support for capabilities: a well-studied form of unforgeable memory pointers that enables fine-grained, efficient privilege separation. Such capabilities are implemented in special processors called capability machines, particularly the recent CHERI processor. More specifically, we rely on support for sealed capabilities (like CHERI’s), as well as a new form of capabilities that we call linear capabilities. Linear capabilities are specially treated by the hardware to ensure that they can never be copied. Using these target-language security primitives, our compiler relies on information from both the source program and its verification proof, i.e. it will be formally defined as a separation-logic-proof-directed compiler.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Van Strydonck</last_name>
          <affiliation>KULeuven</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dominique</first_name>
          <last_name>Devriese</last_name>
          <affiliation>KU Leuven</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://distrinet.cs.kuleuven.be/people/dominiqu</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/dominiquedevriese/08b1fc2d-d157-4905-9c9a-e1ff279ab345/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Frank</first_name>
          <last_name>Piessens</last_name>
          <affiliation>KU Leuven</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Principles of Secure Compilation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d4f49615-70b1-464d-b07b-fcf076a3485f</slot_id>
      <title>Building Secure SGX Enclaves using F*, C/C++ and X64</title>
      <room>Omni Hotel | PriSC</room>
      <date>2018/01/13</date>
      <start_time>11:30</start_time>
      <end_time>12:00</end_time>
      <description>Intel SGX offers hardware mechanisms to isolate code and data running within enclaves from the rest of the platform. This enables security verification on a relatively small software TCB, but the task still involves complex low-level code.
Relying on the Everest verification toolchain, we use F* for developing specifications, code, and proofs; and then safely compile F* code to standalone C code. However, this does not account for all code running within the enclave, which also includes trusted C and assembly code for bootstrapping and for core libraries. Besides, we cannot expect all enclave applications to be rewritten in F*, so we also compile legacy C++ defensively, using variants of /guard that dynamically enforce their safety at runtime.
To reason about enclave security, we thus compose different sorts of code and verification styles, from fine-grained statically-verified F* to dynamically-monitored C++ and custom SGX instructions.
This involves two related program semantics: most of the verification is conducted within F* using the target semantics of Kremlin—a fragment of C with a structured memory—whereas SGX features and dynamic checks embedded by defensive C++ compilers require lower-level X64 code, for which we use the verified assembly language for Everest (VALE) and its embedding in F*.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Anitha</first_name>
          <last_name>Gollamudi</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Cédric</first_name>
          <last_name>Fournet</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://research.microsoft.com/en-us/um/people/fournet/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Principles of Secure Compilation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e9f7080b-ece2-446a-a3af-af84f2241a17</slot_id>
      <title>Enforcing Well-bracketed Control Flow and Stack Encapsulation using Linear Capabilities</title>
      <room>Omni Hotel | PriSC</room>
      <date>2018/01/13</date>
      <start_time>11:00</start_time>
      <end_time>11:30</end_time>
      <description>We propose and study a new calling convention that provably enforces well-bracketed control flow and local state encapsulation on a capability machine. The calling convention is based on linear capabilities, a new type of capabilities that are prevented by the hardware from being duplicated. In addition to designing and formalising this new calling convention, we also contribute a new way to formalise and prove that it effectively enforces well-bracketed control flow and local state encapsulation, building on the concept of fully abstract compilation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lau</first_name>
          <last_name>Skorstengaard</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl18.sigplan.org/getProfileImage/lauskorstengaard/6a1a6472-515b-41d4-943f-7de81373ecb3/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dominique</first_name>
          <last_name>Devriese</last_name>
          <affiliation>KU Leuven</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://distrinet.cs.kuleuven.be/people/dominiqu</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/dominiquedevriese/08b1fc2d-d157-4905-9c9a-e1ff279ab345/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Lars</first_name>
          <last_name>Birkedal</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.au.dk/~birke/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Principles of Secure Compilation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2b468c34-6151-42f6-8ed6-b2ad6a5b582e</subevent_id>
    <title>PLMW: Talks II</title>
    <subevent_type type="regular"/>
    <room>PLMW</room>
    <date>2018/01/09</date>
    <url>https://popl18.sigplan.org/track/PLMW-POPL-2018</url>
    <url_link_display>Programming Languages Mentoring Workshop</url_link_display>
    <tracks>
      <track>Programming Languages Mentoring Workshop</track>
    </tracks>
    <timeslot>
      <slot_id>0a1bc532-6bda-453c-91ff-9e7000d4a56f</slot_id>
      <title>The Curse of Knowledge</title>
      <room>Omni Hotel | PLMW</room>
      <date>2018/01/09</date>
      <start_time>14:30</start_time>
      <end_time>15:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Benjamin C.</first_name>
          <last_name>Pierce</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>Benjamin Pierce is Henry Salvatori Professor of Computer and Information Science at the University of Pennsylvania and a Fellow of the ACM. His research interests include programming languages, type systems, language-based security, computer-assisted formal verification, differential privacy, and synchronization technologies. He is the author of the widely used graduate textbooks Types and Programming Languages and Software Foundations. He has served as co-Editor in Chief of the Journal of Functional Programming, as Managing Editor for Logical Methods in Computer Science, and as editorial board member of Mathematical Structures in Computer Science, Formal Aspects of Computing, and ACM Transactions on Programming Languages and Systems. He is also the lead designer of the popular Unison file synchronizer.</bio>
          <homepage_url>http://www.cis.upenn.edu/~bcpierce/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/benjamincpierce/f2ee6f41-5bf7-4a0d-9b8d-71de6a666b1b/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Programming Languages Mentoring Workshop</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>998674fe-1827-4a69-ba9c-39a4b36e4c43</slot_id>
      <title>How to Give Talks That People Can Follow</title>
      <room>Omni Hotel | PLMW</room>
      <date>2018/01/09</date>
      <start_time>15:00</start_time>
      <end_time>15:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Derek</first_name>
          <last_name>Dreyer</last_name>
          <affiliation>MPI-SWS</affiliation>
          <bio>Derek Dreyer is a professor of computer science at the Max Planck Institute for Software Systems (MPI-SWS), and recipient of the 2017 ACM SIGPLAN Robin Milner Young Researcher Award. His research runs the gamut from the type theory of high-level functional languages, down to the verification of compilers and low-level concurrent programs under relaxed memory models. He is currently leading the RustBelt project, which focuses on building the first formal foundations for the Rust programming language. He also knows a thing or two about Scotch whisky.</bio>
          <homepage_url>http://www.mpi-sws.org/~dreyer</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/derekdreyer/35c3297e-34b7-4b24-bc9e-d4c927a19a40/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Programming Languages Mentoring Workshop</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d41200b2-0529-417c-9eca-d945f79130db</slot_id>
      <title>Dafny Overview</title>
      <room>Omni Hotel | PLMW</room>
      <date>2018/01/09</date>
      <start_time>14:00</start_time>
      <end_time>14:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>K. Rustan M.</first_name>
          <last_name>Leino</last_name>
          <affiliation>Amazon</affiliation>
          <bio>K. Rustan M. Leino is Senior Principal Engineer in the Automated Reasoning Group at Amazon Web Services. He works on ways to make sure programs behave as intended, secure and functionally correct. Leino is known for his work on programming methods and program verification tools and is a world leader in building automated program verification tools. These include the languages and tools Dafny, Chalice, Jennisys, Spec#, Boogie, Houdini, ESC/Java, and ESC/Modula-3. He is an ACM Fellow.
Before Amazon, Leino has been Principal Researcher at Microsoft Research, Visiting Professor at Imperial College London, and researcher at DEC/Compaq SRC. He received his PhD from Caltech (1995), before which he designed and wrote object-oriented software as a technical lead in the Windows NT group at Microsoft.
Leino hosts the Verification Corner channel on youtube. He is a multi-instrumentalist, he instructed group cardio and strength classes for many years, and he likes to cook.</bio>
          <picture_url>https://popl18.sigplan.org/getProfileImage/krustanmleino/22bd805e-6833-45e0-8574-5bc9442e4ffd/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Programming Languages Mentoring Workshop</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>61f75f4b-de03-44cc-8a31-69ac8319ef90</subevent_id>
    <title>PLMW: Panel I</title>
    <subevent_type type="regular"/>
    <room>PLMW</room>
    <date>2018/01/09</date>
    <url>https://popl18.sigplan.org/track/PLMW-POPL-2018</url>
    <url_link_display>Programming Languages Mentoring Workshop</url_link_display>
    <tracks>
      <track>Programming Languages Mentoring Workshop</track>
    </tracks>
    <timeslot>
      <slot_id>7c926745-983d-4ba8-adbb-0a2ac70abe47</slot_id>
      <title>Panel I: Technical Trends in Programming Languages Research</title>
      <room>Omni Hotel | PLMW</room>
      <date>2018/01/09</date>
      <start_time>10:30</start_time>
      <end_time>12:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aws</first_name>
          <last_name>Albarghouthi</last_name>
          <affiliation>University of Wisconsin-Madison</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl18.sigplan.org/getProfileImage/awsalbarghouthi/3a3382aa-47f5-4e02-ac71-509eb94703ff/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Constantin</first_name>
          <last_name>Enea</last_name>
          <affiliation>Université Paris Diderot</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.irif.fr/~cenea/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/constantinenea/2dfe8bfe-ddfe-4012-a2e2-01cc8b953734/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>David</first_name>
          <last_name>Walker</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.princeton.edu/~dpw/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/davidwalker/8763137a-03a5-4963-8639-e9f2a3cc8ac9/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Programming Languages Mentoring Workshop</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>fda9312b-0a1e-404a-a5d8-fa288335e2c2</subevent_id>
    <title>PriSC 2018: Session 3</title>
    <subevent_type type="regular"/>
    <room>PriSC</room>
    <date>2018/01/13</date>
    <url>https://popl18.sigplan.org/track/prisc-2018</url>
    <url_link_display>Principles of Secure Compilation</url_link_display>
    <tracks>
      <track>Principles of Secure Compilation</track>
    </tracks>
    <timeslot>
      <slot_id>68f55549-3910-4b31-8879-5ce9c5f5d7f8</slot_id>
      <title>Constant-time WebAssembly</title>
      <room>Omni Hotel | PriSC</room>
      <date>2018/01/13</date>
      <start_time>16:00</start_time>
      <end_time>16:30</end_time>
      <description>As ever more applications are designed to run inside browsers and other JavaScript runtime systems, there is an increasing need for cryptographic primitives that can be used client-side. Unfortunately, securely implementing cryptographic primitives in high-level languages is extremely difficult—runtime system components such as garbage collectors and just-in-time compilers can trivially introduce timing leaks in seemingly secure code. We argue that runtime system designs should be rethought with such applications—applications that demand strong guarantees for the executed code—in mind. As a concrete step towards this goal, we propose changes to the recent WebAssembly language and runtime system, supported by modern browsers. Our Constant-Time WebAssembly enables developers to implement crypto algorithms whose security guarantees will be preserved through compiler optimizations and execution in the browser.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>John</first_name>
          <last_name>Renner</last_name>
          <affiliation>UCSD</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl18.sigplan.org/getProfileImage/johnrenner/ee473e3c-537b-4d92-afc9-8cb18e611337/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sunjay</first_name>
          <last_name>Cauligi</last_name>
          <affiliation>UCSD</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Deian</first_name>
          <last_name>Stefan</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cseweb.ucsd.edu/~dstefan/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/deianstefan/55e73d29-9671-4740-9ef2-3b45f485fc24/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Principles of Secure Compilation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>73b1544d-b191-4be2-83da-8dd7c6c14b85</slot_id>
      <title>On Compositional Compiler Correctness and Fully Abstract Compilation</title>
      <room>Omni Hotel | PriSC</room>
      <date>2018/01/13</date>
      <start_time>17:00</start_time>
      <end_time>17:30</end_time>
      <description>Fully abstract compilation has long been understood to be useful for building secure compilers, but most verified compilers are not fully abstract. In particular, much recent work in the verified compilers community has gone into building compilers that are able to link with code that may not be produced from the same compiler. This is an important area of progress, because real software is made up of components written in different languages compiled by different compilers. But a key challenge is how to formally state the compiler correctness theorem so it supports linking with target code of arbitrary provenance. Recent results state their correct-component-compilation theorems in remarkably different ways, yielding pros and cons that aren’t well understood. Worse, to check if these theorems are sensible, reviewers must understand a massive amount of formalism. Further complicating things, compilers have multiple passes, which means that results from single passes need to be lifted to multi-pass compilers which often requires non-trivial work.
In this talk, we will survey recent results and present a generic compositional compiler correctness (CCC) theorem that we argue is the desired theorem for any compositionally correct compiler. Specific compiler-verification efforts can use their choice of formalism ``under the hood'' and then show that their theorems imply CCC. Using this theorem, we will show how fully abstract compilation relates to compositional compiler correctness, and argue that even researchers uninterested in secure compilation would still benefit from building fully abstract compilers, as they lead to easier composition of multi-pass compilers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Patterson</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://dbp.io</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/danielpatterson/5b299b7f-7940-4cf3-a798-2999ac0913c4/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Amal</first_name>
          <last_name>Ahmed</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ccs.neu.edu/home/amal/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/amalahmed/301fd92b-d4ae-4998-8f6b-82cf081da653/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Principles of Secure Compilation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c6f384df-c943-475b-a944-dd15bb9a7301</slot_id>
      <title>Foundations of Dependent Interoperability</title>
      <room>Omni Hotel | PriSC</room>
      <date>2018/01/13</date>
      <start_time>17:30</start_time>
      <end_time>18:00</end_time>
      <description>We observe that one approach to address the compilation of source programs working with rich(er) types to target programs with weak(er) types is to formally relate both source and target types via a type-theoretic partial Galois connection that accounts for the semantic correspondence between both. The partiality of the connection reflects the potential for failure when attempting to derive a corresponding value at a source type given a value at a target type.
We explore the applicability of type-theoretic Galois connections in the specific setting of dependent interoperability: trading static guarantees for runtime checks, a dependent interoperability framework provides a mechanism by which simply-typed values can safely be coerced to dependent types and, conversely, dependently-typed programs can defensively be exported to a simply-typed application.
In this setting, a traditional monotone type-theoretic Galois connections enforces a translation of dependent types to runtime checks that is both sound and complete with respect to the invariants encoded by dependent types. We also study a variant, dubbed anticonnection, which lets us induce weaker sound conditions that can amount to more efficient runtime checks.
Using our Coq framework, users can specify domain-specific partial connections between data structures. The library takes care of the (heavy) lifting that leads to interoperable programs. It thus becomes possible to internalize and hand-tune the extraction of dependently-typed programs to interoperable OCaml programs within Coq itself.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Pierre-Evariste</first_name>
          <last_name>Dagand</last_name>
          <affiliation>LIP6/CNRS </affiliation>
          <bio>undefined</bio>
          <homepage_url>https://pages.lip6.fr/Pierre-Evariste.Dagand/#contact</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/pierreevaristedagand/9c64ffc3-c911-4f4b-ba1c-82259f88ac56/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nicolas</first_name>
          <last_name>Tabareau</last_name>
          <affiliation>Inria, France</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Éric</first_name>
          <last_name>Tanter</last_name>
          <affiliation>University of Chile</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pleiad.cl/people/etanter</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/etanter/9bd12954-3541-41ba-9fb4-9ca8e0701371/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Principles of Secure Compilation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e2482310-6750-4e90-8d50-517ee24831d0</slot_id>
      <title>Per-Thread Compositional Compilation for Confidentiality-Preserving Concurrent Programs</title>
      <room>Omni Hotel | PriSC</room>
      <date>2018/01/13</date>
      <start_time>16:30</start_time>
      <end_time>17:00</end_time>
      <description>Recent work has demonstrated that per-thread compositional verification of value-dependent noninterference is feasible for concurrent programs. However, the gap remains that the verification of this (necessarily timing-sensitive) property for the source code of a program may not guarantee that the property still holds for that program once it has been compiled and is running on actual hardware. To this end, I have adapted and implemented in the Isabelle/HOL theorem prover an existing compilation scheme from a generic imperative While language to a generic RISC-style assembly language, and proved that my compiler preserves the compositional value-dependent noninterference property in question. As a proof of concept, I have exercised this compiler on a concurrent While model of the Cross Domain Desktop Compositor, and instantiated all of the related proofs of security for the compiled RISC-style assembly artifact of the system. In this talk I will expand on the details and immediate trajectory of this work, as well as discussing medium-to-long term plans and overarching objectives for my PhD thesis.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Robert</first_name>
          <last_name>Sison</last_name>
          <affiliation>Data61, CSIRO and UNSW</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ts.data61.csiro.au/people/?cn=Robert+Sison</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/robertsison/df03389e-d7ee-4236-928a-67ea610659d2/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Principles of Secure Compilation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9b4eda5a-48ee-4b2d-95c5-ffb225ac2c23</subevent_id>
    <title>PLMW: Panel II</title>
    <subevent_type type="regular"/>
    <room>PLMW</room>
    <date>2018/01/09</date>
    <url>https://popl18.sigplan.org/track/PLMW-POPL-2018</url>
    <url_link_display>Programming Languages Mentoring Workshop</url_link_display>
    <tracks>
      <track>Programming Languages Mentoring Workshop</track>
    </tracks>
    <timeslot>
      <slot_id>9aed4b06-48c6-48d1-8458-344b1bafd9e0</slot_id>
      <title>Work-Life Balance</title>
      <room>Omni Hotel | PLMW</room>
      <date>2018/01/09</date>
      <start_time>16:00</start_time>
      <end_time>16:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Andrew</first_name>
          <last_name>Myers</last_name>
          <affiliation>Cornell University</affiliation>
          <bio>Andrew Myers is a Professor in the Department of Computer Science at Cornell University in Ithaca, NY. His research interests include programming languages, computer security, and distributed and persistent programming systems. Myers is an ACM Fellow. He has received awards for papers appearing in POPL’99, SOSP’01, SOSP’07, CIDR’13, PLDI’13, and PLDI’15. Myers is currently the Editor-in-Chief for ACM Transactions on Programming Languages and Systems (TOPLAS). He has also served as program chair or co-chair for a few conferences: ACM POPL 2018, ACM CCS 2016, POST 2014, IEEE CSF 2010, and IEEE S&amp;amp;P 2009.</bio>
          <homepage_url>http://www.cs.cornell.edu/andru</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/andrewmyers/88baadd2-5ed8-4687-b205-3cbbe8b1a848/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Programming Languages Mentoring Workshop</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b4b58e9e-c858-4060-bb10-d35f1ed6f680</slot_id>
      <title>Panel II: Life in Grad School (and Beyond)</title>
      <room>Omni Hotel | PLMW</room>
      <date>2018/01/09</date>
      <start_time>16:30</start_time>
      <end_time>18:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Azadeh</first_name>
          <last_name>Farzan</last_name>
          <affiliation>University of Toronto</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.toronto.edu/~azadeh/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/azadehfarzan/f0942c46-887a-4f22-bf78-74fd48f6f0ed/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Zachary</first_name>
          <last_name>Tatlock</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>Assistant Professor at UW</bio>
          <homepage_url>https://homes.cs.washington.edu/~ztatlock/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/zacharytatlock/87af1196-2d8d-4bd5-a692-018d3939a00f/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Ball</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://research.microsoft.com/en-us/people/tball/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/tomball/886f5bf6-25ff-41e3-9745-d9a1eea01b29/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jennifer</first_name>
          <last_name>Paykin</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.seas.upenn.edu/~jpaykin/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/jenniferpaykin/61f6fdf3-10dd-4e5d-98bd-6aa4644432b8/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Programming Languages Mentoring Workshop</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f9a74319-637a-44d3-b93e-0f9d7cc373c8</subevent_id>
    <title>PriSC 2018: Welcome and Invited Talk</title>
    <subevent_type type="regular"/>
    <room>PriSC</room>
    <date>2018/01/13</date>
    <url>https://popl18.sigplan.org/track/prisc-2018</url>
    <url_link_display>Principles of Secure Compilation</url_link_display>
    <tracks>
      <track>Principles of Secure Compilation</track>
    </tracks>
    <timeslot>
      <slot_id>467b343b-b049-4e82-949a-5beb796e28f3</slot_id>
      <title>Challenges For Compiler-backed Security: From Sanitizer to Mitigation (Invited Talk)</title>
      <room>Omni Hotel | PriSC</room>
      <date>2018/01/13</date>
      <start_time>09:00</start_time>
      <end_time>10:00</end_time>
      <description>TBA</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mathias</first_name>
          <last_name>Payer</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>Mathias Payer is a security researcher and an assistant professor in computer science at Purdue university. His interests are related to system security, binary exploitation, user-space software-based fault isolation, binary translation/recompilation, and (application) virtualization.
Before joining Purdue in 2014 he spent two years as PostDoc in Dawn Song’s BitBlaze group at UC Berkeley where he worked on Code-Pointer Integrity and scalable symbolic execution. He graduated from ETH with a Dr. sc. ETH in 2012. The topic of his thesis is related to low-level binary translation and security.</bio>
          <homepage_url>https://nebelwelt.net/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/mathiaspayer/c3aa0773-d07c-49eb-8981-83f120873315/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Principles of Secure Compilation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>15fa1779-b73b-43d9-a7e3-e3df30300385</subevent_id>
    <title>Off the Beaten Track 2018: Keynote</title>
    <subevent_type type="regular"/>
    <room>OBT</room>
    <date>2018/01/13</date>
    <url>https://popl18.sigplan.org/track/OBT-2018</url>
    <url_link_display>Off the Beaten Track 2018</url_link_display>
    <tracks>
      <track>Off the Beaten Track 2018</track>
    </tracks>
    <timeslot>
      <slot_id>a4500154-87bf-4481-9bd1-ed69da92fbdd</slot_id>
      <title>Keynote</title>
      <room>Omni Hotel | OBT</room>
      <date>2018/01/13</date>
      <start_time>09:00</start_time>
      <end_time>10:00</end_time>
      <description>Abstract coming soon!</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Catherine</first_name>
          <last_name>Dubois</last_name>
          <affiliation>ENSIIE Paris-Evry</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Off the Beaten Track 2018</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>36d6e6f1-ecc8-48fd-932d-1d8c28a4a4e9</subevent_id>
    <title>PriSC 2018: Session 2</title>
    <subevent_type type="regular"/>
    <room>PriSC</room>
    <date>2018/01/13</date>
    <url>https://popl18.sigplan.org/track/prisc-2018</url>
    <url_link_display>Principles of Secure Compilation</url_link_display>
    <tracks>
      <track>Principles of Secure Compilation</track>
    </tracks>
    <timeslot>
      <slot_id>29c8c418-da8b-4cf2-8afd-f7b8a6e4b2a2</slot_id>
      <title>Short Talks</title>
      <room>Omni Hotel | PriSC</room>
      <date>2018/01/13</date>
      <start_time>13:30</start_time>
      <end_time>14:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Principles of Secure Compilation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>47915c00-b09d-4068-b8ee-233339d653ad</slot_id>
      <title>Secure Compilation in a Production Environment</title>
      <room>Omni Hotel | PriSC</room>
      <date>2018/01/13</date>
      <start_time>15:00</start_time>
      <end_time>15:30</end_time>
      <description>There are several security and privacy concerns that arise in a distributed computing environment where thousands of engineers develop and deploy binaries. These concerns can broadly be classified in terms of whether they are defense mechanisms against a dedicated attacker, general protection mechanisms for either the engineer or the computing environment, or techniques for detection and response to either security or privacy incidents. In this talk I will provide an overview of a few efforts of each of these types, with special emphasis on tools and techniques that may not have adopted recent research ideas. Audience willing, I will also speculate on analogies between the landscape of secure compilation and data privacy issues that receive significant attention in the industry.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Vijay</first_name>
          <last_name>D'Silva</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://research.google.com/pubs/VijayDSilva.html</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Principles of Secure Compilation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>603d5907-4e67-4342-8221-301ada213543</slot_id>
      <title>Robust Hyperproperty Preservation for Secure Compilation</title>
      <room>Omni Hotel | PriSC</room>
      <date>2018/01/13</date>
      <start_time>14:00</start_time>
      <end_time>14:30</end_time>
      <description>We map the space of soundness criteria for secure compilation based on the preservation of hyperproperties in arbitrary adversarial contexts, which we call robust hyperproperty preservation. For this, we study the preservation of several classes of hyperproperties and for each class we propose an equivalent “property-free” characterization of secure compilation that is generally better tailored for proofs. Even the strongest of our soundness criteria, the robust preservation of all hyperproperties, seems achievable for simple transformations and provable using context back-translation techniques previously developed for showing fully abstract compilation. While proving the robust preservation of hyperproperties that are not safety requires such powerful context back-translation techniques, for preserving safety hyperproperties robustly, translating each finite trace prefix back to a source context seems to suffice.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Deepak</first_name>
          <last_name>Garg</last_name>
          <affiliation>Max Planck Institute for Software Systems</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-sws.org/~dg</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/deepakgarg/2a70fd29-76c7-4771-98ce-7d8c591f4e69/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Cătălin</first_name>
          <last_name>Hriţcu</last_name>
          <affiliation>Inria Paris</affiliation>
          <bio>Catalin is a tenured Research Scientist at Inria Paris where he develops rigorous formal techniques for solving security problems. He is particularly interested in formal methods for security (memory safety, compartmentalization, dynamic monitoring, integrity, security protocols, information flow), programming languages (type systems, verification, proof assistants, property-based testing, semantics, formal metatheory, certified tools), and the design and verification of security-critical systems (reference monitors, secure compilers, microkernels, secure hardware). He is actively involved in the design of the F* verification system and was recently awarded an ERC Starting Grant on secure compilation. Catalin was a PhD student at Saarland University and a Research Associate at University of Pennsylvania before joining Inria Paris in 2013.</bio>
          <homepage_url>http://prosecco.gforge.inria.fr/personal/hritcu/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/catalinhritcu/e262cec6-3e6b-47cc-ad61-b5c5b07953a1/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Marco</first_name>
          <last_name>Patrignani</last_name>
          <affiliation>Saarland University, CISPA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-sws.org/~marcopat/marcopat/Home.html</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/marcopatrignani/1dc2d601-e85a-4b78-b8cc-8bbabb1191f5/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Marco</first_name>
          <last_name>Stronati</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>David</first_name>
          <last_name>Swasey</last_name>
          <affiliation>MPI-SWS</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.mpi-sws.org/~swasey/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/davidswasey/d7fcea88-1675-4ed2-b454-7effd77e1004/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Principles of Secure Compilation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e033fa48-64ab-464d-adac-73820247e54e</slot_id>
      <title>Formally Secure Compilation of Unsafe Low-Level Components</title>
      <room>Omni Hotel | PriSC</room>
      <date>2018/01/13</date>
      <start_time>14:30</start_time>
      <end_time>15:00</end_time>
      <description>We propose a new formal criterion for secure compilation, providing strong security guarantees for components written in unsafe, low-level languages with C-style undefined behavior. Our criterion goes beyond recent proposals, which protect the trace properties of a single component against an adversarial context, to model dynamic compromise in a system of mutually distrustful components. Each component is protected from all the others until it receives an input that triggers an undefined behavior, causing it to become compromised and attack the remaining uncompromised components. To illustrate this model, we demonstrate a secure compilation chain for an unsafe language with buffers, procedures, and components, compiled to a simple RISC abstract machine with built-in compartmentalization. The protection guarantees offered by this abstract machine can be achieved at the machine-code level using either software fault isolation or tag-based reference monitoring. We are working on machine-checked proofs showing that this compiler satisfies our secure compilation criterion.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Guglielmo</first_name>
          <last_name>Fachini</last_name>
          <affiliation>Inria Paris</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Cătălin</first_name>
          <last_name>Hriţcu</last_name>
          <affiliation>Inria Paris</affiliation>
          <bio>Catalin is a tenured Research Scientist at Inria Paris where he develops rigorous formal techniques for solving security problems. He is particularly interested in formal methods for security (memory safety, compartmentalization, dynamic monitoring, integrity, security protocols, information flow), programming languages (type systems, verification, proof assistants, property-based testing, semantics, formal metatheory, certified tools), and the design and verification of security-critical systems (reference monitors, secure compilers, microkernels, secure hardware). He is actively involved in the design of the F* verification system and was recently awarded an ERC Starting Grant on secure compilation. Catalin was a PhD student at Saarland University and a Research Associate at University of Pennsylvania before joining Inria Paris in 2013.</bio>
          <homepage_url>http://prosecco.gforge.inria.fr/personal/hritcu/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/catalinhritcu/e262cec6-3e6b-47cc-ad61-b5c5b07953a1/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Marco</first_name>
          <last_name>Stronati</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ana Nora</first_name>
          <last_name>Evans</last_name>
          <affiliation>Inria Paris and University of Virginia</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Théo</first_name>
          <last_name>Laurent</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Arthur</first_name>
          <last_name>Azevedo de Amorim</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>I am currently a post-doc researcher at CMU working with Matt Fredrikson and Anupam Datta. I completed my Ph.D. studies at the University of Pennsylvania, under the supervision of Benjamin Pierce.</bio>
          <homepage_url>http://www.seas.upenn.edu/~aarthur</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/arthurazevedodeamorim/d1479df1-8050-45a5-afb0-3f1f36a68672/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Benjamin C.</first_name>
          <last_name>Pierce</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>Benjamin Pierce is Henry Salvatori Professor of Computer and Information Science at the University of Pennsylvania and a Fellow of the ACM. His research interests include programming languages, type systems, language-based security, computer-assisted formal verification, differential privacy, and synchronization technologies. He is the author of the widely used graduate textbooks Types and Programming Languages and Software Foundations. He has served as co-Editor in Chief of the Journal of Functional Programming, as Managing Editor for Logical Methods in Computer Science, and as editorial board member of Mathematical Structures in Computer Science, Formal Aspects of Computing, and ACM Transactions on Programming Languages and Systems. He is also the lead designer of the popular Unison file synchronizer.</bio>
          <homepage_url>http://www.cis.upenn.edu/~bcpierce/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/benjamincpierce/f2ee6f41-5bf7-4a0d-9b8d-71de6a666b1b/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Andrew</first_name>
          <last_name>Tolmach</last_name>
          <affiliation>Portland State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.pdx.edu/~apt</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/andrewtolmach/a92afdc6-45ac-4bbb-803c-f93b67dc4a4b/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Principles of Secure Compilation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9913ed5f-f93a-46e0-9f53-d9b003beee2a</subevent_id>
    <title>NetPL 2018: Morning Session 1</title>
    <subevent_type type="regular"/>
    <room>NetPL</room>
    <date>2018/01/09</date>
    <url>https://popl18.sigplan.org/track/netpl-2018</url>
    <url_link_display>NetPL 2018</url_link_display>
    <tracks>
      <track>NetPL 2018</track>
    </tracks>
    <timeslot>
      <slot_id>38ffa7c6-eeda-40c0-8a59-6ca533c9a8cb</slot_id>
      <title>Invited Talk 1</title>
      <room>Omni Hotel | NetPL</room>
      <date>2018/01/09</date>
      <start_time>09:00</start_time>
      <end_time>09:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>invited speaker</role>
          <sort_key>1</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Smith</last_name>
          <affiliation>DARPA</affiliation>
          <bio>Dr. Jonathan M. Smith joined DARPA in September 2017 from the University of Pennsylvania, where he is a professor of computer and information science and the Olga and Alberico Pompa Professor of Engineering and Applied Science. As a DARPA program manager, Smith seeks to develop and execute programs in cybersecurity, networking, and distributed computing. Smith joined the University of Pennsylvania in 1989 from Bell Communications Research, where he was a member of the technical staff, a position he also held at Bell Telephone Laboratories.
Smith served as a program manager in DARPA’s Information Processing Technology Office (IPTO) from 2004 to 2006, developing and executing programs including Situation Aware Protocols In Edge Network Technologies (SAPIENT), Adaptive Cognition Enhanced Radio Teams (ACERT), and Brood of Spectrum Supremacy (BOSS). Smith was awarded the Office of the Secretary of Defense Medal for Exceptional Public Service in August 2006.</bio>
          <homepage_url>http://www.cis.upenn.edu/~jms</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/jonathansmith/483242a0-7acb-407e-8c7c-7db30c16273f/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>NetPL 2018</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d50cddf5-f0d5-4457-abfb-8dce437faf17</slot_id>
      <title>Invited Talk 2</title>
      <room>Omni Hotel | NetPL</room>
      <date>2018/01/09</date>
      <start_time>09:30</start_time>
      <end_time>10:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>invited speaker</role>
          <sort_key>1</sort_key>
          <first_name>Anees</first_name>
          <last_name>Shaikh</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>NetPL 2018</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2b76ab19-6a4c-446f-b58f-ca0f3bac15e8</subevent_id>
    <title>NetPL 2018: Morning Session 2</title>
    <subevent_type type="regular"/>
    <room>NetPL</room>
    <date>2018/01/09</date>
    <url>https://popl18.sigplan.org/track/netpl-2018</url>
    <url_link_display>NetPL 2018</url_link_display>
    <tracks>
      <track>NetPL 2018</track>
    </tracks>
    <timeslot>
      <slot_id>6dece315-294c-4327-af27-47e759ee478f</slot_id>
      <title>Working Groups</title>
      <room>Omni Hotel | NetPL</room>
      <date>2018/01/09</date>
      <start_time>11:00</start_time>
      <end_time>12:00</end_time>
      <description>We will break into groups to discuss goals and open challenges in different research directions.</description>
      <tracks>
        <track>NetPL 2018</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ef1f0c6d-3932-433f-98bb-ea8fc733000c</slot_id>
      <title>Invited Talk 3</title>
      <room>Omni Hotel | NetPL</room>
      <date>2018/01/09</date>
      <start_time>10:30</start_time>
      <end_time>11:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>invited speaker</role>
          <sort_key>1</sort_key>
          <first_name>Andrey</first_name>
          <last_name>Rybalchenko</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://research.microsoft.com/en-us/people/rybal/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/andreyrybalchenko/6a82d181-045a-4268-b923-13bdd175f20a/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>NetPL 2018</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1a5a2591-0637-4025-abba-9fa0d99dc39a</subevent_id>
    <title>Off the Beaten Track 2018: Session 3</title>
    <subevent_type type="regular"/>
    <room>OBT</room>
    <date>2018/01/13</date>
    <url>https://popl18.sigplan.org/track/OBT-2018</url>
    <url_link_display>Off the Beaten Track 2018</url_link_display>
    <tracks>
      <track>Off the Beaten Track 2018</track>
    </tracks>
    <timeslot>
      <slot_id>8d6d7413-0836-4f8a-bdb0-89269e631fc7</slot_id>
      <title>Towards A Systems Approach To Distributed Programming</title>
      <room>Omni Hotel | OBT</room>
      <date>2018/01/13</date>
      <start_time>17:00</start_time>
      <end_time>17:30</end_time>
      <description>It is undeniable that most developers today are building distributed applications. However, most of these applications are developed by composing existing systems together through unspecified APIs exposed to the application developer. Systems are not going away: they solve a particular problem and most applications today need to rely on several of these systems working in concert. Given this, we propose a research direction where higher-level languages with well defined semantics target underlying systems infrastructure as a middle-ground.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christopher</first_name>
          <last_name>Meiklejohn</last_name>
          <affiliation>Université catholique de Louvain</affiliation>
          <bio>Christopher Meiklejohn loves distributed systems and programming languages. Previously, Christopher worked at Basho Technologies, Inc. on the distributed key-value store, Riak. Christopher develops a programming language for distributed computation, called Lasp. Christopher is currently a Ph.D. student at the Université catholique de Louvain in Belgium.</bio>
          <homepage_url>http://christophermeiklejohn.com</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/christophermeiklejohn/534c2b02-1208-4a46-a66d-0ab8d3747cc3/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Peter</first_name>
          <last_name>Van Roy</last_name>
          <affiliation>Université catholique de Louvain</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.info.ucl.ac.be/~pvr/pldc.html</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/petervanroy/d483fce0-cfeb-405b-b540-a48b942e9315/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Off the Beaten Track 2018</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ce4eba67-8700-48d5-93d7-32a65290a842</slot_id>
      <title>Back to the Future with Denotational Semantics</title>
      <room>Omni Hotel | OBT</room>
      <date>2018/01/13</date>
      <start_time>16:00</start_time>
      <end_time>16:30</end_time>
      <description>This talk raises the question of whether we should go back to denotational semantics. I suspect that the elementary models of the λ-calculus (graph models and filter models) did not get a fair shake. These semantics are much simpler than the standard models and can be just as simple to define as an operational semantics. But why should we give up operational semantics? Denotational semantics have two properties that are lacking in operational semantics: they are compositional and extensional. In this talk I’ll present a new variation on the elementary models of the λ-calculus and discuss applications to compiler correctness and handling features such as parametric polymorphism. Of course, this just scratches the surface regarding whether this style of semantics is easier to use for large-scale language mechanization efforts. I invite you to join me as I go back to the future with denotational semantics!</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jeremy G.</first_name>
          <last_name>Siek</last_name>
          <affiliation>Indiana University, USA</affiliation>
          <bio>Jeremy Siek is an Associate Professor at Indiana University Bloomington. Jeremy’s areas of research include programming language design, type systems, mechanized theorem proving using proof assistants, and optimizing compilers. Jeremy’s Ph.D. thesis explored foundations for constrained templates, aka the “concepts” proposal for C++. Prior to that, Jeremy developed the Boost Graph Library, a C++ generic library for graph algorithms and data structures. Jeremy post-doc’d at Rice University where he developed the idea of gradual typing: a type system that integrates both dynamic and static typing in the same programming language. Jeremy is currently working on several open questions regarding gradual typing. Is the polymorphic blame calculus really parametric? How should gradual typing be combined with other features such as dependent types? What is the formal criteria for gradually typed languages? Is it possible to create a high-performance implementation of a gradually-typed languages? In 2009 Jeremy received the NSF CAREER award to fund his project: “Bridging the Gap Between Prototyping and Production”. In 2010 and again in 2015, Jeremy was awarded a Distinguished Visiting Fellowship from the Scottish Informatics &amp;amp; Computer Science Alliance.</bio>
          <homepage_url>http://homes.soic.indiana.edu/jsiek/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/jeremysiek/4365edf9-715f-46e0-8867-4ea5fb6341ad/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Off the Beaten Track 2018</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f0e17b95-70fd-4066-877e-76a3bc1c7a17</slot_id>
      <title>Climbing Up the Semantic Tower — at Runtime</title>
      <room>Omni Hotel | OBT</room>
      <date>2018/01/13</date>
      <start_time>16:30</start_time>
      <end_time>17:00</end_time>
      <description>Software exists at multiple levels of abstraction, where each more concrete level is an implementation of the more abstract level above, in a semantic tower of compilers and/or interpreters. First-class implementations are a reflection protocol to navigate this tower at runtime: they enable changing the underlying implementation of a computation while it is running. Key is a generalized notion of safe points that enable observing a computation at a higher-level than that at which it runs, and therefore to climb up the semantic tower, when at runtime most existing systems only ever allow but to go further down. The protocol was obtained by extracting the computational content of a formal specification for implementations and some of their properties. This approach reconciles two heretofore mutually exclusive fields: Semantics and Runtime Reflection.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>François-René</first_name>
          <last_name>Rideau</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Off the Beaten Track 2018</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f575c1e8-8506-475d-b611-7607291cf498</slot_id>
      <title>Discussion and business meeting</title>
      <room>Omni Hotel | OBT</room>
      <date>2018/01/13</date>
      <start_time>17:30</start_time>
      <end_time>18:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Off the Beaten Track 2018</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>35bec852-48ad-4b6c-910f-9eabf5bd9e2f</subevent_id>
    <title>Off the Beaten Track 2018: Session 1</title>
    <subevent_type type="regular"/>
    <room>OBT</room>
    <date>2018/01/13</date>
    <url>https://popl18.sigplan.org/track/OBT-2018</url>
    <url_link_display>Off the Beaten Track 2018</url_link_display>
    <tracks>
      <track>Off the Beaten Track 2018</track>
    </tracks>
    <timeslot>
      <slot_id>08516123-0c89-4fdc-be4d-10e3fc7a7080</slot_id>
      <title>Explaining Type Errors</title>
      <room>Omni Hotel | OBT</room>
      <date>2018/01/13</date>
      <start_time>11:30</start_time>
      <end_time>12:00</end_time>
      <description>Every beginning student of programming—that is, every student with the ill fortune of having a language with a static type system foisted upon them by a well-intentioned yet sadistic instructor—is well-acquainted with the Dreaded Type Error Message. Why do type error messages have to be so terrifying? Can’t we do a better job explaining type errors to programmers?
We propose two interrelated theses:

 We ought to move away from static error “messages” and towards interactive error explanations.
 We ought to consider the problem of generating error explanations in a more systematic, disciplined, and formal way. Explaining errors to users shouldn’t just be relegated to the status of an “engineering issue”, but ought to have all the tools of programming language theory and practice applied to it.
</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Brent</first_name>
          <last_name>Yorgey</last_name>
          <affiliation>Hendrix College</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ozark.hendrix.edu/~yorgey/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/brentyorgey/7604236a-b0c2-4c69-8d3d-75ec12c4feaf/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Richard A.</first_name>
          <last_name>Eisenberg</last_name>
          <affiliation>Bryn Mawr College, USA</affiliation>
          <bio>Assistant Professor at Bryn Mawr College. I completed my PhD in 2016 at University of Pennsylvania working under Stephanie Weirich; my dissertation topic was the integration of dependent types into the Haskell programming language. I am a regular contributor to the Glasgow Haskell Compiler (GHC).</bio>
          <homepage_url>http://cs.brynmawr.edu/~rae</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/richardeisenberg/576e2511-ae2a-4c2a-93b0-b8981243251c/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Harley D.</first_name>
          <last_name>Eades III</last_name>
          <affiliation>Augusta University</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Off the Beaten Track 2018</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3f990f88-861d-4e1e-bf32-5518560565db</slot_id>
      <title>Synthesizing Program-Specific Static Analyses</title>
      <room>Omni Hotel | OBT</room>
      <date>2018/01/13</date>
      <start_time>10:30</start_time>
      <end_time>11:00</end_time>
      <description>Designing a static analysis is generally a substantial undertaking, requiring significant expertise in both program analysis and the domain of interest, and significant development resources. As a result, most program analyses target properties that are universally of interest (e.g., absence of null pointer dereference) or nearly so (e.g., deadlock freedom). However, many interesting program properties that would benefit from static checking are specific to individual programs, or sometimes programs utilizing a certain library. It is impractical to devote program analysis and verification experts to these problems. We propose instead to work on example-based synthesis of program analyses within well-understood domains like type qualifier systems and effect systems. The dynamic behaviors behind the classes of problems these systems prevent correspond to examples that developers who lack expertise in static analysis can readily provide (data flow paths, or stack traces).</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Colin</first_name>
          <last_name>Gordon</last_name>
          <affiliation>Drexel University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cs.drexel.edu/~csgordon/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/colingordon/d990db47-1ece-4016-bce5-b764428bd0ee/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Off the Beaten Track 2018</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f86beaae-40f9-4aa4-96a1-d56245dad396</slot_id>
      <title>On quantifying the degree of unsoundness of static analyses</title>
      <room>Omni Hotel | OBT</room>
      <date>2018/01/13</date>
      <start_time>11:00</start_time>
      <end_time>11:30</end_time>
      <description>The theory and practice of static analysis differ greatly. In static-analysis research, the focus is commonly on analyses that are proven sound, apply to small calculi or toy languages, and use sophisticated techniques to achieve precision. In industry, static analyses are unsound, apply to real languages, and use simple techniques in order to scale to large programs.
Static-analysis researchers avoid unsound analyses, because it is not clear what one can formally say about an unsound analysis. Sure, it helps people in practice, but what precise statement can one make about it? Is the merit of an unsound analysis based purely on opinion?
I believe it is beneficial to characterize unsound analyses mathematically; to develop rigorous ways of evaluating them and formal models describing their behavior. Then, theoreticians would be able to approach unsound analyses systematically, and develop novel ways of reasoning about such analyses. In addition, practitioners would be able to compare the pros and cons of various analyses in a precise way.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dimitrios</first_name>
          <last_name>Vardoulakis</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Off the Beaten Track 2018</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6932fa46-64e9-4f09-b1b5-c37be17db06a</subevent_id>
    <title>Off the Beaten Track 2018: Session 2</title>
    <subevent_type type="regular"/>
    <room>OBT</room>
    <date>2018/01/13</date>
    <url>https://popl18.sigplan.org/track/OBT-2018</url>
    <url_link_display>Off the Beaten Track 2018</url_link_display>
    <tracks>
      <track>Off the Beaten Track 2018</track>
    </tracks>
    <timeslot>
      <slot_id>30eb1e15-d815-4301-91dd-625be4e3f2f5</slot_id>
      <title>Towards Proof Synthesis by Neural Machine Translation</title>
      <room>Omni Hotel | OBT</room>
      <date>2018/01/13</date>
      <start_time>15:00</start_time>
      <end_time>15:30</end_time>
      <description>Inspired by the recent evolution of deep neural networks (DNNs) in machine learning, we explore their application to the problems that often appear in the research of programming languages (PL problems), such as program synthesis and automated theorem proving. As a first step towards this goal, we report the result of our preliminary experimental result of the application of DNNs to proof synthesis of the intuitionistic propositional logic. The idea is to view the proof-synthesis problem as a translation from a proposition to its proof. We train a seq2seq model, which is a popular model in neural machine translation, so that it generates a proof term from a given proposition. We empirically observe that, although the generated proof is correct only for approximately half of the propositions in the test data, a generated proof term is close to a correct one in terms of the tree edit distance of AST. Based on this observation, we implemented a proof-search procedure that uses the generated proof term as a hint, which outperforms a brute-force one. We discuss future research directions and the gaps to be filled between DNN and PL problems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Taro</first_name>
          <last_name>Sekiyama</last_name>
          <affiliation>IBM Research, Japan</affiliation>
          <bio>I’m a research staff at IBM Research - Tokyo. I am interested in theory and applications of programming languages, such as type theory, program verification, type inference, program reasoning, and so on. The current research theme is to optimize and empower deep learning frameworks such as Caffe, Chainer, and so on.</bio>
          <homepage_url>http://researcher.ibm.com/researcher/view.php?person=jp-SEKIYM</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/tarosekiyama/dd6fb4ca-8161-4bbd-9392-01e4b94374e6/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Akifumi</first_name>
          <last_name>Imanishi</last_name>
          <affiliation>Kyoto University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Kohei</first_name>
          <last_name>Suenaga</last_name>
          <affiliation>Graduate School of Informatics, Kyoto University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fos.kuis.kyoto-u.ac.jp/~ksuenaga/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/koheisuenaga/f57f179b-edd7-499b-9b7b-0a240a6b0474/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Off the Beaten Track 2018</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7dacd033-945c-47d9-ba0d-7af53c904430</slot_id>
      <title>SweetPea: A Language for Designing Experiments</title>
      <room>Omni Hotel | OBT</room>
      <date>2018/01/13</date>
      <start_time>14:00</start_time>
      <end_time>14:30</end_time>
      <description>We introduce SweetPea, a SAT-sampler aided language that addresses problems scientists face when creating randomized experimental designs. SweetPea provides a high-level interface to declaratively describe an experimental design, and a low-level synthesizer to generate unbiased sequences of trials given satisfiable constraints. Our prototype provides a rich set of primitives that closely match natural descriptions of experimental designs, allowing researchers to concisely describe what analysis they wish to perform. To ensure statistically significant results, every possible sequence of trials that satisfies the design must have an equal likelihood of being chosen for the experiment. SweetPea samples sequences of trials by compiling experimental designs into Boolean logic, which are then passed to a SAT-sampler. The SAT-sampler Unigen provides statistical guarantees that the solutions it finds are approximately uniformly probable in the space of all valid solutions.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Annie</first_name>
          <last_name>Cherkaev</last_name>
          <affiliation>University of Utah</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sebastian</first_name>
          <last_name>Musslick</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Cohen</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Vivek</first_name>
          <last_name>Srikumar</last_name>
          <affiliation>University of Utah</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Flatt</last_name>
          <affiliation>University of Utah</affiliation>
          <bio>Matthew Flatt is a professor in the School of Computing at the University of Utah, where he works on extensible programming languages, runtime systems, and applications of functional programming. He is one of the developers of the Racket programming language. He received his PhD from Rice University in 1999.</bio>
          <homepage_url>http://www.cs.utah.edu/~mflatt/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/matthewflatt/8be359a0-6498-4c8c-a43a-e74a3d39673c/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Off the Beaten Track 2018</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>94b4f374-c86e-469a-83b4-759b71c6a368</slot_id>
      <title>Lunch</title>
      <room>Omni Hotel | OBT</room>
      <date>2018/01/13</date>
      <start_time>13:30</start_time>
      <end_time>14:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Off the Beaten Track 2018</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>db4c3cde-cb7f-4e5f-bd00-df1b9f06035e</slot_id>
      <title>Extensible Semantics for Fluidics</title>
      <room>Omni Hotel | OBT</room>
      <date>2018/01/13</date>
      <start_time>14:30</start_time>
      <end_time>15:00</end_time>
      <description>With the rise of lab automation technologies, scientists are writing programs instead of pen-and-paper protocols. These programs mix computation with fluidic manipulation, leading to problems with resource management and error handling. Scientists have rich understanding of the biological or chemical systems involved, but the current programming model can not use this information. We believe techniques from the programming language (PL) community are well-suited to address the myriad challenges in this field. This talk will present how some of the problems in this field line up with (and challenge) well-understood PL techniques.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Max</first_name>
          <last_name>Willsey</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.mwillsey.com</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/maxwillsey/ff552459-e263-42a5-b17b-1301d482943d/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jared</first_name>
          <last_name>Roesch</last_name>
          <affiliation>University of Washington, USA</affiliation>
          <bio>I am a 2nd year PhD student at the University of Washington.</bio>
          <homepage_url>http://jroesch.github.io/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/jaredroesch/8e584c15-d323-48f2-b76b-1700a77ed0ea/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Off the Beaten Track 2018</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ae259548-62e3-4210-9199-7105b01ad229</subevent_id>
    <title>NetPL 2018: Afternoon Session 2</title>
    <subevent_type type="regular"/>
    <room>NetPL</room>
    <date>2018/01/09</date>
    <url>https://popl18.sigplan.org/track/netpl-2018</url>
    <url_link_display>NetPL 2018</url_link_display>
    <tracks>
      <track>NetPL 2018</track>
    </tracks>
    <timeslot>
      <slot_id>1b3d09ef-f668-41ec-9efc-e64708a7490b</slot_id>
      <title>Wrap Up</title>
      <room>Omni Hotel | NetPL</room>
      <date>2018/01/09</date>
      <start_time>17:30</start_time>
      <end_time>18:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Organization Co-chair</role>
          <sort_key>1</sort_key>
          <first_name>Marco</first_name>
          <last_name>Canini</last_name>
          <affiliation>KAUST</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://mcanini.github.io</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/marcocanini/427f6371-6805-4db7-8653-8018220bfc98/small.jpg</picture_url>
        </person>
        <person>
          <role>Organization Co-chair</role>
          <sort_key>2</sort_key>
          <first_name>Nate</first_name>
          <last_name>Foster</last_name>
          <affiliation>Cornell University</affiliation>
          <bio>Nate Foster is an Associate Professor of Computer Science at Cornell University. The goal of his research is to develop languages and tools that make it easy for programmers to build secure and reliable systems. His current work focuses on the design and implementation of languages for programming software-defined networks. In the past he has also worked on bidirectional languages (also known as “lenses”), database query languages, data provenance, type systems, mechanized proof, and formal semantics. He received a PhD in Computer Science from the University of Pennsylvania, an MPhil in History and Philosophy of Science from Cambridge University, and a BA in Computer Science from Williams College. His awards include a Sloan Research Fellowship, an NSF CAREER Award, a Most Influential POPL Paper Award, a Tien ’72 Teaching Award, a Google Research Award, a Yahoo! Academic Career Enhancement Award, a Cornell Engineering Research Excellence Award, and the Morris and Dorothy Rubinoff Award.</bio>
          <homepage_url>http://www.cs.cornell.edu/~jnfoster/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/natefoster/fc11e437-6a66-45e4-b6a3-c4b879fa2e7c/small.jpg</picture_url>
        </person>
        <person>
          <role>Organization Co-chair</role>
          <sort_key>3</sort_key>
          <first_name>Todd</first_name>
          <last_name>Millstein</last_name>
          <affiliation>University of California, Los Angeles</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.cs.ucla.edu/~todd/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/toddmillstein1/a55642b6-6fa2-40f6-99ba-8b9003ee61d9/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>NetPL 2018</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>40394968-5705-43bf-9dd1-10f5d3bcf503</slot_id>
      <title>Invited Talk 7</title>
      <room>Omni Hotel | NetPL</room>
      <date>2018/01/09</date>
      <start_time>16:30</start_time>
      <end_time>17:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>invited speaker</role>
          <sort_key>1</sort_key>
          <first_name>George</first_name>
          <last_name>Varghese</last_name>
          <affiliation>UCLA</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>NetPL 2018</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>77ecea3a-54fe-4194-a945-db3443980981</slot_id>
      <title>Panel</title>
      <room>Omni Hotel | NetPL</room>
      <date>2018/01/09</date>
      <start_time>17:00</start_time>
      <end_time>17:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Moderator</role>
          <sort_key>1</sort_key>
          <first_name>Nate</first_name>
          <last_name>Foster</last_name>
          <affiliation>Cornell University</affiliation>
          <bio>Nate Foster is an Associate Professor of Computer Science at Cornell University. The goal of his research is to develop languages and tools that make it easy for programmers to build secure and reliable systems. His current work focuses on the design and implementation of languages for programming software-defined networks. In the past he has also worked on bidirectional languages (also known as “lenses”), database query languages, data provenance, type systems, mechanized proof, and formal semantics. He received a PhD in Computer Science from the University of Pennsylvania, an MPhil in History and Philosophy of Science from Cambridge University, and a BA in Computer Science from Williams College. His awards include a Sloan Research Fellowship, an NSF CAREER Award, a Most Influential POPL Paper Award, a Tien ’72 Teaching Award, a Google Research Award, a Yahoo! Academic Career Enhancement Award, a Cornell Engineering Research Excellence Award, and the Morris and Dorothy Rubinoff Award.</bio>
          <homepage_url>http://www.cs.cornell.edu/~jnfoster/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/natefoster/fc11e437-6a66-45e4-b6a3-c4b879fa2e7c/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>NetPL 2018</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>822ea969-29a6-45c1-bfdf-5a3b6b258e6e</slot_id>
      <title>Invited Talk 6</title>
      <room>Omni Hotel | NetPL</room>
      <date>2018/01/09</date>
      <start_time>16:00</start_time>
      <end_time>16:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>invited speaker</role>
          <sort_key>1</sort_key>
          <first_name>Calin</first_name>
          <last_name>Cascaval</last_name>
          <affiliation>Barefoot Networks</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://home.cascaval.us/calin</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>NetPL 2018</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d702cfe8-17d0-4dfa-a1bb-3ef2ded4bec8</subevent_id>
    <title> : Keynote</title>
    <subevent_type type="regular"/>
    <room>CoqPL</room>
    <date>2018/01/13</date>
    <url>https://popl18.sigplan.org/track/CoqPL-2018</url>
    <url_link_display>The Fourth International Workshop on Coq for Programming Languages</url_link_display>
    <tracks>
      <track>The Fourth International Workshop on Coq for Programming Languages</track>
    </tracks>
    <timeslot>
      <slot_id>4bad6b1d-4357-41ac-9f9d-77fc7c418870</slot_id>
      <title>CoqHammer: Strong Automation for Program Verification</title>
      <room>Omni Hotel | CoqPL</room>
      <date>2018/01/13</date>
      <start_time>09:00</start_time>
      <end_time>10:00</end_time>
      <description>We present CoqHammer: the first full hammer system for the Coq proof assistant. The system translates Coq logic to untyped first-order logic and uses external automated theorem provers (ATPs) to prove the translations of user given conjectures. Based on the output of the ATPs, the conjecture is then re-proved in the logic of Coq using an eauto-type proof search algorithm. Together with machine-learning based selection of relevant premises this constitutes a full hammer system.
The performance of the overall procedure has been evaluated in a bootstrapping scenario emulating the development of the Coq standard library. Over 40% of the theorems in the Coq standard library can be proved in a push-button mode in about 40 seconds of real time on a 8-CPU system. This offers a huge saving of human work in programming language formalizations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lukasz</first_name>
          <last_name>Czajka</last_name>
          <affiliation>University of Innsbruck</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mimuw.edu.pl/~lukaszcz/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Cezary</first_name>
          <last_name>Kaliszyk</last_name>
          <affiliation>University of Innsbruck</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cl-informatik.uibk.ac.at/users/cek/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/cezarykaliszyk/bc2b6c58-bf34-4432-a7a0-95b36c02bba4/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>The Fourth International Workshop on Coq for Programming Languages</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a0e13360-58c2-477d-a607-11d570dff777</subevent_id>
    <title> : Semantics and Synthesis</title>
    <subevent_type type="regular"/>
    <room>CoqPL</room>
    <date>2018/01/13</date>
    <url>https://popl18.sigplan.org/track/CoqPL-2018</url>
    <url_link_display>The Fourth International Workshop on Coq for Programming Languages</url_link_display>
    <tracks>
      <track>The Fourth International Workshop on Coq for Programming Languages</track>
    </tracks>
    <timeslot>
      <slot_id>3e2f8bf6-0dc9-4cda-b503-8cd9f03fd958</slot_id>
      <title>A calculus for logical refinements in separation logic</title>
      <room>Omni Hotel | CoqPL</room>
      <date>2018/01/13</date>
      <start_time>17:40</start_time>
      <end_time>18:05</end_time>
      <description>We present a formalization of logical refinements of programs in a higher-order programming languages with general references, polymorphism and existential types, and concurrency. The logical refinement is sound w.r.t. contextual refinements of programs, and has been formalized in Coq, together with a number of case studies, in state of the art concurrent separation logic Iris. The work extends on the initial interpretation of logical relations in Iris by Krebbers et al., to the extent that we provide a calculus that allows one to reason about logical refinement in an abstract way, together with a collection of Coq tactics that make reasoning in the calculus tractable for realistic examples.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dan</first_name>
          <last_name>Frumin</last_name>
          <affiliation>Radboud University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Robbert</first_name>
          <last_name>Krebbers</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://robbertkrebbers.nl</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>The Fourth International Workshop on Coq for Programming Languages</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6463802b-7724-4db4-a971-27226e79b924</slot_id>
      <title>Towards Context-Aware Data Refinement</title>
      <room>Omni Hotel | CoqPL</room>
      <date>2018/01/13</date>
      <start_time>16:50</start_time>
      <end_time>17:15</end_time>
      <description>Abstract: Fiat is a deductive synthesis framework for deriving correct-by-construction implementations of abstract data types in Coq. The framework uses the representation independence provided by data abstraction to ensure that a derived implementation meets the specification for any possible client. The restriction that an implementation works for every client removes potential optimizations that would be correct for a particular client, however. The proposed talk discuss our ongoing work on formalizing a relaxation of data refinement in order to enable synthesis of implementations that are tailored to a particular client, while preserving the same representation independence guarantees programmers are used to.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Paul</first_name>
          <last_name>Krogmeier</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Steven</first_name>
          <last_name>Kidd</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benjamin</first_name>
          <last_name>Delaware</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/bendy/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/benjamindelaware/39bbf6b3-d145-435c-8956-8acf8cfcaffa/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>The Fourth International Workshop on Coq for Programming Languages</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9302761a-25fd-4bdc-820c-5df1752f130b</slot_id>
      <title>Mechanizing the Construction and Rewriting of Proper Functions in Coq</title>
      <room>Omni Hotel | CoqPL</room>
      <date>2018/01/13</date>
      <start_time>17:15</start_time>
      <end_time>17:40</end_time>
      <description>The notion of monotonic, or order-preserving, functions is a key notion in programming languages semantics, being used in both logical relations and denotational semantics. In Coq, monotonic functions are also known as Proper functions, because they are usually defined with the Proper typeclass, and they are used for setoid rewriting. Although it is straightforward to define a Coq type for Proper functions, it is onerous and time-consuming to build any non-trivial Proper functions in this type, as the user has to manually write the proofs of monotonicity at every Proper abstraction. Further, rewriting these Proper functions requires rewriting their proofs as well, which can increase the size of expressions dramatically with each rewrite step.
In this talk, ongoing work will be presented that addresses both of these problems. To build Proper functions, a collection of Coq typeclass instances and notations are used to automatically build monotonicity proofs, effectively creating an embedded domain-specific language (EDSL) of Proper functions inside Coq. To rewrite Proper functions, they are first reflected into a Coq inductive datatype that represents Proper functions without requiring monotonicity proofs. This reflection is performed using a second collection of Coq typeclass instances. Because this inductive datatype does not require monotonicity proofs, rewriting becomes orders of magnitude more efficient.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Edwin</first_name>
          <last_name>Westbrook</last_name>
          <affiliation>Galois, Inc.</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>The Fourth International Workshop on Coq for Programming Languages</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d3d4a190-1c4d-414e-8e1f-f23b5ab88a39</slot_id>
      <title>Revisiting Parametricity: Inductives and Uniformity of Propositions</title>
      <room>Omni Hotel | CoqPL</room>
      <date>2018/01/13</date>
      <start_time>16:25</start_time>
      <end_time>16:50</end_time>
      <description>Reynolds’ parametricity theory captures the property that parametrically polymorphic functions behave uniformly: they produce related results on related instantiations. In dependently-typed programming languages, such relations and uniformity proofs can be expressed internally, and generated as a program translation.
We present a new parametricity translation for a significant fragment of Coq. Previous translations of parametrically polymorphic propositions allowed non-uniformity. For example, on related instantiations, a function may return propositions that are logically inequivalent (e.g. True and False). We show that uniformity of polymorphic propositions is not achievable in general. Nevertheless, our translation produces proofs that the two propositions are logically equivalent and also that any two proofs of those propositions are related. This is achieved at the cost of potentially requiring more assumptions on the instantiations, requiring them to be isomorphic in the worst case.
Our translation augments the previous one for Coq by carrying and compositionally building extra proofs about parametricity relations. It is made easier by a new method for translating inductive types and pattern matching. The new method builds upon and generalizes previous such translations for dependently-typed programming languages.
Using reification and reflection, we have implemented our translation as Coq programs. We obtain several stronger free theorems applicable to an ongoing compiler-correctness project. Previously, proofs of some of these theorems took several hours to finish.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Abhishek</first_name>
          <last_name>Anand</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Greg</first_name>
          <last_name>Morrisett</last_name>
          <affiliation>Cornell University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cornell.edu/~jgm/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>The Fourth International Workshop on Coq for Programming Languages</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ed444518-d437-48dd-92f0-9baad8670cfc</slot_id>
      <title>Phantom Types for Quantum Programs</title>
      <room>Omni Hotel | CoqPL</room>
      <date>2018/01/13</date>
      <start_time>16:00</start_time>
      <end_time>16:25</end_time>
      <description>We explore the design space of using dependent types to type check and verify quantum circuits. We weigh the trade-offs between the expressivity of dependent types against the costs imposed by large proof terms. We propose lightweight dependent types, or phantom types, as a middle ground, which provide useful type information for programming while specifying the properties to be externally verified.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Robert</first_name>
          <last_name>Rand</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>I am a PhD student in the Programming Languages Research Group at the University of Pennsylvania, advised by Dr. Steve Zdancewic. My research interests span probability theory, quantum computing, programming languages and formal verification. I’m currently working on QWIRE, a quantum programming language embedded in the Coq proof assistant.</bio>
          <homepage_url>http://www.cis.upenn.edu/~rrand/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/robertrand/55e0e41c-245e-4474-9dcc-038bb78ec518/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jennifer</first_name>
          <last_name>Paykin</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.seas.upenn.edu/~jpaykin/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/jenniferpaykin/61f6fdf3-10dd-4e5d-98bd-6aa4644432b8/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Steve</first_name>
          <last_name>Zdancewic</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cis.upenn.edu/~stevez</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/stevezdancewic/41b883c6-4689-4ae3-b6f1-6b7a24622e99/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>The Fourth International Workshop on Coq for Programming Languages</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4a1169f0-da18-4342-a03c-bd7e99d5d6ed</subevent_id>
    <title> : PL Metatheory</title>
    <subevent_type type="regular"/>
    <room>CoqPL</room>
    <date>2018/01/13</date>
    <url>https://popl18.sigplan.org/track/CoqPL-2018</url>
    <url_link_display>The Fourth International Workshop on Coq for Programming Languages</url_link_display>
    <tracks>
      <track>The Fourth International Workshop on Coq for Programming Languages</track>
    </tracks>
    <timeslot>
      <slot_id>8b72f12a-5cc6-4fd4-9c7e-d4974c44a492</slot_id>
      <title>A Coq Formalisation of a Core of R</title>
      <room>Omni Hotel | CoqPL</room>
      <date>2018/01/13</date>
      <start_time>14:25</start_time>
      <end_time>14:50</end_time>
      <description>Real-world programming languages have subtle behaviours. In particular, their semantics is often associated with various corner cases. Programmers are sometimes unaware of all these corner cases, which can yield to serious bugs. This is an opportunity for our community as Coq provides a way to certify the behaviour of a program. But if the certified program is not written in Coq, such a certification relies on a formal semantics of its programming language. In the case of a real-world language, such a semantics can be as difficult to trust as the original program. Some previous work proposed ways to trust such large semantics. This work evaluates the feasibility of such a large-scale formalisation in the case of the R programming language—a trending programming language specialised in statistics. We introduce a formalisation of the core of R related to the reference R interpreter.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Martin</first_name>
          <last_name>Bodin</last_name>
          <affiliation>CMM</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cmm.uchile.cl/~mbodin/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>The Fourth International Workshop on Coq for Programming Languages</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>928f92e9-e60e-4022-9758-02dc0096fc40</slot_id>
      <title>Locally Nameless at Scale</title>
      <room>Omni Hotel | CoqPL</room>
      <date>2018/01/13</date>
      <start_time>14:00</start_time>
      <end_time>14:25</end_time>
      <description>The Corespec project is an extensive mechanization in Coq of the metatheory of System D and System DC, two related, dependently-typed languages aimed at replacing the GHC’s internal language, Core. In this talk, we take a retrospective look at our development through the lens of a recent addition, eta-equivalence. In particular, we describe our experience with the practical application of locally nameless variable-binding representation for mechanized metatheory, supported by the Ott and LNgen tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Stephanie</first_name>
          <last_name>Weirich</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cis.upenn.edu/~sweirich/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/stephanieweirich/1f63ace9-e52a-4efc-b20b-ee75b5d7d091/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Antoine</first_name>
          <last_name>Voizard</last_name>
          <affiliation>University of Pennsylvannia</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Anastasiya</first_name>
          <last_name>Kravchuk-Kirilyuk</last_name>
          <affiliation>	University of Pennsylvania</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>The Fourth International Workshop on Coq for Programming Languages</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8537af26-a37c-48cc-a7d2-e2c3e4763912</subevent_id>
    <title> : Tactics and Proof Engineering</title>
    <subevent_type type="regular"/>
    <room>CoqPL</room>
    <date>2018/01/13</date>
    <url>https://popl18.sigplan.org/track/CoqPL-2018</url>
    <url_link_display>The Fourth International Workshop on Coq for Programming Languages</url_link_display>
    <tracks>
      <track>The Fourth International Workshop on Coq for Programming Languages</track>
    </tracks>
    <timeslot>
      <slot_id>210e3522-1fcb-4ec8-87ea-e22026553909</slot_id>
      <title>Elpi: an extension language for Coq</title>
      <room>Omni Hotel | CoqPL</room>
      <date>2018/01/13</date>
      <start_time>11:20</start_time>
      <end_time>11:45</end_time>
      <description>Elpi is dialect of λProlog that can be used as an extension language for Coq. It lets one define commands and tactics in a high level programming language tailored to the manipulation of syntax trees containing binders and existentially quantified meta variables.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Enrico</first_name>
          <last_name>Tassi</last_name>
          <affiliation>INRIA</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>The Fourth International Workshop on Coq for Programming Languages</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4b9bc275-1412-4b01-a701-b4ab6fa7cf75</slot_id>
      <title>Typed Template Coq</title>
      <room>Omni Hotel | CoqPL</room>
      <date>2018/01/13</date>
      <start_time>10:55</start_time>
      <end_time>11:20</end_time>
      <description>Template-Coq is a plugin for Coq, originally implemented by Malecha, which provides a reifier for Coq terms and global declarations, as represented in the Coq kernel, as well as a denotation command. Initially, it was developed for the purpose of writing simple functions on Coq ’s AST. Recently, its use was extended for the needs of the CertiCoq certified compiler project, which uses it as its frontend language (CertiCoq compiles Gallina terms to CompCert’s CLight), and the work of Forter and Kunze on extracting Coq terms to a CBV lambda-calculus. However, the syntax currently lacks semantics, be it typing semantics or operational semantics, which should reflect as formal specifications in Coq the semantics of Coq itself. This is an issue for CertiCoq where both a non-deterministic small step semantics and a deterministic call-by-value big step semantics had to be defined and preserved, without an official specification to refer to. Our hope with this work is to remedy this situation and provide a formal semantics of Coq’s implemented type theory, that can independently be refined and studied. By implementing a (partial) independent checker in Coq, we can also help formalize certified translations from Coq to Coq.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Simon</first_name>
          <last_name>Boulier</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Matthieu</first_name>
          <last_name>Sozeau</last_name>
          <affiliation>Inria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.pps.univ-paris-diderot.fr/~sozeau/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/matthieusozeau/d1a3ad89-73f4-44cc-8f0b-830f395d9953/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nicolas</first_name>
          <last_name>Tabareau</last_name>
          <affiliation>Inria, France</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Abhishek</first_name>
          <last_name>Anand</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>The Fourth International Workshop on Coq for Programming Languages</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bd3ab8a7-ba43-4270-88da-1fa69b31dff6</slot_id>
      <title>Coqatoo: Generating Natural Language Versions of Coq Proofs</title>
      <room>Omni Hotel | CoqPL</room>
      <date>2018/01/13</date>
      <start_time>11:45</start_time>
      <end_time>12:10</end_time>
      <description>We present Coqatoo, a command-line utility capable of automatically generating natural language versions of Coq proofs. We illustrate its use on a simple proof.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Andrew</first_name>
          <last_name>Bedford</last_name>
          <affiliation>Laval University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://andrew-bedford.ca</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/andrewbedford/9da22383-8380-4af6-9b75-816ba5a96ec1/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>The Fourth International Workshop on Coq for Programming Languages</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cd8fcf9d-939b-49b6-ba60-2c7492fc1267</slot_id>
      <title>A “destruct” Tactic for Mtac2</title>
      <room>Omni Hotel | CoqPL</room>
      <date>2018/01/13</date>
      <start_time>10:30</start_time>
      <end_time>10:55</end_time>
      <description>We present a “destruct” tactic that supports dependent types written in Mtac2. The tactic is implemented to a large degree in Coq itself — only using Mtac2’s unsafe features when absolutely necessary. To this end, the development includes fully-typed descriptions of 1) inductive datatypes, 2) arguments of inductive datatypes, 3) constructors of inductive dataypes, 4) branches of matches on values of inductive datatypes, and 5) return types of matches on values of inductive datatypes. Additionally, we also propose a way of dealing with meta-programs that are parametric in Prop/Type.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jan-Oliver</first_name>
          <last_name>Kaiser</last_name>
          <affiliation>MPI-SWS</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Beta</first_name>
          <last_name>Ziliani</last_name>
          <affiliation>FAMAF, UNC and CONICET</affiliation>
          <bio>Currently researcher in the group LIIS at FAMAF, UNC and CONICET (Argentina).
From 04/2015 to 10/2015 Postdoc at LIIS.
PhD from MPI-SWS (Germany), supervisor Dr. Derek Dreyer.
MSc from FCEyN, UBA.</bio>
          <homepage_url>http://people.mpi-sws.org/~beta/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/betaziliani/293e6140-bcd4-4e3f-85ae-b8ec673bbfba/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>The Fourth International Workshop on Coq for Programming Languages</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9685d9bb-c83f-4422-bbc0-8ef7318c378d</subevent_id>
    <title> : Coq developers talk &amp; panel</title>
    <subevent_type type="regular"/>
    <room>CoqPL</room>
    <date>2018/01/13</date>
    <url>https://popl18.sigplan.org/track/CoqPL-2018</url>
    <url_link_display>The Fourth International Workshop on Coq for Programming Languages</url_link_display>
    <tracks>
      <track>The Fourth International Workshop on Coq for Programming Languages</track>
    </tracks>
    <timeslot>
      <slot_id>c78027cd-5f45-4556-b598-c3ba9e4473c3</slot_id>
      <title>Session with the Coq Development Team</title>
      <room>Omni Hotel | CoqPL</room>
      <date>2018/01/13</date>
      <start_time>14:50</start_time>
      <end_time>15:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matthieu</first_name>
          <last_name>Sozeau</last_name>
          <affiliation>Inria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.pps.univ-paris-diderot.fr/~sozeau/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/matthieusozeau/d1a3ad89-73f4-44cc-8f0b-830f395d9953/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Maxime</first_name>
          <last_name>Dénès</last_name>
          <affiliation>INRIA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.maximedenes.fr/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yves</first_name>
          <last_name>Bertot</last_name>
          <affiliation>INRIA</affiliation>
          <bio>Research at Inria since 1992. co-author of a book on “Interactive Theorem Proving and Program Development, Coq’Art: the Calculus of Inductive Constructions”. Recipient of the 2013 ACM Software System award, along with developers of the Coq system.</bio>
          <homepage_url>http://www-sop.inria.fr/members/Yves.Bertot/index.html</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/yvesbertot/693d2381-59b8-4c1d-bd53-64b47fdef7ed/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>The Fourth International Workshop on Coq for Programming Languages</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>cc8eb387-a91a-4fb2-b993-ebab4c78bf2c</subevent_id>
    <title>CPP 2018: Invited Talk by Brigitte Pientka</title>
    <subevent_type type="regular"/>
    <room>CPP</room>
    <date>2018/01/09</date>
    <url>https://popl18.sigplan.org/track/CPP-2018</url>
    <url_link_display>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</url_link_display>
    <tracks>
      <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
    </tracks>
    <timeslot>
      <slot_id>0ba5a4d9-6eab-4dfd-bc4e-d98c1bb30a32</slot_id>
      <title>POPLMark Reloaded: Mechanizing Logical Relations Proofs (Invited Talk)</title>
      <room>Omni Hotel | CPP</room>
      <date>2018/01/09</date>
      <start_time>09:00</start_time>
      <end_time>10:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Brigitte</first_name>
          <last_name>Pientka</last_name>
          <affiliation>McGill University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.mcgill.ca/~bpientka/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/brigittepientka/de1fcba2-a8fd-4b6e-a4f2-b7d397fef2cf/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>40401c1c-7e49-4ecb-89b4-5090a80c08cf</subevent_id>
    <title>PEPM 2018: Session 1-1</title>
    <subevent_type type="regular"/>
    <room>PEPM</room>
    <date>2018/01/08</date>
    <url>https://popl18.sigplan.org/track/PEPM-2018</url>
    <url_link_display>— ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation</url_link_display>
    <tracks>
      <track>— ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation</track>
    </tracks>
    <timeslot>
      <slot_id>79ffbefb-58fd-4e72-9a7d-935ff3856131</slot_id>
      <title>Developments in Property-Based Testing (Invited Talk)</title>
      <room>Omni Hotel | PEPM</room>
      <date>2018/01/08</date>
      <start_time>10:30</start_time>
      <end_time>11:30</end_time>
      <description>Property-based testing (aka. QuickCheck) is a successful automated testing approach originating in the programming language community (Claessen-Hughes:ICFP00). It unites the well-known idea of randomized testing with that of ensuring program-specific properties akin to those encountered within verification and theorem proving. Starting as a Haskell library the approach has grown to become language independent with ports to over 30 different programming languages. Over the years property-based testing has been used to pinpoint an impressive amount of software errors in a multitude of settings, initially within academia but more and more so also in the software industry.
In this talk I will first recall the basic concepts of property-based testing and then cover a couple of recent applications, while sharing some of the folklore and community know-how. This includes quite a bit of symbolic program manipulation at the heart of the PEPM community. I will then offer a personal perspective on the approach, both in terms of programming language theory and software engineering.</description>
      <persons>
        <person>
          <role>invited speaker</role>
          <sort_key>1</sort_key>
          <first_name>Jan</first_name>
          <last_name>Midtgaard</last_name>
          <affiliation>University of Southern Denmark</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://janmidtgaard.dk/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/janmidtgaard/deb4aff7-1902-4d2f-8512-c8968c89e722/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>— ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ce485dd4-436d-4d62-a6ba-c6bb9fdb3c8f</slot_id>
      <title>Selective CPS Transformation for Shift and Reset</title>
      <room>Omni Hotel | PEPM</room>
      <date>2018/01/08</date>
      <start_time>11:30</start_time>
      <end_time>12:00</end_time>
      <description>This paper presents a selective CPS transformation for a program that uses delimited continuation constructs, shift and reset, introduced by Danvy and Filinski in a typed setting. By selectively CPS-transforming a program, we can execute a program with shift and reset in the standard functional language without support for control operators. We introduce a constraint-based type inference system that annotates the parts that are captured by shift and thus require CPS transformation. We show that the best annotation does not exist in general, and present a constraint solving algorithm that is reasonably efficient. The selective CPS transformation is defined over annotated terms and its correctness is proven. Finally, experimental results show that selective CPS transformation does improve the performance compared to the standard CPS transformation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kenichi</first_name>
          <last_name>Asai</last_name>
          <affiliation>Ochanomizu University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pllab.is.ocha.ac.jp/~asai/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/kenichiasai/8f4ff835-8fd8-4b50-bcae-abd92601a71b/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Chihiro</first_name>
          <last_name>Uehara</last_name>
          <affiliation>Ochanomizu University</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>— ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>069e1ed9-bf3f-418c-847b-f579e8653b06</subevent_id>
    <title>PEPM 2018: Session 2-2</title>
    <subevent_type type="regular"/>
    <room>PEPM</room>
    <date>2018/01/09</date>
    <url>https://popl18.sigplan.org/track/PEPM-2018</url>
    <url_link_display>— ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation</url_link_display>
    <tracks>
      <track>— ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation</track>
    </tracks>
    <timeslot>
      <slot_id>28b2f3f3-8ad3-4f5a-bc4f-94c89875c8fb</slot_id>
      <title>Recursive Programs in Normal Form (Short Paper)</title>
      <room>Omni Hotel | PEPM</room>
      <date>2018/01/09</date>
      <start_time>15:00</start_time>
      <end_time>15:30</end_time>
      <description>Recursive programs can now be expressed as normal forms within some rewriting systems, including traditional combinatory logic, a new variant of lambda-calculus called closure calculus, and recent variants of combinatory logic that support queries of internal program structure. In all these settings, partial evaluation of primitive recursive functions, such as addition, can reduce open terms to normal form without fear of non-termination. In those settings where queries of program structure are supported, program optimizations that are expressed as non-standard rewriting rules can be represented as functions in the calculus, without any need for quotation or other meta-theory.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Barry</first_name>
          <last_name>Jay</last_name>
          <affiliation>University of Technology Sydney</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>— ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>539bf32c-f287-4071-837f-8adc2afb3887</slot_id>
      <title>Program Generation for ML Modules (Short Paper)</title>
      <room>Omni Hotel | PEPM</room>
      <date>2018/01/09</date>
      <start_time>14:30</start_time>
      <end_time>15:00</end_time>
      <description>Program generation has been successful in generating high-performance code in highly modular way. Yet, programming-language supports for program generation needs further improvement. One important omission is the functionality of generating modules in a type safe way. Inoue et al. have addressed this issue in 2016, but investigated only a few examples. We propose a language as an extension of (small subset of) MetaOCaml in which one can manipulate and generate code of modules, and implement it based on a simple translation to an existing language. We show that our language solves the performance problem in functor applications and that it provides a suitable basis of hand-written custom code generators for modules.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Takahisa</first_name>
          <last_name>Watanabe</last_name>
          <affiliation>University of Tsukuba, Japan</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yukiyoshi</first_name>
          <last_name>Kameyama</last_name>
          <affiliation>University of Tsukuba, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tsukuba.ac.jp/~kam/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/yukiyoshikameyama/a7ae9aee-0992-4ddf-ae1d-6fee59d9e814/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>— ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8c4dfd7a-6620-416c-85b2-97f88930b590</slot_id>
      <title>Partially Static Data as Free Extension of Algebras (Short Paper)</title>
      <room>Omni Hotel | PEPM</room>
      <date>2018/01/09</date>
      <start_time>14:00</start_time>
      <end_time>14:30</end_time>
      <description>Partially-static data structures are a well-known technique for improving binding times. However, they are often defined in an ad-hoc manner, without a unifying framework that ensures full use of the equations associated with each operation.
We present a foundational view of partially-static data structures as free extensions of algebras for suitable equational theories, i.e.~the coproduct of an algebra and a free algebra in the category of algebras and their homomorphisms. By precalculating these free extensions, we construct a high-level library of partially static data representations for common algebraic structures. We demonstrate our library with common use-cases from the literature string and list manipulation, linear algebra, and numerical simplification.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jeremy</first_name>
          <last_name>Yallop</last_name>
          <affiliation>University of Cambridge, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cl.cam.ac.uk/~jdy22/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tamara</first_name>
          <last_name>von Glehn</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ohad</first_name>
          <last_name>Kammar</last_name>
          <affiliation>University of Oxford</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ox.ac.uk/people/ohad.kammar/main.html</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/ohadkammar/1336a5cb-4d72-49de-898d-ce768d425a55/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>— ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b534e0c3-0fd7-4494-b554-92ea6185d5d1</subevent_id>
    <title>CPP 2018: Verifing Programs and Systems</title>
    <subevent_type type="regular"/>
    <room>CPP</room>
    <date>2018/01/08</date>
    <url>https://popl18.sigplan.org/track/CPP-2018</url>
    <url_link_display>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</url_link_display>
    <tracks>
      <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
    </tracks>
    <timeslot>
      <slot_id>25ca37f4-1db8-4b24-8589-5db24247389e</slot_id>
      <title>A Formal Proof in Coq of a Control Function for the Inverted Pendulum</title>
      <room>Omni Hotel | CPP</room>
      <date>2018/01/08</date>
      <start_time>11:00</start_time>
      <end_time>11:30</end_time>
      <description>Control theory provides techniques to design controllers, or control functions, for dynamical systems with inputs, so as to grant a particular behaviour of such a system. The inverted pendulum is a classic system in control theory: it is used as a benchmark for nonlinear control techniques and is a model for several other systems with various applications. We formalized in the {\sc Coq} proof assistant the proof of soundness of a control function for the inverted pendulum. This is a first step towards the formal verification of more complex systems for which safety may be critical.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Damien</first_name>
          <last_name>Rouhling</last_name>
          <affiliation>University of Côte d'Azur, France</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>50937020-1008-411b-a87e-cb9d2d55abb6</slot_id>
      <title>Total Haskell is Reasonable Coq</title>
      <room>Omni Hotel | CPP</room>
      <date>2018/01/08</date>
      <start_time>10:30</start_time>
      <end_time>11:00</end_time>
      <description>We would like to use the Coq proof assistant to mechanically verify properties of Haskell programs. To that end, we present a tool, named &amp;lt;tt&amp;gt;hs-to-coq&amp;lt;/tt&amp;gt;, that translates total Haskell programs into Coq programs via a shallow embedding. We apply our tool in three case studies – a lawful &amp;lt;tt&amp;gt;Monad&amp;lt;/tt&amp;gt; instance, “Hutton’s razor”, and an existing data structure library – and prove their correctness. These examples show that this approach is viable: both that &amp;lt;tt&amp;gt;hs-to-coq&amp;lt;/tt&amp;gt; applies to existing Haskell code, and that the output it produces is amenable to verification.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Antal</first_name>
          <last_name>Spector-Zabusky</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Joachim</first_name>
          <last_name>Breitner</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cis.upenn.edu/~joachim/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/joachimbreitner/2bc58f26-64bd-4bda-a3d8-a97c89b419fc/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Christine</first_name>
          <last_name>Rizkallah</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.mpi-inf.mpg.de/~crizkall/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/christinerizkallah/e181f947-fb32-4d02-a0e9-085ff6318d78/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Stephanie</first_name>
          <last_name>Weirich</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cis.upenn.edu/~sweirich/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/stephanieweirich/1f63ace9-e52a-4efc-b20b-ee75b5d7d091/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cfb28839-1363-46fd-b050-356ac9c7f9b3</slot_id>
      <title>Completeness and Decidability of Converse PDL in the Constructive Type Theory of Coq</title>
      <room>Omni Hotel | CPP</room>
      <date>2018/01/08</date>
      <start_time>11:30</start_time>
      <end_time>12:00</end_time>
      <description>The completeness proofs for Propositional Dynamic Logic (PDL) in the literature are non-constructive and usually presented in an informal manner. We obtain a formal and constructive completeness proof for Converse PDL by recasting a completeness proof by Kozen and Parikh into our constructive setting. We base our proof on a Pratt-style decision method for satisfiability constructing finite models for satisfiable formulas and pruning refutations for unsatisfiable formulas. Completeness of Segerberg's axiomatization of PDL is then obtained by translating pruning refutations to derivations in the Hilbert system. We first treat PDL without converse and then extend the proofs to Converse PDL. All results are formalized in Coq/Ssreflect.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christian</first_name>
          <last_name>Doczkal</last_name>
          <affiliation>CNRS, France</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Joachim</first_name>
          <last_name>Bard</last_name>
          <affiliation>Saarland University, Germany</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e8428a40-0d99-47aa-bf7a-afc180086e54</subevent_id>
    <title>CPP 2018: Formalizing Meta-Theory</title>
    <subevent_type type="regular"/>
    <room>CPP</room>
    <date>2018/01/09</date>
    <url>https://popl18.sigplan.org/track/CPP-2018</url>
    <url_link_display>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</url_link_display>
    <tracks>
      <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
    </tracks>
    <timeslot>
      <slot_id>0b96b255-e4a1-4815-9a48-df872d5354c7</slot_id>
      <title>Binder Aware Recursion over Well-Scoped de Bruijn Syntax</title>
      <room>Omni Hotel | CPP</room>
      <date>2018/01/09</date>
      <start_time>17:30</start_time>
      <end_time>18:00</end_time>
      <description>The de~Bruijn representation of syntax with binding is commonly used, but flawed when it comes to recursion. As the structural recursion principle associated to an inductive type of expressions is unaware of the binding discipline, each recursive definition requires a separate proof of compatibility with variable instantiation. We solve this problem by extending Allais' notion of syntax traversals to obtain a framework for instantiation-compatible recursion. The framework is general enough to handle multivariate, potentially mutually recursive syntactic systems.
With our framework we define variable renaming and instantiation, syntax directed typing and certain unary logical relations for System~F. These definitons lead to concise proofs of type preservation, as well as weak and strong normalisation.
Our framework is designed to serve as the theoretical foundation of future versions of the Autosubst Coq library. All developments and case studies are formalised in the Coq proof assistant.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jonas</first_name>
          <last_name>Kaiser</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Steven</first_name>
          <last_name>Schäfer</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl18.sigplan.org/getProfileImage/stevenschafer/ca198129-c83e-48bb-a5e0-07c1cea127f9/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Kathrin</first_name>
          <last_name>Stark</last_name>
          <affiliation>Saarland University, Germany</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cf1d5ec6-47bd-4687-bc5d-d0d26a06dec7</slot_id>
      <title>A Coq Formalization of Normalization by Evaluation for Martin-Löf Type Theory</title>
      <room>Omni Hotel | CPP</room>
      <date>2018/01/09</date>
      <start_time>16:30</start_time>
      <end_time>17:00</end_time>
      <description>We present a Coq formalization of the normalization-by-evaluation algorithm for Martin-Löf dependent type theory with one universe and judgmental equality. The end results of the formalization are certified implementations of a reduction-free normalizer and of a decision procedure for term equality.
The formalization takes advantage of a graph-based variant of the Bove-Capretta method to encode mutually recursive evaluation functions with nested recursive calls. The proof of completeness, which uses the PER-model of dependent types, is formalized by relying on impredicativity of the Coq system rather than on the commonly used induction-recursion scheme which is not available in Coq. The proof of soundness is formalized by encoding logical relations as partial functions.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Paweł</first_name>
          <last_name>Wieczorek</last_name>
          <affiliation>University of Wrocław</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dariusz</first_name>
          <last_name>Biernacki</last_name>
          <affiliation>University of Wrocław</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e007f431-1992-49b7-863c-0bc322287b89</slot_id>
      <title>HOpi in Coq</title>
      <room>Omni Hotel | CPP</room>
      <date>2018/01/09</date>
      <start_time>16:00</start_time>
      <end_time>16:30</end_time>
      <description>We propose a formalization of HO$\pi$ in Coq, a process calculus where messages carry processes. Such a higher-order calculus features two very different kinds of binder: process input, similar to $\lambda$-abstraction, and name restriction, whose scope can be expanded by communication. We formalize strong context bisimilarity and prove it is compatible, i.e., closed under every context, using Howe’s method, based on several proof schemes we developed in a previous paper.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sergueï</first_name>
          <last_name>Lenglet</last_name>
          <affiliation>University of Lorraine, France</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alan</first_name>
          <last_name>Schmitt</last_name>
          <affiliation>Inria</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e138d8fa-824a-4fb0-9f2d-1f9df41bae1b</slot_id>
      <title>A Two-Level Logic Perspective on (Simultaneous) Substitutions</title>
      <room>Omni Hotel | CPP</room>
      <date>2018/01/09</date>
      <start_time>17:00</start_time>
      <end_time>17:30</end_time>
      <description>Lambda-tree syntax (λTS), also known as higher-order abstract syntax (HOAS), is a representational technique where the pure λ-calculus in a meta-language is used to represent binding constructs in an object language. A key feature of λTS is that capture-avoiding substitution in the object language is represented by β-reduction in the meta language. However, to reason about the meta-theory of (simultaneous) substitutions, it may seem that λTS gets in the way: not only does iterated β-reduction not capture simultaneity, but also β-redexes are not first-class constructs.
This paper proposes a representation of (simultaneous) substitutions in the two-level logic approach (2LLA), where properties of a specification language are established in a strong reasoning meta-logic that supports inductive reasoning. A substitution, which is a partial map from variables to terms, is represented in a form similar to typing contexts, which are partial maps from variables to types; both are first-class in 2LLA. The standard typing rules for substitutions are then just a kind of context relation that are already well-known in 2LLA. This representation neither changes the reasoning kernel, nor requires any modification of existing type systems, and does not sacrifice any expressivity.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kaustuv</first_name>
          <last_name>Chaudhuri</last_name>
          <affiliation>Inria, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://chaudhuri.info</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e9dda7e6-5bc3-4431-9dc2-c4c7dde47476</subevent_id>
    <title>PEPM 2018: Session 2-3</title>
    <subevent_type type="regular"/>
    <room>PEPM</room>
    <date>2018/01/09</date>
    <url>https://popl18.sigplan.org/track/PEPM-2018</url>
    <url_link_display>— ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation</url_link_display>
    <tracks>
      <track>— ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation</track>
    </tracks>
    <timeslot>
      <slot_id>1ea01e24-51a1-400a-a833-fe81dae9981d</slot_id>
      <title>Modular Macros (Poster/Demo Talk)</title>
      <room>Omni Hotel | PEPM</room>
      <date>2018/01/09</date>
      <start_time>16:30</start_time>
      <end_time>16:40</end_time>
      <description>A demonstration of Modular Macros, an extension to OCaml for typed compile-time metaprogramming</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Nicole</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Leo</first_name>
          <last_name>White</last_name>
          <affiliation>Jane Street</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jeremy</first_name>
          <last_name>Yallop</last_name>
          <affiliation>University of Cambridge, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cl.cam.ac.uk/~jdy22/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>— ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3d3fc29b-eb8b-40d0-a8d0-70250bc1a572</slot_id>
      <title>Equations: From Clauses to Splittings to Functions (Poster/Demo Talk)</title>
      <room>Omni Hotel | PEPM</room>
      <date>2018/01/09</date>
      <start_time>16:40</start_time>
      <end_time>16:50</end_time>
      <description>Equations is a plugin for the Coq proof assistant which provides a notation for defining programs by dependent pattern-matching and well-founded recursion and derives useful proof principles for demonstrating properties about them. In this presentation we give an overview of several components of Equations through the help of an example that will serve as a main thread during the session. First of all, we describe the splitting tree, the intermediate data structure used to represent a function defined by Equations. We also explain how recursive definitions are handled by Equations. Finally, we present a mostly independent module that allows to simplify equalities generated to perform dependent pattern-matching on a variable.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Cyprien</first_name>
          <last_name>Mangin</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Matthieu</first_name>
          <last_name>Sozeau</last_name>
          <affiliation>Inria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.pps.univ-paris-diderot.fr/~sozeau/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/matthieusozeau/d1a3ad89-73f4-44cc-8f0b-830f395d9953/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>— ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>93af433c-8f0c-43af-966c-3874c4f84f60</slot_id>
      <title>Towards Language-independent Code Synthesis (Poster/Demo Talk)</title>
      <room>Omni Hotel | PEPM</room>
      <date>2018/01/09</date>
      <start_time>16:00</start_time>
      <end_time>16:10</end_time>
      <description>Software engineering is routinely based on the premise that one starts a development process by modeling the desired application domain of interest. Iteratively and incrementally over time, further details are added in a seamless transition to a solution domain in which the final executable application is completed. Within this context it is difficult to identify the ideal place to apply software synthesis, that is, the ability to automate the generation of code which otherwise would have been written manually. The challenge is increased by the variety of modeling and programming languages, which are often predetermined by external project constraints such as developer experience or contractual agreements. When the application domain consists of a high degree of variability – found in product lines or highly configurable domains – we believe code synthesis plays an essential role in increasing the productivity of programmers and ensuring the quality of the resulting system. We have built a general framework that combines the language-neutral modeling power of algebra with a type-inhabitation based synthesis algorithm. The resulting framework is proven in Coq and an instance of it, prototypically implemented in Scala, will enable more comprehensive future evaluation in different domains.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jan</first_name>
          <last_name>Bessai</last_name>
          <affiliation>Technical University Dortmund</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Boris</first_name>
          <last_name>Düdder</last_name>
          <affiliation>University of Copenhagen</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>George</first_name>
          <last_name>Heineman</last_name>
          <affiliation>Worcester Polytechnic Institute</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.cs.wpi.edu/~heineman/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jakob</first_name>
          <last_name>Rehof</last_name>
          <affiliation>Technical University Dortmund</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>— ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d545c514-3029-4104-989d-f40efcd18e42</slot_id>
      <title>An Approach to Generating Text-Based IDEs with Syntax Completion (Poster/Demo Talk)</title>
      <room>Omni Hotel | PEPM</room>
      <date>2018/01/09</date>
      <start_time>16:20</start_time>
      <end_time>16:30</end_time>
      <description>Integrated development environments provide various kinds of functionalities. In this presentation we aim at generating functionalities which complete syntax and identifiers from syntax specifications, especially ones based on LR parsing. This is an ongoing work.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Isao</first_name>
          <last_name>Sasano</last_name>
          <affiliation>Shibaura Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.sic.shibaura-it.ac.jp/~sasano/index.html</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/isaosasano/b77a139b-e948-4f6c-ad81-8afe7cb17d0e/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>— ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f467b6d6-11ac-4ab7-8dee-14179dd16246</slot_id>
      <title>Posters/Demos</title>
      <room>Omni Hotel | PEPM</room>
      <date>2018/01/09</date>
      <start_time>16:50</start_time>
      <end_time>17:30</end_time>
      <description>
 Jan Bessai, Boris Düdder, George Heineman, and Jakob Rehof: Towards Language-independent Code Synthesis (Demo)
 Dominic Duggan and Jianhua Yao: Dataflow Metaprogramming (Poster)
 Isao Sasano: An Approach to Generating Text-Based IDEs with Syntax Completion (Poster and Demo)
 Olivier Nicole, Leo White, and Jeremy Yallop: Modular Macros (Demo)
 Cyprien Mangin and Matthieu Sozeau: Equations: From Clauses to Splittings to Functions (Poster and Demo)

Poster Presentations of Regular Research and Short Papers

 Duncan Mitchell, L. Thomas van Binsbergen, Blake Loring, and Johannes Kinder: Checking Cryptographic API Usage with Composable Annotations
 Ben Greenman and Zeina Migeed: On the Cost of Type-Tag Soundness
 Akifumi Imanishi, Kohei Suenaga, and Atsushi Igarashi: A Guess-and-Assume Approach to Loop Fusion for Program Verification
 Jeremy Yallop, Tamara von Glehn, and Ohad Kammar: Partially Static Data as Free Extension of Algebras
</description>
      <tracks>
        <track>— ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f6927b5d-3ab6-4cac-bf1a-485b03ffe2b9</slot_id>
      <title>Dataflow Metaprogramming (Poster/Demo Talk)</title>
      <room>Omni Hotel | PEPM</room>
      <date>2018/01/09</date>
      <start_time>16:10</start_time>
      <end_time>16:20</end_time>
      <description>Dataflow networks have application in various forms of stream processing, for example for parallel processing of multimedia data. A great deal of success has been found in the static scheduling of dataflow networks, providing predictable runtime performance and minimizing the overhead of synchronization. As such applications become larger and more complex, there is a need for mechanisms for composing such networks from components, without violating interface constraints required for safe and correct execution. Such composition will sometimes be done dynamically, including loading and replacing dataflow subgraphs at run-time. A metalanguage for expressing such composition mechanisms is considered, where metaprograms provide the glue for combining dataflow graphs. Metaprograms are related to dataflow graphs by a type and effect system that captures the firing behavior of the dataflow programs. The type system ensures the correctness of the composition of dataflow graphs, ensuring the correct scheduling of actors in the dataflow graph, in a context where the scheduler is defined as part of the application.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dominic</first_name>
          <last_name>Duggan</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jianhua</first_name>
          <last_name>Yao</last_name>
          <affiliation>Stevens Institute of Technology</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>— ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>51ea1d4e-76f8-46a8-bad3-52be3d8f96f8</subevent_id>
    <title>CPP 2018: Type Theory, Set Theory, and Formalized Mathematics</title>
    <subevent_type type="regular"/>
    <room>CPP</room>
    <date>2018/01/09</date>
    <url>https://popl18.sigplan.org/track/CPP-2018</url>
    <url_link_display>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</url_link_display>
    <tracks>
      <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
    </tracks>
    <timeslot>
      <slot_id>1e5b59aa-996b-4b12-b7f1-271b35643c08</slot_id>
      <title>Large Model Constructions for Second-Order ZF in Dependent Type Theory</title>
      <room>Omni Hotel | CPP</room>
      <date>2018/01/09</date>
      <start_time>14:30</start_time>
      <end_time>15:00</end_time>
      <description>We study various models of classical second-order set theories in the dependent type theory of Coq. Without logical assumptions, Aczel's sets-as-trees interpretation yields an intensional model of second-order ZF with functional replacement. Building on work of Werner and Barras, we discuss the need for quotient axioms in order to obtain extensional models with relational replacement and to construct large sets. Specifically, we show that the consistency strength of Coq extended by excluded middle and a description operator on well-founded trees allows for constructing models with exactly $n$ Grothendieck universes for every natural number $n$. By a previous categoricity result based on Zermelo's embedding theorem, it follows that those models are unique up to isomorphism. Moreover, we show that the smallest universe contains exactly the hereditarily finite sets and give a concise independence proof of the foundation axiom based on permutation models.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dominik</first_name>
          <last_name>Kirst</last_name>
          <affiliation>Saarland University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ps.uni-saarland.de/~kirst/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/dominikkirst/4abb14d5-8001-4d88-a1b2-07b6d1ad2cd2/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Gert</first_name>
          <last_name>Smolka</last_name>
          <affiliation>Saarland University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ps.uni-saarland.de/~smolka/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/gertsmolka/2ab7c8ce-c02d-4786-85b3-245d878ea78a/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4ecc7a67-7605-4c3b-bbfb-7d1f3e0dda09</slot_id>
      <title>A Constructive Formalisation of Semi-algebraic Sets and Functions</title>
      <room>Omni Hotel | CPP</room>
      <date>2018/01/09</date>
      <start_time>15:00</start_time>
      <end_time>15:30</end_time>
      <description>Semi-algebraic sets and semi-algebraic functions are essential to specify and certify cylindrical algebraic decomposition algorithms. We formally define in Coq the base operations on semi-algebraic sets and functions using embedded first-order formulae over the language of real closed fields, and we prove the correctness of their geometrical interpretation. In doing so, we exploit a previous formalisation of quantifier elimination on such embedded formulae to guarantee the decidability of several first-order properties and keep our development constructive. We also exploit it to formalise formulae substitution without having to handle bound variables.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Boris</first_name>
          <last_name>Djalal</last_name>
          <affiliation>INRIA</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>964b2f6c-f06d-40d2-9917-e10aae96f367</slot_id>
      <title>Finite Sets in Homotopy Type Theory</title>
      <room>Omni Hotel | CPP</room>
      <date>2018/01/09</date>
      <start_time>13:30</start_time>
      <end_time>14:00</end_time>
      <description>We study different formalizations of finite sets in homotopy type theory to obtain a general definition that exhibits both the computational facilities and the proof principles expected from finite sets. We use higher inductive types to define the type $\mathcal{K}(A)$ of ``finite sets over type $A$'' \emph{à la} Kuratowski without assuming that $\mathcal{K}(A)$ has decidable equality. We show how to define basic functions and prove basic properties after which we give two applications of our definition.
On the foundational side, we use $\mathcal{K}$ to define the notions of Kuratowski-finite type&amp;amp;#39;&amp;amp;#39; andKuratowski-finite subobject'', which we contrast with established notions, \eg Bishop-finite types and enumerated types. We argue that Kuratowski-finiteness is the most general and flexible one of those and we define the usual operations on finite types and subobjects.
From the computational perspective, we show how to use $\mathcal{K}(A)$ for an abstract interface for well-known finite set implementations such as tree- and list-like data structures. This implies that a function defined on a concrete finite sets implementation can be obtained from a function defined on the abstract finite sets $\mathcal{K}(A)$ and that correctness properties are inherited. Hence, HoTT is the ideal setting for data refinement. Beside this, we define bounded quantification, which lifts a decidable property on $A$ to one on $\mathcal{K}(A)$.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dan</first_name>
          <last_name>Frumin</last_name>
          <affiliation>Radboud University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Herman</first_name>
          <last_name>Geuvers</last_name>
          <affiliation>Radboud University Nijmegen, Netherlands</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Léon</first_name>
          <last_name>Gondelman</last_name>
          <affiliation>LRI, Université Paris-Sud</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.lri.fr/~gondelman/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Niels van der</first_name>
          <last_name>Weide</last_name>
          <affiliation>Radboud University Nijmegen, Netherlands</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fd823423-9bc3-4706-8385-7cf41ed70051</slot_id>
      <title>Generic Derivation of Induction for Impredicative Encodings in Cedille</title>
      <room>Omni Hotel | CPP</room>
      <date>2018/01/09</date>
      <start_time>14:00</start_time>
      <end_time>14:30</end_time>
      <description>This paper presents generic derivations of induction for impredicatively typed lambda-encoded datatypes, in the Cedille type theory. Cedille is a pure type theory extending the Curry-style Calculus of Constructions with implicit products, primitive heterogeneous equality, and dependent intersections. All data erase to pure lambda terms, and there is no built-in notion of datatype. The derivations are generic in the sense that we derive induction for any datatype which arises as the least fixed point of a signature functor. We consider Church-style and Mendler-style lambda-encodings. Moreover, the isomorphism of these encodings is proved. Also, we formalize Lambek's lemma as a consequence of expected laws of cancellation, reflection, and fusion.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Denis</first_name>
          <last_name>Firsov</last_name>
          <affiliation>University of Iowa, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://firsov.ee</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aaron</first_name>
          <last_name>Stump</last_name>
          <affiliation>University of Iowa, USA</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c0ca938d-7185-4d5c-bfe0-7febd5a4d2f4</subevent_id>
    <title>CPP 2018: Proof Methods and Libraries</title>
    <subevent_type type="regular"/>
    <room>CPP</room>
    <date>2018/01/08</date>
    <url>https://popl18.sigplan.org/track/CPP-2018</url>
    <url_link_display>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</url_link_display>
    <tracks>
      <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
    </tracks>
    <timeslot>
      <slot_id>588e45b4-de54-447f-b433-74df56db924e</slot_id>
      <title>Formal Proof of Polynomial-Time Complexity with Quasi-Interpretations</title>
      <room>Omni Hotel | CPP</room>
      <date>2018/01/08</date>
      <start_time>17:30</start_time>
      <end_time>18:00</end_time>
      <description>We present a Coq library that allows for readily proving that a function is computable in polynomial time. It is based on quasi-interpretations that, in combination with termination ordering, provide a characterisation of the class \textsc{fp} of functions computable in polynomial time. At the heart of this formalisation is a proof of soundness and extensional completeness. Compared to the original paper proof, we had to fill a lot of not so trivial details that were left to the reader and fix a few glitches. To demonstrate the usability of our library, we apply it to the modular exponentiation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hugo</first_name>
          <last_name>Férée</last_name>
          <affiliation>University of Kent, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://hugo.feree.fr</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Samuel</first_name>
          <last_name>Hym</last_name>
          <affiliation>University of Lille, France</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Micaela</first_name>
          <last_name>Mayero</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jean-Yves</first_name>
          <last_name>Moyen</last_name>
          <affiliation>University of Copenhagen, Denmark</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>David</first_name>
          <last_name>Nowak</last_name>
          <affiliation>CNRS, France</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>76b7c6af-bbac-44fe-a2d3-6a8d561b585b</slot_id>
      <title>Triangulating Context Lemmas</title>
      <room>Omni Hotel | CPP</room>
      <date>2018/01/08</date>
      <start_time>16:00</start_time>
      <end_time>16:30</end_time>
      <description>The idea of a \emph{context lemma} spans a range of programming-language models: from Milner's original through the CIU theorem to `CIU-like' results for multiple language features. Each shows that to prove observational equivalence between program terms it is enough to test only some restricted class of contexts: applicative, evaluation, reduction, \textit{etc.}
We formally reconstruct a distinctive proof method for context lemmas based on cyclic inclusion of three program approximations: by triangulating between applicative&amp;amp;#39; andlogical' relations we prove that both match the observational notion, while being simpler to compute. Moreover, the observational component of the triangle condenses a series of approximations covering variation in the literature around what variable-capturing structure qualifies as a `context'.
Although entirely concrete, our approach involves no term dissection or inspection of reduction sequences; instead we draw on previous context lemmas using operational logical relations and biorthogonality. We demonstrate the method for a fine-grained call-by-value presentation of the simply-typed lambda-calculus, and extend to a CIU result formulated with frame stacks.
All this is formalised and proved in Agda: building on work of Allais et al., we exploit dependent types to specify lambda-calculus terms as well-typed and well-scoped by construction. By doing so, we seek to dispel any lingering anxieties about the manipulation of concrete contexts when reasoning about bound variables, capturing substitution, and observational equivalences.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Craig</first_name>
          <last_name>McLaughlin</last_name>
          <affiliation>The University of Edinburgh</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>James</first_name>
          <last_name>McKinna</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ian</first_name>
          <last_name>Stark</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c82d94f2-3449-43b9-a946-a2473cfe54c6</slot_id>
      <title>A Monadic Framework for Relational Verification: Applied to Information Security, Program Equivalence, and Optimizations</title>
      <room>Omni Hotel | CPP</room>
      <date>2018/01/08</date>
      <start_time>17:00</start_time>
      <end_time>17:30</end_time>
      <description>Relational properties describe multiple runs of one or more programs. They characterize many useful notions of security, program refinement, and equivalence for programs with diverse computational effects, and they have received much attention in the recent literature. Rather than developing separate tools for special classes of effects and relational properties, we advocate using a general purpose proof assistant as a unifying framework for the relational verification of effectful programs. The essence of our approach is to model effectful computations using monads and to prove relational properties on their monadic representations, making the most of existing support for reasoning about pure programs. We apply this method in F* and evaluate it by encoding a variety of relational program analyses, including information flow control, program equivalence and refinement at higher order, correctness of program optimizations and game-based cryptographic security. By relying on SMT-based automation, unary weakest preconditions, user-defined effects, and monadic reification, we show that, compared to unary properties, verifying relational properties requires little additional effort from the F* programmer.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Niklas</first_name>
          <last_name>Grimm</last_name>
          <affiliation>Vienna University of Technology, Austria</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kenji</first_name>
          <last_name>Maillard</last_name>
          <affiliation>Inria Paris and ENS Paris</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Cédric</first_name>
          <last_name>Fournet</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://research.microsoft.com/en-us/um/people/fournet/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Cătălin</first_name>
          <last_name>Hriţcu</last_name>
          <affiliation>Inria Paris</affiliation>
          <bio>Catalin is a tenured Research Scientist at Inria Paris where he develops rigorous formal techniques for solving security problems. He is particularly interested in formal methods for security (memory safety, compartmentalization, dynamic monitoring, integrity, security protocols, information flow), programming languages (type systems, verification, proof assistants, property-based testing, semantics, formal metatheory, certified tools), and the design and verification of security-critical systems (reference monitors, secure compilers, microkernels, secure hardware). He is actively involved in the design of the F* verification system and was recently awarded an ERC Starting Grant on secure compilation. Catalin was a PhD student at Saarland University and a Research Associate at University of Pennsylvania before joining Inria Paris in 2013.</bio>
          <homepage_url>http://prosecco.gforge.inria.fr/personal/hritcu/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/catalinhritcu/e262cec6-3e6b-47cc-ad61-b5c5b07953a1/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Matteo</first_name>
          <last_name>Maffei</last_name>
          <affiliation>Saarland University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.sps.cs.uni-saarland.de/maffei/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/matteomaffei/7890680a-38ae-47e8-b130-05ac674155e4/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Protzenko</last_name>
          <affiliation>Microsoft Research, n.n.</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jonathan.protzenko.fr</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/jonathanprotzenko/203c9e40-1cbf-40d3-b59f-da4a4c305361/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Tahina</first_name>
          <last_name>Ramananandro</last_name>
          <affiliation>Microsoft Research, n.n.</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.normalesup.org/~ramanana/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/tahinaramananandro/a58fd430-e17e-4c52-9296-d211c2084679/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Aseem</first_name>
          <last_name>Rastogi</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.microsoft.com/en-us/research/people/aseemr/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/aseemrastogi/60be692f-f2e1-4eef-ac4a-85f7accdba8e/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>9</sort_key>
          <first_name>Nikhil</first_name>
          <last_name>Swamy</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://research.microsoft.com/~nswamy</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/nikhilswamy/fcdbbbd2-b390-4c57-a305-b77c7386f260/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>10</sort_key>
          <first_name>Santiago</first_name>
          <last_name>Zanella-Béguelin</last_name>
          <affiliation>Microsoft Research, n.n.</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl18.sigplan.org/getProfileImage/santiagozanellabeguelin/dfba81c9-9624-47f1-8015-8abe2eeea970/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f839e780-c277-4ee9-88e3-68e20cfb99eb</slot_id>
      <title>Adapting Proof Automation to Adapt Proofs</title>
      <room>Omni Hotel | CPP</room>
      <date>2018/01/08</date>
      <start_time>16:30</start_time>
      <end_time>17:00</end_time>
      <description>We extend proof automation in an interactive theorem prover to analyze changes in specifications and proofs. Our approach leverages the history of changes to specifications and proofs to search for a patch that can be applied to other specifications and proofs that need to change in analogous ways.
We identify and implement five core components that are key to searching for a patch. We build a patch finding procedure from these components, which we configure for various classes of changes. We implement this procedure in a Coq plugin as a proof-of-concept and use it on real Coq code to change specifications, port definitions of a type, and update the Coq standard library. We show how our findings help drive a future that moves the burden of dealing with the brittleness of small changes in an interactive theorem prover away from the programmer and into automated tooling.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Talia</first_name>
          <last_name>Ringer</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://tlringer.github.io/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/taliaringer/1a95a492-cf5a-4225-8efb-ac834a36fa16/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nathaniel</first_name>
          <last_name>Yazdani</last_name>
          <affiliation>University of Washington, USA</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>John</first_name>
          <last_name>Leo</last_name>
          <affiliation>Halfaya Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://halfaya.org/leo/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/johnleo/40a117e2-4d6b-4362-b98e-a29513d62c2e/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Dan</first_name>
          <last_name>Grossman</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homes.cs.washington.edu/~djg/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/dangrossman/941e0321-e962-4f03-9027-ba9f0448e7df/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>979394e4-0d76-427c-b1e2-b437b20f011a</subevent_id>
    <title>PEPM 2018: Session 1-2</title>
    <subevent_type type="regular"/>
    <room>PEPM</room>
    <date>2018/01/08</date>
    <url>https://popl18.sigplan.org/track/PEPM-2018</url>
    <url_link_display>— ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation</url_link_display>
    <tracks>
      <track>— ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation</track>
    </tracks>
    <timeslot>
      <slot_id>147daf95-853b-48a7-9e19-5b029bd4ecf9</slot_id>
      <title>A Guess-and-Assume Approach to Loop Fusion for Program Verification</title>
      <room>Omni Hotel | PEPM</room>
      <date>2018/01/08</date>
      <start_time>14:00</start_time>
      <end_time>14:30</end_time>
      <description>Loop fusion—a program transformation to merge multiple consecutive loops into a single one—has been studied mainly for compiler optimization. In this paper, we argue that loop fusion can be useful also for program verification because it can simplify loop invariants and we propose a new loop fusion strategy, which can fuse any loops—even loops with data dependence—and preserves partial correctness.
The crux of our loop fusion is the following observation: if the state after the first loop were known, two loop bodies could be computed at the same time without suffering from data dependence by renaming program variables. Our loop fusion produces a program that guesses the unknown state after the first loop nondeterministically, executes the fused loop where variables are renamed, compares the guessed state and the state actually computed by the fused loop, and, if they do not match, diverges. The last two steps of comparison and divergence are crucial to preserve partial correctness. We call our approach ``guess-and-assume'' because, in addition to the first step to guess, the last two steps can be expressed by the pseudo-instruction assume, used in program verification.
We formalize our loop fusion for a simple imperative language and prove that it preserves partial correctness. We further extend the ``guess-and-assume'' technique to reversing loop execution, which is useful to verify a certain type of consecutive loops. Finally, we confirm by experiments that our transformation techniques can significantly reduce verification time in many cases.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Akifumi</first_name>
          <last_name>Imanishi</last_name>
          <affiliation>Kyoto University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kohei</first_name>
          <last_name>Suenaga</last_name>
          <affiliation>Graduate School of Informatics, Kyoto University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fos.kuis.kyoto-u.ac.jp/~ksuenaga/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/koheisuenaga/f57f179b-edd7-499b-9b7b-0a240a6b0474/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Atsushi</first_name>
          <last_name>Igarashi</last_name>
          <affiliation>Kyoto University, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fos.kuis.kyoto-u.ac.jp/~igarashi/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/atsushiigarashi/bbac1695-343a-4091-b33c-b7f01dea73da/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>— ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c813372a-9ab3-44a2-9639-252da9bf4539</slot_id>
      <title>Gradually Typed Symbolic Expressions</title>
      <room>Omni Hotel | PEPM</room>
      <date>2018/01/08</date>
      <start_time>14:30</start_time>
      <end_time>15:00</end_time>
      <description>Embedding a domain-specific language (DSL) in a general purpose host language is an efficient way to develop a new DSL. Various kinds of languages and paradigms can be used as host languages, including object-oriented, functional, statically typed, and dynamically typed variants, all having their pros and cons. For deep embedding, statically typed languages enable early checking and potentially good DSL error messages, instead of reporting runtime errors. Dynamically typed languages, on the other hand, enable flexible transformations, thus avoiding extensive boilerplate code. In this paper, we introduce the concept of gradually typed symbolic expressions that mix static and dynamic typing for symbolic data. The key idea is to combine the strengths of dynamic and static typing in the context of deep embedding of DSLs. We define a gradually typed calculus $\lambda^{&amp;lt;\star&amp;gt;}$, formalize its type system and dynamic semantics, and prove type safety. We introduce a host language called Modelyze that is based on $\lambda^{&amp;lt;\star&amp;gt;}$, and evaluate the approach by embedding a series of equation-based domain-specific modeling languages, all within the domain of physical modeling and simulation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>Broman</last_name>
          <affiliation>KTH Royal Institute of Technology</affiliation>
          <bio>David Broman is an Associate Professor at the KTH Royal Institute of Technology in Sweden, where he is leading the Model-based Computing Systems (MCS) research group. Between 2012 and 2014, he was a visiting scholar at the University of California, Berkeley, where he also was employed as a part time researcher until 2016. David received his Ph.D. in Computer Science in 2010 from Linköping University, Sweden, and was appointed Assistant Professor there in 2011. He earned a Docent degree in Computer Science in 2015. His research focuses on model-based design of time-aware systems, including cyber-physical systems, embedded systems, and real-time systems. In particular, he is interested in modeling language theory, formal semantics, compilers, and machine learning. In 2017, he was awarded the individual grant for future leaders (FFL 6) from the Swedish Foundation for Strategic Research (SSF). David has worked several years within the software industry, co-founded the EOOLT workshop series, and is a member of IFIP WG 2.4, Modelica Association, and the TAACCS steering committee.</bio>
          <homepage_url>https://people.kth.se/~dbro/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/davidbroman/dcc9932a-010a-4ca4-952d-af2114e4dc76/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jeremy G.</first_name>
          <last_name>Siek</last_name>
          <affiliation>Indiana University, USA</affiliation>
          <bio>Jeremy Siek is an Associate Professor at Indiana University Bloomington. Jeremy’s areas of research include programming language design, type systems, mechanized theorem proving using proof assistants, and optimizing compilers. Jeremy’s Ph.D. thesis explored foundations for constrained templates, aka the “concepts” proposal for C++. Prior to that, Jeremy developed the Boost Graph Library, a C++ generic library for graph algorithms and data structures. Jeremy post-doc’d at Rice University where he developed the idea of gradual typing: a type system that integrates both dynamic and static typing in the same programming language. Jeremy is currently working on several open questions regarding gradual typing. Is the polymorphic blame calculus really parametric? How should gradual typing be combined with other features such as dependent types? What is the formal criteria for gradually typed languages? Is it possible to create a high-performance implementation of a gradually-typed languages? In 2009 Jeremy received the NSF CAREER award to fund his project: “Bridging the Gap Between Prototyping and Production”. In 2010 and again in 2015, Jeremy was awarded a Distinguished Visiting Fellowship from the Scottish Informatics &amp;amp; Computer Science Alliance.</bio>
          <homepage_url>http://homes.soic.indiana.edu/jsiek/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/jeremysiek/4365edf9-715f-46e0-8867-4ea5fb6341ad/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>— ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fb75ce43-c184-4c35-b8f4-7a283a6b59f3</slot_id>
      <title>On the Cost of Type-Tag Soundness</title>
      <room>Omni Hotel | PEPM</room>
      <date>2018/01/08</date>
      <start_time>15:00</start_time>
      <end_time>15:30</end_time>
      <description>Gradual typing systems ensure type soundness by transforming static type annotations into run-time checks. These checks provide semantic guarantees, but may come at a large cost in performance. In particular, recent work by Takikawa et al. suggests that enforcing a conventional form of type soundness may slow a program by two orders of magnitude.
Since different gradual typing systems satisfy different notions of soundness, the question then arises: what is the cost of such varying notions of soundness? This paper answers an instance of this question by applying Takikawa et al.’s evaluation method to Reticulated Python, which satisfies a notion of type-tag soundness. We find that the cost of soundness in Reticulated is at most one order of magnitude.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ben</first_name>
          <last_name>Greenman</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Delmar NY -&amp;gt; Cornell University (BS, M.Eng) -&amp;gt; Northeastern University (PhD from Matthias, expected ~2020)</bio>
          <homepage_url>http://www.ccs.neu.edu/home/types/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/bengreenman/43f3d1c6-cde6-4ffc-8753-fd948dfcd732/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Zeina</first_name>
          <last_name>Migeed</last_name>
          <affiliation>University of California, Los Angeles</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>— ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0435bd73-dcb5-4750-abaa-70a22997c83f</subevent_id>
    <title>PEPM 2018: Session 1-3</title>
    <subevent_type type="regular"/>
    <room>PEPM</room>
    <date>2018/01/08</date>
    <url>https://popl18.sigplan.org/track/PEPM-2018</url>
    <url_link_display>— ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation</url_link_display>
    <tracks>
      <track>— ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation</track>
    </tracks>
    <timeslot>
      <slot_id>5ee90279-c72f-4b58-85d3-466762f55303</slot_id>
      <title>TBA (Invited Talk)</title>
      <room>Omni Hotel | PEPM</room>
      <date>2018/01/08</date>
      <start_time>16:00</start_time>
      <end_time>17:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>invited speaker</role>
          <sort_key>1</sort_key>
          <first_name>Conal</first_name>
          <last_name>Elliott</last_name>
          <affiliation>Target, USA</affiliation>
          <bio>Conal Elliott has been working (and playing) in functional programming for more than 35 years. He especially enjoys applying semantic elegance and rigor to library design and optimized implementation. He invented the paradigm now known as “functional reactive programming” in the early 1990s, and then pioneered compilation techniques for high-performance, high-level embedded domain-specific languages, with applications including 2D and 3D computer graphics. The latter work included the first compilation of Haskell programs to GPU code, while maintaining precise and simple semantics and powerful composability, as well a high degree of optimization. Conal earned a BA in math with honors from the College of Creative Studies at UC Santa Barbara in 1982 and a PhD in Computer Science from Carnegie Mellon University in 1990. He is currently working as distinguished scientist at Target. Previously, we worked at Tabula Inc on chip specification and compiling Haskell to hardware for massively parallel execution. Before Tabula, his positions included Architect at Sun Microsystems and Researcher in the Microsoft Research graphics group. He has also coached couples and led conscious relationship workshops together with his partner Holly Croydon, with whom he now lives on 20 acres in the woods in the California Gold Country.</bio>
          <homepage_url>http://conal.net</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/conalelliott/0aca0f74-be30-4571-b92b-630e50725387/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>— ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7251c378-1824-4334-b46a-dd110eab944b</subevent_id>
    <title>CPP 2018: Invited Talk by René Thiemann</title>
    <subevent_type type="regular"/>
    <room>CPP</room>
    <date>2018/01/08</date>
    <url>https://popl18.sigplan.org/track/CPP-2018</url>
    <url_link_display>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</url_link_display>
    <tracks>
      <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
    </tracks>
    <timeslot>
      <slot_id>dee04c50-bcd1-4ae6-864c-7069b8198578</slot_id>
      <title>Efficient Certification of Complexity Proofs: Formalizing the Perron–Frobenius Theorem (Invited Talk Paper)</title>
      <room>Omni Hotel | CPP</room>
      <date>2018/01/08</date>
      <start_time>09:00</start_time>
      <end_time>10:00</end_time>
      <description>Matrix interpretations are widely used in automated complexity analysis. Certifying such analyses boils down to determining the growth rate of $A^n$ for a fixed non-negative rational matrix $A$. A direct solution for this task involves the computation of all eigenvalues of $A$, which often leads to expensive algebraic number computations.
In this work we formalize the Perron–Frobenius theorem. We utilize the theorem to avoid most of the algebraic numbers needed for certifying complexity analysis, so that our new algorithm only needs the rational arithmetic when certifying complexity proofs that existing tools can find. To cover the theorem in its full extent, we establish a connection between two different Isabelle/HOL libraries on matrices, enabling an easy exchange of theorems between both libraries. This connection crucially relies on the transfer mechanism in combination with local type definitions, being a non-trivial case study for these Isabelle tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jose</first_name>
          <last_name>Divasón</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sebastiaan</first_name>
          <last_name>Joosten</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Kunčar</last_name>
          <affiliation>Technische Universität München, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www21.in.tum.de/~kuncar/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>René</first_name>
          <last_name>Thiemann</last_name>
          <affiliation>University of Innsbruck</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cl-informatik.uibk.ac.at/users/thiemann/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Akihisa</first_name>
          <last_name>Yamada</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cl-informatik.uibk.ac.at/users/ayamada/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>3ae02a05-25b6-45fc-9bf1-48f0a06ce200</subevent_id>
    <title>CPP 2018: Trusted Verification Frameworks and Systems</title>
    <subevent_type type="regular"/>
    <room>CPP</room>
    <date>2018/01/09</date>
    <url>https://popl18.sigplan.org/track/CPP-2018</url>
    <url_link_display>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</url_link_display>
    <tracks>
      <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
    </tracks>
    <timeslot>
      <slot_id>628ba933-52d4-4f3d-b3ce-15e498e70b5d</slot_id>
      <title>Œuf: Minimizing the Coq Extraction TCB</title>
      <room>Omni Hotel | CPP</room>
      <date>2018/01/09</date>
      <start_time>11:00</start_time>
      <end_time>11:30</end_time>
      <description>\newcommand{\Oeuf}{\OE uf\xspace} \newcommand{\eg}{\emph{e.g.}\xspace}
Verifying systems by implementing them in the programming language of a proof assistant (\eg, Gallina for Coq) lets us directly leverage the full power of the proof assistant for verifying the system. But, to execute such an implementation requires \emph{extraction}, a large complicated process that is in the trusted computing base (TCB).
This paper presents \Oeuf, a verified compiler from a subset of Gallina to assembly. \Oeuf's correctness theorem ensures that compilation preserves the semantics of the source Gallina program. We describe how \Oeuf's specification can be used as a foreign function interface to reason about the interaction between compiled Gallina programs and surrounding shim code. Additionally, \Oeuf maintains a small TCB for its front-end by reflecting Gallina programs to \Oeuf source and automatically ensuring equivalence using computational denotation. This design enabled us to implement some early compiler passes (\eg, lambda lifting) in the untrusted reflection and ensure their correctness via translation validation. To evaluate \Oeuf, we compile Appel's SHA256 specification from Gallina to x86 and write a shim for the generated code, yielding a verified \texttt{sha256sum} implementation with a small TCB.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Eric</first_name>
          <last_name>Mullen</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Stuart</first_name>
          <last_name>Pernsteiner</last_name>
          <affiliation>University of Washington, USA</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>James R.</first_name>
          <last_name>Wilcox</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>I am a third year PhD student in the Computer Science and Engineering department at the University of Washington. My interests are in programming languages and applications of PL techniques to systems.</bio>
          <homepage_url>http://homes.cs.washington.edu/~jrw12/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/jamesrwilcox/92dfd071-3ff1-4a52-8f23-86215aca7f43/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Zachary</first_name>
          <last_name>Tatlock</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>Assistant Professor at UW</bio>
          <homepage_url>https://homes.cs.washington.edu/~ztatlock/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/zacharytatlock/87af1196-2d8d-4bd5-a692-018d3939a00f/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Dan</first_name>
          <last_name>Grossman</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homes.cs.washington.edu/~djg/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/dangrossman/941e0321-e962-4f03-9027-ba9f0448e7df/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>85196128-84e8-4f0a-81e0-9c843d9cf70e</slot_id>
      <title>A Verified SAT Solver with Watched Literals Using Imperative HOL</title>
      <room>Omni Hotel | CPP</room>
      <date>2018/01/09</date>
      <start_time>10:30</start_time>
      <end_time>11:00</end_time>
      <description>Based on our earlier formalization of conflict-driven clause learning (CDCL) in Isabelle/HOL, we refine the CDCL calculus to add a crucial optimization: two watched literals. We formalize the data structure and the invariants. Then we refine the calculus to obtain an executable SAT solver. Through a chain of refinements carried out using the Isabelle Refinement Framework, we target Imperative HOL and extract imperative Standard ML code. Although our solver is not competitive with the state of the art, it offers acceptable performance for some applications, and heuristics can be added to improve it further.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mathias</first_name>
          <last_name>Fleury</last_name>
          <affiliation>MPI-INF</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-inf.mpg.de/~mfleury</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/mathiasfleury/2a650d8c-0793-42e2-add2-8498088fe591/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jasmin Christian</first_name>
          <last_name>Blanchette</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Peter</first_name>
          <last_name>Lammich</last_name>
          <affiliation>Technische Universität München</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fb21d2ea-50b1-4ae6-a056-81120c72eac7</slot_id>
      <title>Proofs in Conflict-Driven Theory Combination</title>
      <room>Omni Hotel | CPP</room>
      <date>2018/01/09</date>
      <start_time>11:30</start_time>
      <end_time>12:00</end_time>
      <description>Search-based satisfiability procedures try to construct a model of the input formula by simultaneously proposing candidate models and deriving new formulae implied by the input. When the formulae are satisfiable, these procedures generate a model as a witness. Dually, it is desirable to have a proof when the formulae are unsatisfiable. Conflict-driven procedures perform nontrivial inferences only when resolving conflicts between the formulae and assignments representing the candidate model. CDSAT (Conflict-Driven SATisfiability) is a method for conflict-driven reasoning in combinations of theories. It combines solvers for individual theories as theory modules within a solver for the union of the theories. In this paper we endow CDSAT with lemma learning and proof generation. For the latter, we present two techniques. The first one produces proof objects in memory: it assumes that all theory modules produce proof objects and it accommodates multiple proof formats. The second technique adapts the LCF approach to proofs from interactive theorem proving to conflict-driven SMT-solving and theory combination, by defining a small kernel of reasoning primitives that guarantees that CDSAT proofs are correct by construction.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Maria Paola</first_name>
          <last_name>Bonacina</last_name>
          <affiliation>University of Verona, Italy</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Stéphane</first_name>
          <last_name>Graham-Lengrand</last_name>
          <affiliation>CNRS, France</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Natarajan</first_name>
          <last_name>Shankar</last_name>
          <affiliation>SRI International, USA</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a12ee8ec-fd27-4dc5-ab83-d07a18217ade</subevent_id>
    <title>PEPM 2018: Session 2-1</title>
    <subevent_type type="regular"/>
    <room>PEPM</room>
    <date>2018/01/09</date>
    <url>https://popl18.sigplan.org/track/PEPM-2018</url>
    <url_link_display>— ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation</url_link_display>
    <tracks>
      <track>— ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation</track>
    </tracks>
    <timeslot>
      <slot_id>59f41d9a-0ef9-43c2-baf4-691f31e83263</slot_id>
      <title>Challenges in the Design and Compilation of Programming Languages for Exascale Machines (Invited Talk)</title>
      <room>Omni Hotel | PEPM</room>
      <date>2018/01/09</date>
      <start_time>10:30</start_time>
      <end_time>11:30</end_time>
      <description>A new class of very large scale parallel and distributed machines are emerging, with more processors, more complex memory hierarchies, and much more heterogeneity than machines of the past. This talk will outline the likely trends in such machines and why it is worth thinking about programming languages that program them as a whole, rather than current standard approaches which use a mix of technologies. Using the Legion programming model as an example, we’ll discuss a number of novel challenges that arise in the design and compilation of languages for such machines and discuss our current understanding of solutions.</description>
      <persons>
        <person>
          <role>invited speaker</role>
          <sort_key>1</sort_key>
          <first_name>Alex</first_name>
          <last_name>Aiken</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>— ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b4cf0d69-29c7-4440-b8a6-b3a12d8aa12e</slot_id>
      <title>Checking Cryptographic API Usage with Composable Annotations (Short Paper)</title>
      <room>Omni Hotel | PEPM</room>
      <date>2018/01/09</date>
      <start_time>11:30</start_time>
      <end_time>12:00</end_time>
      <description>Application developers increasingly rely on cryptographic libraries but often lack the experience to use them correctly. Popular dynamic languages such as JavaScript make testing or verifying such applications particularly challenging. In this paper, we present our ongoing work toward a methodology for automatically checking security properties in JavaScript code. Our main idea is to attach security annotations to values that encode properties of interest. We illustrate our idea using examples and, as an initial step in our line of work, we present a formalization of security annotations in a statically typed lambda calculus. As next steps, we will translate our annotations to a dynamically typed formalization of JavaScript such as $\lambda_\textsf{JS}$ and implement a runtime checked type extension using code instrumentation for full JavaScript.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Duncan</first_name>
          <last_name>Mitchell</last_name>
          <affiliation>Royal Holloway, University of London</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>L. Thomas</first_name>
          <last_name>van Binsbergen</last_name>
          <affiliation>Royal Holloway University of London</affiliation>
          <bio>L. Thomas van Binsbergen is a PhD student in Computer Science at Royal Holloway University of London, and an MSc graduate of Utrecht University.
His work revolves around specifying and prototyping programming languages. He contributed to the Utrecht University Attribute Grammar Compiler (UUAGC) in 2014, implementing algorithms for compile-time scheduling of attribute evaluation based on dependency analysis.
As an affiliate to the PLanCompS project he has developed Haskell tools for defining and executing FunCons: highly reusable and modular components used in the formal specification of programming languages’ semantics. For more information visit http://plancomps.org
General interest in Computer Science: Teaching, Programming Languages, Algorithm Design, Soundness &amp;amp; Correctness Proofs, Graph Theory and Complexity Analysis, Genetic Programming and Program Synthesis
Particular aspects related to “Software Languages and their Specification”:

 Language design and formal semantics
 Generating interpreters based on the formal semantics of a language
 Computational effects: Modelling abnormal control flow like exceptions, and side-effects like Input/Output and variable assignment in pure maths
 Static analysis of programs: type-checkers, sanity-checkers, program manipulation
 Reusable components for both syntax and semantics of languages.

Interests in Computer Science Education:

 Improving the understandability of algorithms by explaining the algorithm at the right level of abstraction, removing unnecessary detail, breaking down algorithms into their core components and defining those components as pure and composable functions
 Tutoring systems for the analysis of student solutions and automated feedback
</bio>
          <homepage_url>http://ltvanbinsbergen.nl</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/lthomasvanbinsbergen/b276e9a4-2229-45a7-ae0f-e25fb729b0e6/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Blake</first_name>
          <last_name>Loring</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Johannes</first_name>
          <last_name>Kinder</last_name>
          <affiliation>Royal Holloway, University of London</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>— ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>87a0f9ea-683c-445b-8c39-c7fa7d085e06</subevent_id>
    <title>CPP 2018: Verified Applications</title>
    <subevent_type type="regular"/>
    <room>CPP</room>
    <date>2018/01/08</date>
    <url>https://popl18.sigplan.org/track/CPP-2018</url>
    <url_link_display>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</url_link_display>
    <tracks>
      <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
    </tracks>
    <timeslot>
      <slot_id>10cc02cc-3724-436f-b930-4336efe715fd</slot_id>
      <title>Formal Microeconomic Foundations and the First Welfare Theorem</title>
      <room>Omni Hotel | CPP</room>
      <date>2018/01/08</date>
      <start_time>15:00</start_time>
      <end_time>15:30</end_time>
      <description>Economic activity has always been a fundamental part of society. With recent social and political changes economics has gained even more influence on our lives. In this paper we formalize two economic models in Isabelle/HOL: the pure exchange economy, where the only economic actors are consumers, as well as a version of the Arrow-Debreu Model, a private ownership economy, which includes production facilities. Interestingly, the definitions of various components of the economic models differ in the economic literature. We therefore show the equivalences and implications between various presentations, which allows us to create an extensible foundation for formalizing microeconomics and game theory compatible with multiple economic theories. We prove the First Theorem of Welfare Economics in both economic models. The theorem is the mathematical formulation of Adam Smith’s famous invisible hand and states that a group of self-interested and rational actors will eventually achieve an efficient allocation of goods. The formal proofs allow us to find more precise assumptions than those found in the economic literature.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Cezary</first_name>
          <last_name>Kaliszyk</last_name>
          <affiliation>University of Innsbruck</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cl-informatik.uibk.ac.at/users/cek/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/cezarykaliszyk/bc2b6c58-bf34-4432-a7a0-95b36c02bba4/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Julian</first_name>
          <last_name>Parsert</last_name>
          <affiliation>University of Innsbruck, Austria</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8e907a3e-1ee2-4c06-b891-1346cc5ca4f8</slot_id>
      <title>Mechanising and Verifying the WebAssembly Specification</title>
      <room>Omni Hotel | CPP</room>
      <date>2018/01/08</date>
      <start_time>13:30</start_time>
      <end_time>14:00</end_time>
      <description>&amp;lt;p&amp;gt;WebAssembly is a new low-level language currently being implemented in all major web browsers. It is designed to become the universal compilation target for the web, obsoleting existing solutions in this area, such as asm.js and Native Client. The WebAssembly working group has incorporated formal techniques into the development of the language, but their efforts so far have focussed on pen and paper formal specification.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;We present a mechanised Isabelle specification for the WebAssembly language, together with a verified executable interpreter and type checker. Moreover, we present a fully mechanised proof of the soundness of the WebAssembly type system, and detail how our work on this proof has exposed several issues with the official WebAssembly specification, influencing its development. Finally, we give a brief account of our efforts in performing differential fuzzing of our interpreter against industry implementations.&amp;lt;/p&amp;gt;</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Conrad</first_name>
          <last_name>Watt</last_name>
          <affiliation>University of Cambridge, UK</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>994ae22f-0c1c-4352-a222-28d6ba3cf3a4</slot_id>
      <title>Towards Verifying Ethereum Smart Contract Bytecode in Isabelle/HOL</title>
      <room>Omni Hotel | CPP</room>
      <date>2018/01/08</date>
      <start_time>14:00</start_time>
      <end_time>14:30</end_time>
      <description>Blockchain technology has increasing attention in research and across many industries. The Ethereum blockchain offers smart contracts, which are small programs defined, executed, and recorded as transactions in the blockchain transaction history. These smart contracts run on the Ethereum Virtual Machine (EVM) and can be used to encode agreements, transfer assets, and enforce integrity conditions in relationships between parties. Smart contracts can carry financial value, and are increasingly used for safety-, security-, or mission-critical purposes. Errors in smart contracts have led and will lead to loss or harm. Formal verification can provide the highest level of confidence about the correct behaviour of smart contracts. In this paper we extend an existing EVM formalisation in Isabelle/HOL by a sound program logic at the level of bytecode. We structure bytecode sequences into blocks of straight-line code and create a program logic to reason about these. This abstraction is a step towards control of the cost and complexity of formal verification of EVM smart contracts.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sidney</first_name>
          <last_name>Amani</last_name>
          <affiliation>UNSW, Australia</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Myriam</first_name>
          <last_name>Bégel</last_name>
          <affiliation>ENS Paris-Saclay, France</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Maksym</first_name>
          <last_name>Bortin</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Mark</first_name>
          <last_name>Staples</last_name>
          <affiliation>CSIRO, Australia</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fc2c9fed-2aec-499c-ace3-6a71259ad1ce</slot_id>
      <title>Mechanising Blockchain Consensus</title>
      <room>Omni Hotel | CPP</room>
      <date>2018/01/08</date>
      <start_time>14:30</start_time>
      <end_time>15:00</end_time>
      <description>We present the first formalisation of a blockchain-based distributed consensus protocol with a proof of its consistency mechanised in an interactive proof assistant.
Our development includes a reference mechanisation of the block forest data structure, necessary for implementing provably correct per-node protocol logic. We also define a model of a network, implementing the protocol in the form of a replicated state-transition system. The protocol’s executions are modelled via a small-step operational semantics for asynchronous message passing, in which packages can be rearranged or duplicated.
In this work, we focus on the notion of global system safety, proving a form of eventual consistency. To do so, we provide a library of theorems about a pure functional implementation of block forests, define an inductive system invariant, and show that, in a quiescent system state, it implies a global agreement on the state of per-node transaction ledgers. Our development is parametric with respect to implementations of several security primitives, such as hash-functions, a notion of a proof object, a Validator Acceptance Function, and a Fork Choice Rule. We precisely characterise the assumptions, made about these components for proving the global system consensus, and discuss their adequacy.
All results described in this paper are formalised in Coq.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>George</first_name>
          <last_name>Pîrlea</last_name>
          <affiliation>University College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pirlea.net</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/georgepirlea/b6e4660b-5544-4ef9-9455-630d04c5ddc8/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ilya</first_name>
          <last_name>Sergey</last_name>
          <affiliation>University College London</affiliation>
          <bio>I am a lecturer (assistant professor) at University College London.
Prior to joining UCL, I was a postdoctoral researcher at IMDEA Software Institute (Madrid, Spain). I defended my PhD in 2012 in the DistriNet research group at the Department of Computer Sciences of KU Leuven (Belgium). Before that I received my MSc degree in Mathematics and Computer Science from Saint Petersburg State University (Russia) in 2008.
My research interests dwell in the area of the design and implementation of programming languages, including but not limited to program semantics, certified programming, concurrency and abstract interpretation. I am particularly interested in developing verification techniques and static analyses for higher-order and concurrent programs.</bio>
          <homepage_url>http://ilyasergey.net</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/ilyasergey/b2941c89-4843-4194-852a-81c8a30814fa/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>CPP 2018 - The 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6a34cbbc-64e6-43a5-9be4-d4ab6bc03fab</subevent_id>
    <title>PADL 2018: Prolog and Optimizations</title>
    <subevent_type type="regular"/>
    <room>PADL</room>
    <date>2018/01/08</date>
    <url>https://popl18.sigplan.org/track/PADL-2018</url>
    <url_link_display>20th International Symposium on  Practical Aspects of Declarative Languages </url_link_display>
    <tracks>
      <track>20th International Symposium on  Practical Aspects of Declarative Languages </track>
    </tracks>
    <timeslot>
      <slot_id>31e4f5b1-8926-47d1-a970-c326aacec546</slot_id>
      <title>``Safe'' Languages Require Sequential Consistency</title>
      <room>Omni Hotel | PADL</room>
      <date>2018/01/08</date>
      <start_time>15:00</start_time>
      <end_time>15:30</end_time>
      <description>Almost all languages today are memory safe, thereby providing simple and strong guarantees to all programs. Yet the concurrency semantics of these “safe” languages causes similar problems as arise in memory-unsafe languages: small program errors can expose implementation details, violate fundamental language abstractions, and compromise program safety. Perhaps surprisingly, this is the case not only for imperative languages like Java and C++ but also for functional languages that support shared-memory concurrency. In this talk Ill overview the state of concurrency semantics as it exists today and argue that “safe” languages (and particularly declarative ones) must support the simple interleaving semantics of threads known as sequential consistency (SC). Along the way Ill debunk a few persistent myths about SC and argue that it is a practical choice for many languages today.</description>
      <persons>
        <person>
          <role>invited speaker</role>
          <sort_key>1</sort_key>
          <first_name>Todd</first_name>
          <last_name>Millstein</last_name>
          <affiliation>University of California, Los Angeles</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.cs.ucla.edu/~todd/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/toddmillstein1/a55642b6-6fa2-40f6-99ba-8b9003ee61d9/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>20th International Symposium on  Practical Aspects of Declarative Languages </track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b680a5f1-ac56-4586-97a7-51b699417907</slot_id>
      <title>Exploiting Term Hiding to Reduce Run-time Checking Overhead</title>
      <room>Omni Hotel | PADL</room>
      <date>2018/01/08</date>
      <start_time>14:30</start_time>
      <end_time>15:00</end_time>
      <description>One of the most attractive features of untyped languages for programmers is the flexibility in term creation and manipulation. However, with such power comes the responsibility of ensuring correctness of these operations. A solution is adding run-time checks to the program via assertions, but this can introduce overheads that are in many cases impractical. While such overheads can be greatly reduced with static analysis, the gains depend strongly on the quality of the information inferred. Reusable libraries, i.e., library modules that are pre-compiled independently of the client, pose special challenges in this context. We propose a technique which takes advantage of module systems which can hide a selected set of functor symbols to significantly enrich the shape information that can be inferred in reusable modular programs, as well as an improved run-time checking approach that takes advantage of the proposed mechanisms to achieve large reductions in overhead, closer to those of static languages, even in the reusable-library context. While the approach is general and system-independent, we present it for concreteness in the context of the Ciao assertion language and combined static/dynamic checking framework. Our method maintains full expressiveness of the checks in this context. Contrary to other approaches it does not introduce the need to switch the language to a (static) type system, which is known to change the semantics in languages like Prolog. We also study the approach experimentally and evaluate the overhead reduction achieved in the run-time checks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nataliia</first_name>
          <last_name>Stulova</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>José</first_name>
          <last_name>Morales</last_name>
          <affiliation>IMDEA Software Institute</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://software.imdea.org/people/josef.morales/index.html</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Hermenegildo</last_name>
          <affiliation>IMDEA Software Institute and T.U. of Madrid (UPM)</affiliation>
          <bio>Manuel Hermenegildo is a Full Professor and (Founding) Scientific Director of the IMDEA Software Institute. He is also a full Prof. of Computer Science at the Tech. U. of Madrid, UPM. Previously he held an Endowed Chair in Information Science and Technology at the U. of New Mexico. He was also project leader at the MCC research center and Adjunct Assoc. Prof. at the CS Department of the U. of Texas, both in Austin, Texas. See his home page for more information.
Research interests: Energy-Aware Computing, Resource / non-functional property analysis, verification, and control; Global Program Analysis, Optimization, Verification, Debugging; Abstract Interpretation; Partial Evaluation; Parallelism and Parallelizing Compilers; Constraint/Logic/Functional Programming Theory and Implementation, Abstract Machines; Automatic Documentation Tools, Execution Visualization; Sequential and Parallel Computer Architecture.</bio>
          <homepage_url>http://cliplab.org/herme</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/manuelhermengildo/8eef27e4-befd-4c22-b6c8-20207eb80fd4/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>20th International Symposium on  Practical Aspects of Declarative Languages </track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c6ae69d8-1737-4bf6-9049-b94b9f49dfee</subevent_id>
    <title>PADL 2018: Best Papers &amp; Panel</title>
    <subevent_type type="regular"/>
    <room>PADL</room>
    <date>2018/01/09</date>
    <url>https://popl18.sigplan.org/track/PADL-2018</url>
    <url_link_display>20th International Symposium on  Practical Aspects of Declarative Languages </url_link_display>
    <tracks>
      <track>20th International Symposium on  Practical Aspects of Declarative Languages </track>
    </tracks>
    <timeslot>
      <slot_id>1a87a968-c095-4f02-b8bb-1f24630f2397</slot_id>
      <title>Optimizing Answer Set Computation via Heuristic-Based Decomposition</title>
      <room>Omni Hotel | PADL</room>
      <date>2018/01/09</date>
      <start_time>16:30</start_time>
      <end_time>17:00</end_time>
      <description>Answer Set Programming (ASP) is a purely declarative formalism, developed in the field of logic programming and nonmonotonic reasoning. In ASP, computational problems are encoded by logic programs whose answer sets, corresponding to solutions, are computed by an ASP system. In general, several programs semantically equivalent might be defined for the same problem; however, performance of ASP systems while evaluating them might significantly vary. In this work we propose a method for automatically transform an encoding into an equivalent one that can be evaluated more efficiently. The method makes use of hypertree decomposition techniques guided by proper heuristics. We embed the resulting technique into the ASP grounder I-DLV, and experimentally test it in order to asses performance improvements.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Francesco</first_name>
          <last_name>Calimeri</last_name>
          <affiliation>University of Calabria</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.mat.unical.it/calimeri</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/francescocalimeri/f342a94a-baec-4833-b478-e662c8df92e4/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Davide</first_name>
          <last_name>Fuscà</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Simona</first_name>
          <last_name>Perri</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jessica</first_name>
          <last_name>Zangari</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>20th International Symposium on  Practical Aspects of Declarative Languages </track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7610908b-fc2a-4ce7-9b23-37e38bcdc88d</slot_id>
      <title>Panel on Practical Aspects of Declarative Programming: Future of declarative languages &amp; applications</title>
      <room>Omni Hotel | PADL</room>
      <date>2018/01/09</date>
      <start_time>17:00</start_time>
      <end_time>17:50</end_time>
      <description>undefined</description>
      <tracks>
        <track>20th International Symposium on  Practical Aspects of Declarative Languages </track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>885c5f29-1b8f-48e1-89c9-800979a793ab</slot_id>
      <title>Probabilistic Functional Logic Programming</title>
      <room>Omni Hotel | PADL</room>
      <date>2018/01/09</date>
      <start_time>16:00</start_time>
      <end_time>16:30</end_time>
      <description>This paper presents PFLP, a library for probabilistic programming in the functional logic programming language Curry. It demonstrates how the concepts of a functional logic programming language support the implementation of a library for probabilistic programming. In fact, the paradigms of functional logic and probabilistic programming are closely connected. That is, we can apply techniques from one area to the other and vice versa. We will see that an implementation based on the concepts of functional logic programming can have benefits with respect to performance compared to a standard list-based implementation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sandra</first_name>
          <last_name>Dylus</last_name>
          <affiliation>University of Kiel, Germany</affiliation>
          <bio>PhD student in PL</bio>
          <homepage_url>https://www.ps.informatik.uni-kiel.de/de/team/m.sc.-sandra-dylus</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/sandradylus/71a2fec1-7640-4891-9509-fcd1d4f470ff/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jan</first_name>
          <last_name>Christiansen</last_name>
          <affiliation>Flensburg University of Applied Sciences, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl18.sigplan.org/getProfileImage/janchristiansen/3a012d8a-2ac8-4e42-b74e-819c7e12df38/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Finn</first_name>
          <last_name>Teegen</last_name>
          <affiliation>University of Kiel, Germany</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>20th International Symposium on  Practical Aspects of Declarative Languages </track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b7257f37-e79a-475f-8d98-cf2c07979b7c</slot_id>
      <title>Closing</title>
      <room>Omni Hotel | PADL</room>
      <date>2018/01/09</date>
      <start_time>17:50</start_time>
      <end_time>18:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>20th International Symposium on  Practical Aspects of Declarative Languages </track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>105ac2fa-0a9a-414c-965d-f54ab11c053c</subevent_id>
    <title>PADL 2018: Functional Programming</title>
    <subevent_type type="regular"/>
    <room>PADL</room>
    <date>2018/01/09</date>
    <url>https://popl18.sigplan.org/track/PADL-2018</url>
    <url_link_display>20th International Symposium on  Practical Aspects of Declarative Languages </url_link_display>
    <tracks>
      <track>20th International Symposium on  Practical Aspects of Declarative Languages </track>
    </tracks>
    <timeslot>
      <slot_id>4d8370ff-5da1-4524-8f7a-3c13e58ff90f</slot_id>
      <title>Snaarkl: Somewhat Practical, Pretty Much Declarative Verifiable Computing in Haskell</title>
      <room>Omni Hotel | PADL</room>
      <date>2018/01/09</date>
      <start_time>11:00</start_time>
      <end_time>11:30</end_time>
      <description>Verifiable computing (VC) uses cryptography to delegate computation to untrusted workers. But in most VC schemes, the delegated program must first be arithmetized – expressed as a circuit with multiplication and addition over a finite field. Previous work has compiled subsets of languages like C, LLVM, and bespoke assembly to arithmetic circuits. In this paper, we report on a new DSL for VC, called Snaarkl (``Snorkel''), that supports encodings of language features familiar from functional programming such as products, case analysis, and inductive datatypes. We demonstrate that simple constraint-minimization techniques are an effective means of optimizing and solving the resulting encodings, and therefore of generating and constructing witnesses for small circuits.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gordon</first_name>
          <last_name>Stewart</last_name>
          <affiliation>Ohio University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://oucsace.cs.ohiou.edu/~gstewart/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Samuel</first_name>
          <last_name>Merten</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Logan</first_name>
          <last_name>Leland</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>20th International Symposium on  Practical Aspects of Declarative Languages </track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6da4e487-6209-42da-9a62-01943425b158</slot_id>
      <title>Hygienic Source-Code Generation Using Functors</title>
      <room>Omni Hotel | PADL</room>
      <date>2018/01/09</date>
      <start_time>10:30</start_time>
      <end_time>11:00</end_time>
      <description>Existing source-code-generating tools such as Lex and Yacc suffer from practical inconveniences because they use disembodied code to implement actions. To prevent this problem, such tools could generate closed functors that are then instantiated by the programmer with appropriate action code. This results in all code being type checked in its appropriate context, and it assists the type checker in localizing errors correctly. We have implemented a lexer generator and parser generator based on this technique for both Standard ML and Haskell.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Karl</first_name>
          <last_name>Crary</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>20th International Symposium on  Practical Aspects of Declarative Languages </track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9714355d-a60c-4cc3-a8c0-f1b7a36549f2</slot_id>
      <title>Rewriting High-Level Spreadsheet Structures into Higher-Order Functional Programs</title>
      <room>Omni Hotel | PADL</room>
      <date>2018/01/09</date>
      <start_time>11:30</start_time>
      <end_time>12:00</end_time>
      <description>Spreadsheets are used heavily in industry and academia. Often, spreadsheet models are developed for years and their complexity grows vastly beyond what the paradigm was originally conceived for. Such complexity often comes at the cost of maintainability and understandability, as well as recalculation performance. The former have been the subject of prior research, with a focus on helping users understand the high-level structure of spreadsheet models. However, the high-level structure could also be used to improve recalculation performance. In this paper, we devise rules for rewriting high-level spreadsheet structure over cell arrays into higher-order functional programs. This rewriting allows us to exploit implicit parallelism, thereby speeding up spreadsheet recalculation. We implement our rule set for the experimental Funcalc spreadsheet engine which already implements parallelizable higher-order functions on arrays and additionally user-defined higher-order functions. Benchmarks show that our rewriting approach improves recalculation performance for spreadsheets which are dominated by cell arrays, but also that sequential cell dependencies limit parallel speedup.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Florian</first_name>
          <last_name>Biermann</last_name>
          <affiliation>IT University of Copenhagen</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fbie.github.io</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/florianbiermann/6c94347d-bbb9-4a85-a47f-e45883563da2/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Wensheng</first_name>
          <last_name>Dou</last_name>
          <affiliation> State Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Sciences, Beijing</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.tcse.cn/~wsdou/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/wenshengdou/c93a77ee-700c-49cf-b181-c56c45559f38/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Peter</first_name>
          <last_name>Sestoft</last_name>
          <affiliation>IT University of Copenhagen</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.itu.dk/people/sestoft/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>20th International Symposium on  Practical Aspects of Declarative Languages </track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>bb2648ca-9f54-4f6f-8f4a-6ef84a065f31</subevent_id>
    <title>PADL 2018: Invited Talk II</title>
    <subevent_type type="regular"/>
    <room>PADL</room>
    <date>2018/01/09</date>
    <url>https://popl18.sigplan.org/track/PADL-2018</url>
    <url_link_display>20th International Symposium on  Practical Aspects of Declarative Languages </url_link_display>
    <tracks>
      <track>20th International Symposium on  Practical Aspects of Declarative Languages </track>
    </tracks>
    <timeslot>
      <slot_id>82226344-32f9-4b77-b78f-ee89236a8844</slot_id>
      <title>INVITED TALK: Declarative Algorithms on Big Data: a Logic-Based Solution</title>
      <room>Omni Hotel | PADL</room>
      <date>2018/01/09</date>
      <start_time>09:00</start_time>
      <end_time>10:00</end_time>
      <description>The ability of combining declarative specications with efficient implementations is critical to achieve portability and scalability via parallelization of Big Data applications. We will describe the recent progress made toward these objectives at UCLA, progress which is confirming the great potential that logic-based languages can have in this role over a wide range of applications. Indeed our Bigdatalog system on Apache Spark outperforms GraphX on graph applications and has achieved portability over multiple platforms. These high levels of performance, portability and scalability have been obtained while preserving a totally declarative stable-model semantics for recursive Datalog programs that use aggregates in recursion when these programs satisfy a condition called pre-mappability. We show that textbook polynomial-time algorithms can be tersely expressed using such programs, and provide simple conditions that allow users to verify that pre-mappability holds for their programs - thus allowing them to assure that efficiently-computable unique stable models exist for their declarative algorithms. Finally, we will discuss applications of these advances to other systems, and overview the design and implementation of an SQL DBMS prototype that supports similar advances.</description>
      <persons>
        <person>
          <role>invited speaker</role>
          <sort_key>1</sort_key>
          <first_name>Carlo</first_name>
          <last_name>Zaniolo</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>20th International Symposium on  Practical Aspects of Declarative Languages </track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>65a68987-f9f2-4e91-ba12-074c5505623d</subevent_id>
    <title>PADL 2018: Constraint Programming &amp; Business Rules</title>
    <subevent_type type="regular"/>
    <room>PADL</room>
    <date>2018/01/08</date>
    <url>https://popl18.sigplan.org/track/PADL-2018</url>
    <url_link_display>20th International Symposium on  Practical Aspects of Declarative Languages </url_link_display>
    <tracks>
      <track>20th International Symposium on  Practical Aspects of Declarative Languages </track>
    </tracks>
    <timeslot>
      <slot_id>7b60d11a-29d7-481b-a2e8-850b65f7ee3d</slot_id>
      <title>An Automated Detection of Inconsistencies in SBVR-based Business Rules using Many-sorted Logic</title>
      <room>Omni Hotel | PADL</room>
      <date>2018/01/08</date>
      <start_time>16:00</start_time>
      <end_time>16:30</end_time>
      <description>Business rules control and constrain the behavior and structure of the business system in terms of its policies and principles. Business rules are restructured frequently as per the internal or external circumstances based on market opportunities, statutory regulations, and business focus. Unfortunately, the current practice in industry, of detecting inconsistencies manually, becomes tedious and error prone, due to the size, complexity and ambiguity in representation using natural language. The approach presented in this work to detect inconsistencies in business rules is based on model checking that exploits the FOL basis of SBVR specification. In this paper, we aim to reduce the burden on solvers and obtain effective system level test data, leading to the development of a novel inconsistency rule checker based on extracting the unsatisfiable cores using solvers like Z3, CVC4, etc. We introduce the concept of graphical clusters, to partition SBVR vocabularies and represent the former exploiting the many-sorted logic and graph reachability algorithm, thus reducing the domain of quantification and the number of uninterpreted functions. The translation of SBVR to SMT-LIBv2 is implemented as part of our tool BuRRiTo which employs certain FOL solvers. Experimental results are shown on industrial level rule sets with seeded inconsistencies.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kritika</first_name>
          <last_name>Anand</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Pavan</first_name>
          <last_name>Chittimalli</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ravindra</first_name>
          <last_name>Naik</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>20th International Symposium on  Practical Aspects of Declarative Languages </track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a7b1f4fe-a033-49dd-bd2a-582f234e6d55</slot_id>
      <title>Three is a crowd: SAT, SMT and CLP on a chessboard</title>
      <room>Omni Hotel | PADL</room>
      <date>2018/01/08</date>
      <start_time>16:30</start_time>
      <end_time>17:00</end_time>
      <description>Constraint solving technology for declarative formal models has made considerable progress in recent years, and has many applications such as animation of high-level specifications, test case generation, or symbolic model checking. In this article we evaluate the idea of using very high-level declarative models themselves to express constraint satisfaction problems. In particular, we study an old mathematical puzzle from 100 years ago, called the crowded chessboard. We study various high-level and low-level encodings and solutions, covering SAT, SMT and CLP-based solutions of the puzzle. Additionally, we present a new technique combining SAT-solving with CLP which is able to solve the puzzle efficiently</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sebastian</first_name>
          <last_name>Krings</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael</first_name>
          <last_name>Leuschel</last_name>
          <affiliation>University of Düsseldorf</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Philipp</first_name>
          <last_name>Koerner</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Stefan</first_name>
          <last_name>Hallerstede</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Miran</first_name>
          <last_name>Hasanagic</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>20th International Symposium on  Practical Aspects of Declarative Languages </track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>42cf8fb1-928e-4ac0-8d75-0e0f69d43ff6</subevent_id>
    <title>PADL 2018: Answer Set Programming</title>
    <subevent_type type="regular"/>
    <room>PADL</room>
    <date>2018/01/09</date>
    <url>https://popl18.sigplan.org/track/PADL-2018</url>
    <url_link_display>20th International Symposium on  Practical Aspects of Declarative Languages </url_link_display>
    <tracks>
      <track>20th International Symposium on  Practical Aspects of Declarative Languages </track>
    </tracks>
    <timeslot>
      <slot_id>50ae3603-eb37-4b83-b110-b28cb301dcbd</slot_id>
      <title>A REST-based Development Framework for ASP: Tools and Application</title>
      <room>Omni Hotel | PADL</room>
      <date>2018/01/09</date>
      <start_time>14:30</start_time>
      <end_time>15:00</end_time>
      <description>Answer Set Programming (ASP) is a declarative programming paradigm that has been successfully used in a number of industry-level applications also thanks to the availability of development tools. REpresentation State Transfer (REST) Web Services recently became a common and widely-used tool for enterprise applications. A service- oriented infrastructure for ASP is not available, and this results in an obstacle for the adoption of ASP-based solutions. We address this issue by introducing a REST-based framework for ASP. Moreover, we report on the usage of the framework for developing a service of surveillance for photovoltaic plants.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gelsomina</first_name>
          <last_name>Catalano</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Giovanni</first_name>
          <last_name>Laboccetta</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Kristian</first_name>
          <last_name>Reale</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Francesco</first_name>
          <last_name>Ricca</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Pierfrancesco</first_name>
          <last_name>Veltri</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>20th International Symposium on  Practical Aspects of Declarative Languages </track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7e2111a7-4bcf-4486-a25d-1e04911a4c32</slot_id>
      <title>LoIDE: a a web-based IDE for Logic Programming - Preliminary Report</title>
      <room>Omni Hotel | PADL</room>
      <date>2018/01/09</date>
      <start_time>15:00</start_time>
      <end_time>15:30</end_time>
      <description>Logic-based paradigms are nowadays widely used in many different fields, also thank to the availability of robust tools and systems that allow the development of real-world and industrial applications. In this work we present LoIDE, an advanced and modular web-editor for logic-based languages that also integrates with state-of-the-art solvers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Stefano</first_name>
          <last_name>Germano</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Francesco</first_name>
          <last_name>Calimeri</last_name>
          <affiliation>University of Calabria</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.mat.unical.it/calimeri</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/francescocalimeri/f342a94a-baec-4833-b478-e662c8df92e4/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Eliana</first_name>
          <last_name>Palermiti</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>20th International Symposium on  Practical Aspects of Declarative Languages </track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d4d27064-32cd-4fbf-b3c7-649f682ce248</slot_id>
      <title>Automatic Web Services Composition for Phylotastic</title>
      <room>Omni Hotel | PADL</room>
      <date>2018/01/09</date>
      <start_time>13:30</start_time>
      <end_time>14:00</end_time>
      <description>We describe an automatic web service composition framework for Phylotastic, a project aimed at developing a platform for generating phylogenetic trees. We will begin with a short description of Phylotastic. Afterwards, we present the overall architecture of our framework and describe its components such as the ontology API, the planning module, the workflow configuration module, the execution and monitoring module. We illustrate the working of our framework using a use case and discuss the desirable features of the final system.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Thanh</first_name>
          <last_name>Nguyen</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tran Cao</first_name>
          <last_name>Son</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Enrico</first_name>
          <last_name>Pontelli</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>20th International Symposium on  Practical Aspects of Declarative Languages </track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d4eb7615-df55-4df6-8fac-ddadcbd4e68e</slot_id>
      <title>Navigating Online Semantic Resources for Entity Set Expansion</title>
      <room>Omni Hotel | PADL</room>
      <date>2018/01/09</date>
      <start_time>14:00</start_time>
      <end_time>14:30</end_time>
      <description>Semantic resources (WordNet, Wikidata, BabelNet, …) offer invaluable knowledge that can be exploited by humans and machines to solve a variety of tasks. Among these, we address here the one called entity set expansion: extend a given a set of words –called seeds– with new ones being of the same “sort”. Differently from classical approaches, we determine “optimal” common categories of the given seeds by analyzing the semantic relations among the objects these seeds refer to. In particular, we define the notion of entity network to integrate information from different semantic resources, and show how to use such networks to disambiguate word senses. Finally, we propose a proof-of-concept implementation in answer set programming with external predicates to query online semantic resources and perform optimization tasks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Weronika T.</first_name>
          <last_name>Adrian</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marco</first_name>
          <last_name>Manna</last_name>
          <affiliation>University of Calabria</affiliation>
          <bio>Marco Manna is an Associate Professor in the Department of Mathematics and Computer Science at University of Calabria, where he has been also a member of the Scientific Board of the PhD programme since 2012. Currently, he teaches both “Theoretical Computer Science” and “Web 2.0 - Interactive and Multichannel Technologies”. He received the Master Degree in Computer Engineering from the University of Calabria in May 2005. In February 2009, he received a PhD in Mathematics and Computer Science from the University of Calabria. Before that, in 2008, Marco Manna was a visiting PhD student at the Oxford University Computing Laboratory and at the Oxford-Man Institute of Quantitative Finance. From 2009 to 2011, he was a Research Fellow in Computer Science at the University of Calabria. Subsequently, in 2012, he was also a Research Assistant in the Department of Computer Science at the University of Oxford. Form 2012 to 2016 he was an Assistant Professor of Computer Science at the University of Calabria. Since 2006, he has been involved in a number of (national and international) projects on Knowledge Representation, Reasoning and Logic, and Natural Language Processing and Information Retrieval. In particular, he was (2013 - 2015) workpackage leader in KnowRex: Un sistema per il riconoscimento e l’estrazione di conoscenza (POR Calabria FESR 2007-2013), and (2010 - 2015) external collaborator in DIADEM: Domain-centric Intelligent Automated Data Extraction Methodology (European project FP7/ERC). He has been PC member of AAAI-18, IJCAI-17, IJCAI-16, and IJCAI-15, as well as a reviewer for Artificial Intelligence Journal since 2013.</bio>
          <homepage_url>https://www.mat.unical.it/manna/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/marcomanna/991e2ccf-0394-43a1-aaca-fb4c0f9b2aa4/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>20th International Symposium on  Practical Aspects of Declarative Languages </track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>82ebe64d-ddf2-42b3-b2e3-c9dd9bc60c29</subevent_id>
    <title>PADL 2018: Opening &amp; Invited Talk I</title>
    <subevent_type type="regular"/>
    <room>PADL</room>
    <date>2018/01/08</date>
    <url>https://popl18.sigplan.org/track/PADL-2018</url>
    <url_link_display>20th International Symposium on  Practical Aspects of Declarative Languages </url_link_display>
    <tracks>
      <track>20th International Symposium on  Practical Aspects of Declarative Languages </track>
    </tracks>
    <timeslot>
      <slot_id>557d016f-8e8a-40ec-b12c-084a8a69d112</slot_id>
      <title>INVITED TALK: On k-colored Lambda Terms and their Skeletons </title>
      <room>Omni Hotel | PADL</room>
      <date>2018/01/08</date>
      <start_time>14:00</start_time>
      <end_time>14:30</end_time>
      <description>The paper describes an application of logic programming to the modeling of difficult combinatorial properties of lambda terms, with focus on the class of simply typed terms. Lambda terms in de Bruijn notation are Motzkin trees (also called binary-unary trees) with indices at their leaves counting up on the path to the root the steps to their lambda binder. As a generalization of {\em affine lambda terms}, we introduce {\em k-colored lambda terms} obtained by labeling their lambda nodes with counts of the variables they bind. We define the {\em skeleton of a k-colored lambda term} as the Motzkin tree obtained by erasing the de Bruijn indices labeling its leaves and we give a bijection between 2-colored skeletons and binary trees that reveals their connection to the Catalan family of combinatorial objects. After a statistical study of properties of {\em k-colored lambda terms} and their skeletons, we focus on the case of simply-typed k-colored lambda terms for which a new combinatorial generation algorithm is given and some interesting relations between maximal coloring, size of type expressions and typability are explored. The paper is structured as a literate Prolog program to facilitate an easily replicable, concise and declarative expression of our concepts and algorithms.</description>
      <persons>
        <person>
          <role>invited speaker</role>
          <sort_key>1</sort_key>
          <first_name>Paul</first_name>
          <last_name>Tarau</last_name>
          <affiliation>University of North Texas</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.unt.edu/~tarau/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/paultarau/79013cf3-bf98-4bbd-aaec-7f4bdc977f08/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>20th International Symposium on  Practical Aspects of Declarative Languages </track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a02fb3ea-433f-42fd-942e-96060ecd838f</slot_id>
      <title>Opening</title>
      <room>Omni Hotel | PADL</room>
      <date>2018/01/08</date>
      <start_time>13:30</start_time>
      <end_time>13:40</end_time>
      <description>undefined</description>
      <tracks>
        <track>20th International Symposium on  Practical Aspects of Declarative Languages </track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>393f3fc0-5c19-44f7-bd65-3a4876b03d5e</subevent_id>
    <title>VMCAI 2018: Abstract Interpretation</title>
    <subevent_type type="regular"/>
    <room>VMCAI</room>
    <date>2018/01/08</date>
    <url>https://popl18.sigplan.org/track/VMCAI-2018</url>
    <url_link_display>19th International Conference on Verification, Model Checking, and Abstract Interpretation</url_link_display>
    <tracks>
      <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
    </tracks>
    <timeslot>
      <slot_id>0a5f965c-dc6b-43ec-892f-a7a3ce037bf7</slot_id>
      <title>On Constructivity of Galois Connections</title>
      <room>Omni Hotel | VMCAI</room>
      <date>2018/01/08</date>
      <start_time>10:30</start_time>
      <end_time>11:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Francesco</first_name>
          <last_name>Ranzato</last_name>
          <affiliation>University of Padova</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.math.unipd.it/~ranzato/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/francescoranzato/319b8e10-9d08-4060-889f-c55067c7ffed/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>75cb3fb9-0eb3-4334-9989-7762ef3ba65d</slot_id>
      <title>An Abstract Interpretation Framework for the Round-Off Error Analysis of Floating-Point Programs</title>
      <room>Omni Hotel | VMCAI</room>
      <date>2018/01/08</date>
      <start_time>11:00</start_time>
      <end_time>11:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Laura</first_name>
          <last_name>Titolo</last_name>
          <affiliation>National Institute of Aerospace, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://users.dimi.uniud.it/~laura.titolo/Laura/Home_Page.html</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marco A.</first_name>
          <last_name>Feliu</last_name>
          <affiliation>National Institute of Aerospace</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Mariano</first_name>
          <last_name>Moscato</last_name>
          <affiliation>National Institute of Aerospace</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Cesar</first_name>
          <last_name>Munoz</last_name>
          <affiliation>NASA</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>88b2da3c-b29b-4daf-9638-6c757dbb04e7</slot_id>
      <title>Modular Analysis of Executables using On-Demand Heyting Completion</title>
      <room>Omni Hotel | VMCAI</room>
      <date>2018/01/08</date>
      <start_time>11:30</start_time>
      <end_time>12:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Julian</first_name>
          <last_name>Kranz</last_name>
          <affiliation>Technical University of Munich</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Axel</first_name>
          <last_name>Simon</last_name>
          <affiliation>Google</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f584458f-8e54-4999-a3ad-29e15b094020</subevent_id>
    <title>VMCAI 2018: Verification</title>
    <subevent_type type="regular"/>
    <room>VMCAI</room>
    <date>2018/01/07</date>
    <url>https://popl18.sigplan.org/track/VMCAI-2018</url>
    <url_link_display>19th International Conference on Verification, Model Checking, and Abstract Interpretation</url_link_display>
    <tracks>
      <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
    </tracks>
    <timeslot>
      <slot_id>06949655-3840-4fae-8294-0e54e37b1a56</slot_id>
      <title>P5: Planner-less Proofs of Probabilistic Parameterized Protocols</title>
      <room>Omni Hotel | VMCAI</room>
      <date>2018/01/07</date>
      <start_time>15:00</start_time>
      <end_time>15:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lenore</first_name>
          <last_name>Zuck</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kenneth L.</first_name>
          <last_name>McMillan</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>Ken McMillan is a principal researcher at Microsoft Research in Redmond, Washington. He works in formal verification, primarily in model checking for hardware and software. He holds a BS in electrical engineering from the University of Illinois at Urbana (1984), an MS in electrical engineering from Stanford (1986) and a Ph.D. in computer science from Carnegie Mellon (1992). He is the author of the book “Symbolic Model Checking”, and the SMV symbolic model checking system. For his work in model checking, he has received the ACM doctoral dissertation award, the SRC technical excellence award, the ACM Paris Kannelakis award, the Alan Newell award from Carnegie Mellon and the Computer-aided Verification Conference award. He was formerly a member of the technical staff at AT&amp;amp;T Bell Laboratories and a fellow at Cadence research labs.</bio>
          <homepage_url>https://www.microsoft.com/en-us/research/people/kenmcmil/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/kennethlmcmillan/e2fd4a89-3521-46db-ad28-ea8640d21303/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jordan</first_name>
          <last_name>Torf</last_name>
          <affiliation>UIC</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>122ec7da-367f-494f-8cd7-b54fd676d66b</slot_id>
      <title>A Logical System for Modular Information Flow Verification</title>
      <room>Omni Hotel | VMCAI</room>
      <date>2018/01/07</date>
      <start_time>14:30</start_time>
      <end_time>15:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Adi</first_name>
          <last_name>Prabawa</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mahmudul Faisal</first_name>
          <last_name>Al Ameen</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benedict</first_name>
          <last_name>Lee</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Wei-Ngan</first_name>
          <last_name>Chin</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ad3b6996-dfdd-4662-ac18-3f4a1adde53c</slot_id>
      <title>Gradual Program Verification</title>
      <room>Omni Hotel | VMCAI</room>
      <date>2018/01/07</date>
      <start_time>14:00</start_time>
      <end_time>14:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Johannes</first_name>
          <last_name>Bader</last_name>
          <affiliation>Microsoft</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.johannes-bader.com</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/johannesbader/0b7e635c-fba7-4113-a53d-4451edd44ca5/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Aldrich</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Jonathan Aldrich is Associate Professor of Computer Science at Carnegie Mellon University. He is the director of CMU’s Software Engineering Ph.D. program, and teaches courses in programming languages, software engineering, and program analysis for quality and security. In addition, he serves as a consultant on architecture, design, and legal issues in the software industry. Dr. Aldrich joined the CMU faculty after completing a Ph.D. at the University of Washington and a B.S. at Caltech.
Dr. Aldrich’s research centers on programming languages and type systems that are deeply informed by software engineering considerations. His research contributions include verifying the correct implementation of an architectural design, modular formal reasoning about code, and API protocol specification and verification. For his work on software architecture, Aldrich received a 2006 NSF CAREER award and the 2007 Dahl-Nygaard Junior Prize, given annually for a significant technical contribution to object-oriented programming. He is currently performing research on extensible programming languages, analysis and type systems for security and productivity, and foundations of object-oriented programming.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aldrich/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/jonathanaldrich/e4add3cf-580c-4d1b-9832-3f7577a14b72/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Éric</first_name>
          <last_name>Tanter</last_name>
          <affiliation>University of Chile</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pleiad.cl/people/etanter</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/etanter/9bd12954-3541-41ba-9fb4-9ca8e0701371/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e37abc84-3740-401d-b32e-f91a3877f38e</subevent_id>
    <title>VMCAI 2018: Model Checking</title>
    <subevent_type type="regular"/>
    <room>VMCAI</room>
    <date>2018/01/09</date>
    <url>https://popl18.sigplan.org/track/VMCAI-2018</url>
    <url_link_display>19th International Conference on Verification, Model Checking, and Abstract Interpretation</url_link_display>
    <tracks>
      <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
    </tracks>
    <timeslot>
      <slot_id>12f05278-f3cb-4a4f-9b92-62ae6d742a9a</slot_id>
      <title>Parameterized Model Checking of Synchronous Distributed Algorithms by Abstraction</title>
      <room>Omni Hotel | VMCAI</room>
      <date>2018/01/09</date>
      <start_time>17:00</start_time>
      <end_time>17:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Benjamin</first_name>
          <last_name>Aminof</last_name>
          <affiliation>Vienna University of Technology</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sasha</first_name>
          <last_name>Rubin</last_name>
          <affiliation>University of Naples Federico II</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://sasharubin.github.io/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ilina</first_name>
          <last_name>Stoilkovska</last_name>
          <affiliation>Vienna University of Technology	</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Josef</first_name>
          <last_name>Widder</last_name>
          <affiliation>TU Wien</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://forsyte.at/widder</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/josefwidder/00270144-5414-4755-8247-696f8068049b/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Florian</first_name>
          <last_name>Zuleger</last_name>
          <affiliation>TU Vienna</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://forsyte.at/people/zuleger/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3546e3fb-b6ef-4262-ad52-520a0cbbca1f</slot_id>
      <title>Learning to Complement Büchi Automata</title>
      <room>Omni Hotel | VMCAI</room>
      <date>2018/01/09</date>
      <start_time>16:00</start_time>
      <end_time>16:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yong</first_name>
          <last_name>Li</last_name>
          <affiliation>Institute of Software, Chinese Academy of Sciences</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andrea</first_name>
          <last_name>Turrini</last_name>
          <affiliation>State Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Sciences</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Lijun</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Institute of Software, Chinese Academy of Sciences</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Sven</first_name>
          <last_name>Schewe</last_name>
          <affiliation>University of Liverpool</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.csc.liv.ac.uk/~sven/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>deb942a0-3dcb-4367-bc05-60ff3e5f5844</slot_id>
      <title>Selfless Interpolation for Infinite-State Model Checking</title>
      <room>Omni Hotel | VMCAI</room>
      <date>2018/01/09</date>
      <start_time>16:30</start_time>
      <end_time>17:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tanja</first_name>
          <last_name>Schindler</last_name>
          <affiliation>University of Freiburg</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://swt.informatik.uni-freiburg.de/staff/schindler</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dejan</first_name>
          <last_name>Jovanović</last_name>
          <affiliation>SRI International</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://csl.sri.com/users/dejan/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/dejanjovanovic/ebb3e04b-ce7c-4489-85fc-d21fa51e9e15/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b9be7c1b-2707-497b-9593-c5f4fe4ddac3</subevent_id>
    <title>VMCAI 2018: Security</title>
    <subevent_type type="regular"/>
    <room>VMCAI</room>
    <date>2018/01/07</date>
    <url>https://popl18.sigplan.org/track/VMCAI-2018</url>
    <url_link_display>19th International Conference on Verification, Model Checking, and Abstract Interpretation</url_link_display>
    <tracks>
      <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
    </tracks>
    <timeslot>
      <slot_id>6e020f35-3e02-44ad-9311-3ebd8c6e6164</slot_id>
      <title>Scalable Approximation of Quantitative Information Flow in Programs</title>
      <room>Omni Hotel | VMCAI</room>
      <date>2018/01/07</date>
      <start_time>16:30</start_time>
      <end_time>17:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fabrizio</first_name>
          <last_name>Biondi</last_name>
          <affiliation>CentraleSupelec Rennes</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mike</first_name>
          <last_name>Enescu</last_name>
          <affiliation>INRIA</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Annelie</first_name>
          <last_name>Heuser</last_name>
          <affiliation>CNRS/IRISA</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Axel</first_name>
          <last_name>Legay</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Kuldeep S.</first_name>
          <last_name>Meel</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Jean</first_name>
          <last_name>Quilbeuf</last_name>
          <affiliation>INRIA</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7584a038-dc42-4c9f-a348-bb02ffb96ae8</slot_id>
      <title>Abstract Code Injection - A Semantic Approach Based on Abstract Non-Interference</title>
      <room>Omni Hotel | VMCAI</room>
      <date>2018/01/07</date>
      <start_time>17:00</start_time>
      <end_time>17:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Samuele</first_name>
          <last_name>Buro</last_name>
          <affiliation>Università degli Studi di Verona</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Isabella</first_name>
          <last_name>Mastroeni</last_name>
          <affiliation>University of Verona, Italy</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://profs.scienze.univr.it/mastroeni/Welcome.html</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/isabellamastroeni/35102ab8-17d3-49b9-8ae0-f3990cb799b5/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c880a38c-488b-46ce-a188-b3339a8c374d</slot_id>
      <title>Code Obfuscation Against Abstract Model Checking Attacks</title>
      <room>Omni Hotel | VMCAI</room>
      <date>2018/01/07</date>
      <start_time>16:00</start_time>
      <end_time>16:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Roberto</first_name>
          <last_name>Bruni</last_name>
          <affiliation>Dipartimento di Informatica, Universita' di Pisa</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Roberto</first_name>
          <last_name>Giacobazzi</last_name>
          <affiliation>University of Verona and IMDEA Software Institute</affiliation>
          <bio>Roberto Giacobazzi received the Laurea degree in Computer Science in 1988 from the University of Pisa, and in 1993 he received the Ph.D. in Computer Science from the same university, with a Ph.D. thesis on Semantic aspects of logic program analysis, under the supervision of Prof. Giorgio Levi. From 1993 to 1995 he had a Post Doctoral Research position at Laboratoire d’Informatique (LIX), Ecole Polytechnique (Paris) in the equipe Cousot. From 1995 to 1998 he was (tenured) Assistant Professor in Computer Science at the University of Pisa. From May 2000 until now he is Full Professor in Computer Science at the University of Verona. The research interests of Roberto Giacobazzi include abstract interpretation, static program analysis, semantics of programming languages, program verification, abstract model-checking, program transformation and optimization, digital asset protection, code obfuscation, malware detection, software watermarking and lattice theory. He has been Program Chair of SAS, VMCAI, of workshops in programming languages and language based security, and General Chair of ACM POPL2013. He is currently in the Steering committee of SAS and ACM POPL. From 2006 to 2012 he has been Dean of the College of Science of the University of Verona. He is now in his sabbatical year at IMDEA Software Institute.</bio>
          <homepage_url>http://profs.sci.univr.it/~giaco/index.html</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/robertogiacobazzi/3a292abe-6f69-4d5d-bfa3-305417b39cba/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Roberta</first_name>
          <last_name>Gori</last_name>
          <affiliation>Dipartimento di Informatica, Universita' di Pisa</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7ee1e60f-1f4f-4128-9ed0-095cfb079b2b</subevent_id>
    <title>VMCAI 2018: Verifying Protocols and Systems</title>
    <subevent_type type="regular"/>
    <room>VMCAI</room>
    <date>2018/01/09</date>
    <url>https://popl18.sigplan.org/track/VMCAI-2018</url>
    <url_link_display>19th International Conference on Verification, Model Checking, and Abstract Interpretation</url_link_display>
    <tracks>
      <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
    </tracks>
    <timeslot>
      <slot_id>11b0a787-21e6-4bb1-9ad6-fd1e282296a0</slot_id>
      <title>Co-Design and Verification of an Available File System</title>
      <room>Omni Hotel | VMCAI</room>
      <date>2018/01/09</date>
      <start_time>11:30</start_time>
      <end_time>12:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mahsa</first_name>
          <last_name>Najafzadeh</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marc</first_name>
          <last_name>Shapiro</last_name>
          <affiliation>LIP6</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Eugster</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>Professor Eugster’s research aims at proposing support for developing distributed systems. Particular topics of interest, in the context of distributed settings, include algorithms, middleware, and programming languages, abstractions, and methodologies.
Professor Eugster was educated in Switzerland, and has worked for both Swiss Federal Institutes of Technology in Lausanne (EPFL) and in Zurich (ETHZ), as well as for Sun Microsystems (now Oracle) prior to joining Purdue University. He has authored over 70 refereed articles, and is a member of ACM and IEEE. Among other awards for his research and teaching, Professor Eugster has received an NSF CAREER award (2007) and Experienced Researcher fellowship by the Alexander von Humboldt foundation (2011). He is also a participant of the 2011 DARPA Computer Science Study Panel.</bio>
          <homepage_url>https://www.cs.purdue.edu/people/faculty/peugster/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/patrickeugster/bf8c955c-8902-4678-8c57-4b75cbd4f3c0/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3a5e9741-4c1c-41a1-a93d-d261244327ae</slot_id>
      <title>Automatic Verification of Intermittent Systems</title>
      <room>Omni Hotel | VMCAI</room>
      <date>2018/01/09</date>
      <start_time>11:00</start_time>
      <end_time>11:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Manjeet</first_name>
          <last_name>Dahiya</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sorav</first_name>
          <last_name>Bansal</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>aa353ccb-0756-40da-86ca-5a7e85eb33d8</slot_id>
      <title>Analyzing Guarded Protocols: Better Cutoffs, More Systems, More Expressivity</title>
      <room>Omni Hotel | VMCAI</room>
      <date>2018/01/09</date>
      <start_time>10:30</start_time>
      <end_time>11:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Swen</first_name>
          <last_name>Jacobs</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mouhammad</first_name>
          <last_name>Sakr</last_name>
          <affiliation>Saarland University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.react.uni-saarland.de/people/sakr.html</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>151a67d9-a36e-4e6b-baeb-76fabf62cc54</subevent_id>
    <title>VMCAI 2018: Invited Talk by Kenneth L. McMillan</title>
    <subevent_type type="regular"/>
    <room>VMCAI</room>
    <date>2018/01/08</date>
    <url>https://popl18.sigplan.org/track/VMCAI-2018</url>
    <url_link_display>19th International Conference on Verification, Model Checking, and Abstract Interpretation</url_link_display>
    <tracks>
      <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
    </tracks>
    <timeslot>
      <slot_id>fe552ecb-49fb-4c2f-ad32-dc2e264a51b1</slot_id>
      <title>How to Stay Decidable</title>
      <room>Omni Hotel | VMCAI</room>
      <date>2018/01/08</date>
      <start_time>09:00</start_time>
      <end_time>10:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kenneth L.</first_name>
          <last_name>McMillan</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>Ken McMillan is a principal researcher at Microsoft Research in Redmond, Washington. He works in formal verification, primarily in model checking for hardware and software. He holds a BS in electrical engineering from the University of Illinois at Urbana (1984), an MS in electrical engineering from Stanford (1986) and a Ph.D. in computer science from Carnegie Mellon (1992). He is the author of the book “Symbolic Model Checking”, and the SMV symbolic model checking system. For his work in model checking, he has received the ACM doctoral dissertation award, the SRC technical excellence award, the ACM Paris Kannelakis award, the Alan Newell award from Carnegie Mellon and the Computer-aided Verification Conference award. He was formerly a member of the technical staff at AT&amp;amp;T Bell Laboratories and a fellow at Cadence research labs.</bio>
          <homepage_url>https://www.microsoft.com/en-us/research/people/kenmcmil/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/kennethlmcmillan/e2fd4a89-3521-46db-ad28-ea8640d21303/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>3a2362d5-b85c-428f-a167-251c46873067</subevent_id>
    <title>VMCAI 2018: Potpourri</title>
    <subevent_type type="regular"/>
    <room>VMCAI</room>
    <date>2018/01/08</date>
    <url>https://popl18.sigplan.org/track/VMCAI-2018</url>
    <url_link_display>19th International Conference on Verification, Model Checking, and Abstract Interpretation</url_link_display>
    <tracks>
      <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
    </tracks>
    <timeslot>
      <slot_id>1286325e-a9dc-440e-b9d3-e13e39d40cb0</slot_id>
      <title>On abstraction and compositionality for weak-memory linearisability</title>
      <room>Omni Hotel | VMCAI</room>
      <date>2018/01/08</date>
      <start_time>14:30</start_time>
      <end_time>15:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Brijesh</first_name>
          <last_name>Dongol</last_name>
          <affiliation>Brunel University London</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Radha</first_name>
          <last_name>Jagadeesan</last_name>
          <affiliation>DePaul University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>James</first_name>
          <last_name>Riely</last_name>
          <affiliation>DePaul University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Alasdair</first_name>
          <last_name>Armstrong</last_name>
          <affiliation>Brunel University</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1456985f-b789-4364-a104-343a4efe333a</slot_id>
      <title>Automatic Verification of RMA Programs via Abstraction Extrapolation</title>
      <room>Omni Hotel | VMCAI</room>
      <date>2018/01/08</date>
      <start_time>15:00</start_time>
      <end_time>15:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Cedric</first_name>
          <last_name>Baumann</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andrei Marian</first_name>
          <last_name>Dan</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>I am a PhD student in the Software Reliability Lab, supervised by Prof. Martin Vechev. My research focuses on static analysis techniques for relaxed memory models.</bio>
          <homepage_url>http://www.srl.ethz.ch/adan.php</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/andreidan/2dc3316d-d228-4b2e-9242-351a78a0e587/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yuri</first_name>
          <last_name>Meshman</last_name>
          <affiliation>IMDEA</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Torsten</first_name>
          <last_name>Hoefler</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>Torsten is an Assistant Professor of Computer Science at ETH Zürich, Switzerland. Before joining ETH, he led the performance modeling and simulation efforts of parallel petascale applications for the NSF-funded Blue Waters project at NCSA/UIUC. He is also a key member of the Message Passing Interface (MPI) Forum where he chairs the “Collective Operations and Topologies” working group. Torsten won best paper awards at the ACM/IEEE Supercomputing Conference 2010 (SC10), EuroMPI 2013, ACM/IEEE Supercomputing Conference 2013 (SC13), and other conferences. He published numerous peer-reviewed scientific conference and journal articles and authored chapters of the MPI-2.2 and MPI-3.0 standards. For his work, Torsten received the SIAM SIAG/Supercomputing Junior Scientist Prize in 2012 and the IEEE TCSC Young Achievers in Scalable Computing Award in 2013. Following his Ph.D., the received the Young Alumni Award 2014 from Indiana University. Torsten was elected into the first steering committee of ACM’s SIGHPC in 2013. His research interests revolve around the central topic of “Performance-centric Software Development” and include scalable networks, parallel programming techniques, and performance modeling. Additional information about Torsten can be found on his homepage at htor.inf.ethz.ch.</bio>
          <homepage_url>http://htor.inf.ethz.ch/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/torstenhoefler/b570b3f0-a91f-4651-8a80-cfde60d06190/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Martin</first_name>
          <last_name>Vechev</last_name>
          <affiliation>ETH Zürich</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.srl.inf.ethz.ch/vechev.php</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/martinvechev/4ae74bfd-22ac-4e29-a171-3fc706a85e3a/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3c4ac3d6-f8b5-4277-9f4b-3371a83db135</slot_id>
      <title>Revisiting MITL to Fix Decision Procedures</title>
      <room>Omni Hotel | VMCAI</room>
      <date>2018/01/08</date>
      <start_time>14:00</start_time>
      <end_time>14:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nima</first_name>
          <last_name>Roohi</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mahesh</first_name>
          <last_name>Viswanathan</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>20c6bd21-1269-41b0-882c-4cc528c9ffa7</subevent_id>
    <title>VMCAI 2018: Types and Analysis</title>
    <subevent_type type="regular"/>
    <room>VMCAI</room>
    <date>2018/01/09</date>
    <url>https://popl18.sigplan.org/track/VMCAI-2018</url>
    <url_link_display>19th International Conference on Verification, Model Checking, and Abstract Interpretation</url_link_display>
    <tracks>
      <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
    </tracks>
    <timeslot>
      <slot_id>2dd1ee2d-ded1-442f-b30a-08814de90887</slot_id>
      <title>Invariant Generation for Multi-Path Loops with Polynomial Assignments</title>
      <room>Omni Hotel | VMCAI</room>
      <date>2018/01/09</date>
      <start_time>14:30</start_time>
      <end_time>15:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Andreas</first_name>
          <last_name>Humenberger</last_name>
          <affiliation>Vienna University of Technology</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Maximilian</first_name>
          <last_name>Jaroschek</last_name>
          <affiliation>Vienna University of Technology</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Laura</first_name>
          <last_name>Kovacs</last_name>
          <affiliation>Chalmers University of Technology</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d7958f46-7f9f-4c7d-b3f6-6347fac94f20</slot_id>
      <title>Refinement Types for Ruby</title>
      <room>Omni Hotel | VMCAI</room>
      <date>2018/01/09</date>
      <start_time>15:00</start_time>
      <end_time>15:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Milod</first_name>
          <last_name>Kazerounian</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Niki</first_name>
          <last_name>Vazou</last_name>
          <affiliation>University of Maryland</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://nikivazou.github.io/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/nikivazou/8cc6ddec-154b-47e9-b40d-c66e78476391/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Austin</first_name>
          <last_name>Bourgerie</last_name>
          <affiliation>University of Maryland</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jeffrey S.</first_name>
          <last_name>Foster</last_name>
          <affiliation>University of Maryland, College Park</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.umd.edu/~jfoster</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/jeffreysfoster/b22ce952-32b0-48bd-be56-12fd87bf3469/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Emina</first_name>
          <last_name>Torlak</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>Emina Torlak is an Assistant Professor at the University of Washington, working at the intersection of programming languages, formal methods, and software engineering. She received her Bachelors (2003), Masters (2004), and Ph.D. (2009) degrees from MIT, and subsequently worked at IBM Research, LogicBlox, and as a research scientist at U.C. Berkeley. Her research focuses on developing automated tools and programming models for computer-aided design, verification, and synthesis of software. She is the creator of the Kodkod constraint solver, which has been used in over 70 academic and industrial tools for software engineering. Emina has applied her expertise to a broad range of problems, from verification of memory-consistency models to generation of test data for decision support applications. Her current work on the Rosette solver-aided language integrates constraint solvers into programming languages to support computer-aided verification, debugging, and synthesis of code, making programming a collaboration between humans and machines.</bio>
          <homepage_url>https://homes.cs.washington.edu/~emina/index.html</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/eminatorlak/b48dd8a1-4bf6-4d29-b6e3-fb0e9ea9ce8e/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f37893b9-0457-4fc6-a5b8-402ab42c8a3b</slot_id>
      <title>From Shapes to Amortized Complexity</title>
      <room>Omni Hotel | VMCAI</room>
      <date>2018/01/09</date>
      <start_time>14:00</start_time>
      <end_time>14:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tomas</first_name>
          <last_name>Fiedor</last_name>
          <affiliation>VUT Brno</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Lukas</first_name>
          <last_name>Holik</last_name>
          <affiliation>Brno University of Technology</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Adam</first_name>
          <last_name>Rogalewicz</last_name>
          <affiliation>Brno University of Technology </affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fit.vutbr.cz/~rogalew/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Moritz</first_name>
          <last_name>Sinn</last_name>
          <affiliation>St. Polten University of Applied Sciences</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://vorschau.fhstp.ac.at/de/uber-uns/mitarbeiter-innen-a-z/sinn-moritz-2</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Tomas</first_name>
          <last_name>Vojnar</last_name>
          <affiliation>Brno University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>www.fit.vutbr.cz/~vojnar</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Florian</first_name>
          <last_name>Zuleger</last_name>
          <affiliation>TU Vienna</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://forsyte.at/people/zuleger/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>dc58a365-4440-42fd-9786-02b05e624f95</subevent_id>
    <title>VMCAI 2018: Invited Tutorial by Mayur Naik</title>
    <subevent_type type="regular"/>
    <room>VMCAI</room>
    <date>2018/01/08</date>
    <url>https://popl18.sigplan.org/track/VMCAI-2018</url>
    <url_link_display>19th International Conference on Verification, Model Checking, and Abstract Interpretation</url_link_display>
    <tracks>
      <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
    </tracks>
    <timeslot>
      <slot_id>635bb018-51f8-4a24-8c17-72f2e5085ff1</slot_id>
      <title>Maximum Satisfiability in Program Analysis: Applications and Techniques</title>
      <room>Omni Hotel | VMCAI</room>
      <date>2018/01/08</date>
      <start_time>16:00</start_time>
      <end_time>17:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mayur</first_name>
          <last_name>Naik</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.seas.upenn.edu/~mhnaik/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/mayurnaik/681e8d43-e5b6-4a09-a8a5-11053f830db6/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Xujie</first_name>
          <last_name>Si</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.seas.upenn.edu/~xsi/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/xujiesi/239392c8-225d-49b8-8a09-05ec7ba5c7a3/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Xin</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>Xin Zhang is a postdoctoral associate at MIT. He is broadly interested in research topics related to programming languages and software engineering, including program analysis, program verification, program synthesis, mobile-cloud computing, and approximate computing.</bio>
          <homepage_url>http://people.csail.mit.edu/xzhang/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/xinzhang/a4dbba61-3d43-4702-818f-94cad593fbec/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Radu</first_name>
          <last_name>Grigore</last_name>
          <affiliation>University of Kent</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://rgrig.appspot.com/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/radugrigore/f90672c3-ee68-4466-84f5-5649b61973a0/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>d677870d-fd40-4710-8e93-e12d13d835f7</subevent_id>
    <title>VMCAI 2018: Invited Talk by Azadeh Farzan</title>
    <subevent_type type="regular"/>
    <room>VMCAI</room>
    <date>2018/01/09</date>
    <url>https://popl18.sigplan.org/track/VMCAI-2018</url>
    <url_link_display>19th International Conference on Verification, Model Checking, and Abstract Interpretation</url_link_display>
    <tracks>
      <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
    </tracks>
    <timeslot>
      <slot_id>48347f2f-2432-41a3-b612-d0a2721efd7a</slot_id>
      <title>Rethinking Compositionality for Concurrent Program Proofs</title>
      <room>Omni Hotel | VMCAI</room>
      <date>2018/01/09</date>
      <start_time>09:00</start_time>
      <end_time>10:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Azadeh</first_name>
          <last_name>Farzan</last_name>
          <affiliation>University of Toronto</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.toronto.edu/~azadeh/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/azadehfarzan/f0942c46-887a-4f22-bf78-74fd48f6f0ed/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c4b1e612-ba99-4ac0-a4ea-5e38efad1bb5</subevent_id>
    <title>VMCAI 2018: VMCAI Banquet</title>
    <subevent_type type="regular"/>
    <room>VMCAI</room>
    <date>2018/01/08</date>
    <url>https://popl18.sigplan.org/track/VMCAI-2018</url>
    <url_link_display>19th International Conference on Verification, Model Checking, and Abstract Interpretation</url_link_display>
    <tracks>
      <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
    </tracks>
    <timeslot>
      <slot_id>6b1f6b7f-c677-4c9e-b907-acf8ef12b620</slot_id>
      <title>Banquet</title>
      <room>Omni Hotel | VMCAI</room>
      <date>2018/01/08</date>
      <start_time>18:00</start_time>
      <end_time>22:00</end_time>
      <description>The VMCAI 2018 Banquet is in the 71Above Restaurant at the top of the U.S. Bank Tower. Arrive between 6pm and 6:30pm, enjoy the view of Los Angeles, and have a few tray-passed hors d’oeuvres. We will sit down to eat by the window at 7pm.
The U.S. Bank Tower is within walking distance of the conference hotel. If you like, join Jens Palsberg in the lobby of the conference hotel at 5:50pm and walk to the banquet.</description>
      <tracks>
        <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>10ff73c0-fdc2-404e-913a-8f9a969386da</subevent_id>
    <title>VMCAI 2018: Synthesis</title>
    <subevent_type type="regular"/>
    <room>VMCAI</room>
    <date>2018/01/07</date>
    <url>https://popl18.sigplan.org/track/VMCAI-2018</url>
    <url_link_display>19th International Conference on Verification, Model Checking, and Abstract Interpretation</url_link_display>
    <tracks>
      <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
    </tracks>
    <timeslot>
      <slot_id>3efcd037-01c8-4da0-b83d-86dfdc5464e0</slot_id>
      <title>A Framework for Computer-Aided Design of Educational Domain Models</title>
      <room>Omni Hotel | VMCAI</room>
      <date>2018/01/07</date>
      <start_time>11:00</start_time>
      <end_time>11:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Eric</first_name>
          <last_name>Butler</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Emina</first_name>
          <last_name>Torlak</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>Emina Torlak is an Assistant Professor at the University of Washington, working at the intersection of programming languages, formal methods, and software engineering. She received her Bachelors (2003), Masters (2004), and Ph.D. (2009) degrees from MIT, and subsequently worked at IBM Research, LogicBlox, and as a research scientist at U.C. Berkeley. Her research focuses on developing automated tools and programming models for computer-aided design, verification, and synthesis of software. She is the creator of the Kodkod constraint solver, which has been used in over 70 academic and industrial tools for software engineering. Emina has applied her expertise to a broad range of problems, from verification of memory-consistency models to generation of test data for decision support applications. Her current work on the Rosette solver-aided language integrates constraint solvers into programming languages to support computer-aided verification, debugging, and synthesis of code, making programming a collaboration between humans and machines.</bio>
          <homepage_url>https://homes.cs.washington.edu/~emina/index.html</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/eminatorlak/b48dd8a1-4bf6-4d29-b6e3-fb0e9ea9ce8e/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zoran</first_name>
          <last_name>Popovic</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>89804361-171d-448b-86f6-9ee4858c78ec</slot_id>
      <title>Generating Tests by Example</title>
      <room>Omni Hotel | VMCAI</room>
      <date>2018/01/07</date>
      <start_time>11:30</start_time>
      <end_time>12:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hila</first_name>
          <last_name>Peleg</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dan</first_name>
          <last_name>Rasin</last_name>
          <affiliation>Technion – Israel Institute of Technology</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Eran</first_name>
          <last_name>Yahav</last_name>
          <affiliation>Technion</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.technion.ac.il/~yahave/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/eranyahav/e77d8b4b-d267-4659-969c-6542a0d385b3/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b73241b8-7e4a-489a-8ca1-9b730d2f4627</slot_id>
      <title>Abstraction-Based Interaction Model for Synthesis</title>
      <room>Omni Hotel | VMCAI</room>
      <date>2018/01/07</date>
      <start_time>10:30</start_time>
      <end_time>11:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hila</first_name>
          <last_name>Peleg</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Shachar</first_name>
          <last_name>Itzhaky</last_name>
          <affiliation>Technion, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.technion.ac.il/~shachari</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/shacharitzhaky/649d5921-4057-4ac3-8fc7-75471ee8527b/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sharon</first_name>
          <last_name>Shoham</last_name>
          <affiliation>Tel Aviv university</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.tau.ac.il/~sharonshoham/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/sharonshoham/52ca243a-805e-43b9-9f5a-bd1bae25fccb/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9c4c3ff0-7914-40ca-8fac-0cb85fbacf52</subevent_id>
    <title>VMCAI 2018: Invited Talk by Ranjit Jhala</title>
    <subevent_type type="regular"/>
    <room>VMCAI</room>
    <date>2018/01/07</date>
    <url>https://popl18.sigplan.org/track/VMCAI-2018</url>
    <url_link_display>19th International Conference on Verification, Model Checking, and Abstract Interpretation</url_link_display>
    <tracks>
      <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
    </tracks>
    <timeslot>
      <slot_id>d223dad5-e4b2-4b54-8721-e56f3a7802e9</slot_id>
      <title>Reasoning about Functions</title>
      <room>Omni Hotel | VMCAI</room>
      <date>2018/01/07</date>
      <start_time>09:00</start_time>
      <end_time>10:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ranjit</first_name>
          <last_name>Jhala</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>Nom nom. Chomp. Burp.</bio>
          <homepage_url>http://ranjitjhala.github.io</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/ranjitjhala/afbdab69-ed23-4022-b7a4-2c57128f20ec/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>19th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4dde05d1-e81e-452f-9a37-aab624dd9a49</subevent_id>
    <title>TutorialFest: Code Obfuscation</title>
    <subevent_type type="regular"/>
    <room>Tutorial - A</room>
    <date>2018/01/08</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>23a152b2-8208-4cf5-adbd-c1b51ca5d62b</slot_id>
      <title>Code Obfuscation - A Hacking view on program analysis and understanding. </title>
      <room>Omni Hotel | Tutorial - A</room>
      <date>2018/01/08</date>
      <start_time>09:00</start_time>
      <end_time>10:30</end_time>
      <description>The tutorial is intended to present the most recent achievements in code protecting methods and technologies, ranging from code obfuscation to tamper proofing technique, in a programming languages way. The battle scenario involves attackers intended to extract information by reverse engineering the code, and protecting code transformations modelled as distorted compilers devoted to inhibit these attacks. Attacks are inhibited by maximising imprecision in all attempts made by the attacker to exploit control and data- flow of the obscured code. After a brief survey on the state of the art in the field, we introduce a model for code obfuscation which is general enough to include generic automated static and dynamic attacks. Protecting transformations are then systematically and formally derived as distorted compilers, obtained by specialising a suitably distorted interpreter for the given programming language with respect to the source code to protect. Interestingly this distortion corresponds precisely to defeat the potency of the expected attacker, which is itself an interpreter and whose potency consists in its ability to extract a complete and precise view of program’s execution.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Roberto</first_name>
          <last_name>Giacobazzi</last_name>
          <affiliation>University of Verona and IMDEA Software Institute</affiliation>
          <bio>Roberto Giacobazzi received the Laurea degree in Computer Science in 1988 from the University of Pisa, and in 1993 he received the Ph.D. in Computer Science from the same university, with a Ph.D. thesis on Semantic aspects of logic program analysis, under the supervision of Prof. Giorgio Levi. From 1993 to 1995 he had a Post Doctoral Research position at Laboratoire d’Informatique (LIX), Ecole Polytechnique (Paris) in the equipe Cousot. From 1995 to 1998 he was (tenured) Assistant Professor in Computer Science at the University of Pisa. From May 2000 until now he is Full Professor in Computer Science at the University of Verona. The research interests of Roberto Giacobazzi include abstract interpretation, static program analysis, semantics of programming languages, program verification, abstract model-checking, program transformation and optimization, digital asset protection, code obfuscation, malware detection, software watermarking and lattice theory. He has been Program Chair of SAS, VMCAI, of workshops in programming languages and language based security, and General Chair of ACM POPL2013. He is currently in the Steering committee of SAS and ACM POPL. From 2006 to 2012 he has been Dean of the College of Science of the University of Verona. He is now in his sabbatical year at IMDEA Software Institute.</bio>
          <homepage_url>http://profs.sci.univr.it/~giaco/index.html</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/robertogiacobazzi/3a292abe-6f69-4d5d-bfa3-305417b39cba/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>928bf42d-372c-4175-aef9-00f71ff4d4bc</subevent_id>
    <title>TutorialFest: Programming and Reasoning with Infinite Data in Isabelle/HOL</title>
    <subevent_type type="regular"/>
    <room>Tutorial - D</room>
    <date>2018/01/08</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>b8ced81f-de35-4b40-b66e-fde9db4ca020</slot_id>
      <title>Programming and Reasoning with Infinite Data in Isabelle/HOL.</title>
      <room>Omni Hotel | Tutorial - D</room>
      <date>2018/01/08</date>
      <start_time>11:00</start_time>
      <end_time>12:00</end_time>
      <description>Recently we have endowed the proof assistant Isabelle/HOL with a powerful framework for programming with, and reasoning about, infinite objects such as streams and infinite-depth trees. It implements the paradigm of total/productive coprogramming, and is based on a modular design of coinductive datatypes. The tutorial will present this framework through examples taken from the field of programming languages.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mathias</first_name>
          <last_name>Fleury</last_name>
          <affiliation>MPI-INF</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-inf.mpg.de/~mfleury</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/mathiasfleury/2a650d8c-0793-42e2-add2-8498088fe591/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andreas</first_name>
          <last_name>Lochbihler</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Andrei</first_name>
          <last_name>Popescu</last_name>
          <affiliation>Middlesex University, London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.andreipopescu.uk/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/andreipopescu/4c35986e-7c13-4d2c-9e25-4de4c785ba36/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>06a637c3-4a3c-4772-8f79-937072f9de3e</subevent_id>
    <title>TutorialFest: Equational reasoning for probabilistic programming</title>
    <subevent_type type="regular"/>
    <room>Tutorial - B</room>
    <date>2018/01/08</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>f37d4b69-3fd9-4c18-98c2-618e80364997</slot_id>
      <title>Equational reasoning for probabilistic programming.</title>
      <room>Omni Hotel | Tutorial - B</room>
      <date>2018/01/08</date>
      <start_time>09:00</start_time>
      <end_time>10:30</end_time>
      <description>Equations on programs are used to express domain knowledge, verify correctness, and improve performance, by people such as programmers and by tools such as compilers. It turns out that equations on probabilistic programs are a particularly good way to express Bayesian inference, verify distribution correctness, and improve sampler performance. In this way, this tutorial will introduce the mathematical reasoning principles that practitioners of probabilistic reasoning use to turn declarative models into efficient algorithms. These principles include integration and conjugacy, density and conditioning, and detailed balance.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Chung-chieh</first_name>
          <last_name>Shan</last_name>
          <affiliation>Indiana University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homes.soic.indiana.edu/ccshan/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/chungchiehshan/5f1d6cc2-6e76-484a-bafe-85460ba4c6e5/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ef787cd8-837b-4891-9e3e-c91a2eeb74ca</subevent_id>
    <title>TutorialFest: Iris - A Modular Foundation for Higher-Order Concurrent Separation Logic</title>
    <subevent_type type="regular"/>
    <room>Tutorial - C</room>
    <date>2018/01/08</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>fe615381-074e-47c1-aef2-0f9841857cc3</slot_id>
      <title>Iris - A Modular Foundation for Higher-Order Concurrent Separation Logic.</title>
      <room>Omni Hotel | Tutorial - C</room>
      <date>2018/01/08</date>
      <start_time>16:00</start_time>
      <end_time>17:00</end_time>
      <description>Iris is a framework for higher-order concurrent separation logic, which has been implemented in the Coq proof assistant and deployed very effectively in a wide variety of verification projects. These projects include but are not limited to: verification of fine-grained concurrent data structures, logical-relations for relational reasoning, program logics for relaxed memory models, program logics for object capabilities, and a safety proof for a realistic subset of the Rust programming language. In this tutorial, you will learn how use the Iris framework to reason about concurrent programs. This tutorial will be hands-on: we will use the Coq implementation of Iris to mechanize our proofs. It is recommended to come with Coq and Iris pre-installed on your machine so that you can play with Iris yourself.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jacques-Henri</first_name>
          <last_name>Jourdan</last_name>
          <affiliation>CNRS, LRI, Université Paris-Sud</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jhjourdan.mketjh.fr/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/jacqueshenrijourdan/4214e3a4-2811-4db8-8ecb-7d4aeb554543/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Robbert</first_name>
          <last_name>Krebbers</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://robbertkrebbers.nl</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7915ab27-dfcb-4a01-af89-e40e5864b57c</subevent_id>
    <title>TutorialFest: One Weird Trick: Relational Interpreters for Program Synthesis</title>
    <subevent_type type="regular"/>
    <room>Tutorial - D</room>
    <date>2018/01/08</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>c471ee99-4690-44e5-8e9e-0d4a63a020e4</slot_id>
      <title>One Weird Trick: Relational Interpreters for Program Synthesis.</title>
      <room>Omni Hotel | Tutorial - D</room>
      <date>2018/01/08</date>
      <start_time>14:00</start_time>
      <end_time>15:30</end_time>
      <description>In an ideal world we would directly express the operational semantics or type judgements of a programming language as a high-level executable semantics. We could then perform tasks like program synthesis or type inference/type inhabitation by writing queries with variables representing “holes” in a program or a type, and letting an advanced reasoning system efficiently fill in those holes. This is the promise and challenge of relational programming, a pure form of constraint logic programming. Over the past dozen years we and our colleagues have experimented with this approach, using the relational programming language miniKanren (http://minikanren.org/). In the past two years we have applied a variety of optimizations and heuristics to the relational interpreters we use to encode an operational semantics, speeding up some synthesis queries by 9 orders of magnitude. This speed up allows us to synthesize small but interesting higher-order and recursive Racket programs, as shown in our 2017 ICFP Pearl ‘A unified approach to solving seven programming problems’, Byrd, Ballantyne, Rosenblatt, Might.
In this tutorial we will show how we write and extend an interpreter for a Turing-complete subset of Racket as a relation in miniKanren, and then use this relational interpreter for program synthesis. Participants will follow along in the Racket version of miniKanren, and will write their own recursive miniKanren relations, including their own relational interpreter (and relational type inferencer, time allowing). We will also discuss the philosophy of relational programming, and describe open research problems in using relational interpreters for program synthesis. We assume participants have a basic knowledge of functional programming. Familiarity with writing simple interpreters will be helpful, but is not required. No knowledge of miniKanren, relational/logic programming, or program synthesis is assumed.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>William E.</first_name>
          <last_name>Byrd</last_name>
          <affiliation>University of Alabama at Birmingham, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://webyrd.net/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/williamebyrd/2a4d1ebd-5e55-4fdd-a807-8f7b593d0445/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>97d5e927-2918-4698-998a-9919ce48bc52</subevent_id>
    <title>TutorialFest: Equational reasoning for probabilistic programming</title>
    <subevent_type type="regular"/>
    <room>Tutorial - B</room>
    <date>2018/01/08</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>39d43b4c-5b5f-4ae4-ae3f-2174f9f0b8d2</slot_id>
      <title>Equational reasoning for probabilistic programming.</title>
      <room>Omni Hotel | Tutorial - B</room>
      <date>2018/01/08</date>
      <start_time>11:00</start_time>
      <end_time>12:00</end_time>
      <description>Equations on programs are used to express domain knowledge, verify correctness, and improve performance, by people such as programmers and by tools such as compilers. It turns out that equations on probabilistic programs are a particularly good way to express Bayesian inference, verify distribution correctness, and improve sampler performance. In this way, this tutorial will introduce the mathematical reasoning principles that practitioners of probabilistic reasoning use to turn declarative models into efficient algorithms. These principles include integration and conjugacy, density and conditioning, and detailed balance.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Chung-chieh</first_name>
          <last_name>Shan</last_name>
          <affiliation>Indiana University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homes.soic.indiana.edu/ccshan/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/chungchiehshan/5f1d6cc2-6e76-484a-bafe-85460ba4c6e5/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>873a1936-c3c3-4002-b807-4c42b32e8fb7</subevent_id>
    <title>TutorialFest: Message-Passing Concurrency and Substructural Logics</title>
    <subevent_type type="regular"/>
    <room>Tutorial - C</room>
    <date>2018/01/08</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>af0047be-93e2-49f2-9773-bf3a15c601d0</slot_id>
      <title>Message-Passing Concurrency and Substructural Logics</title>
      <room>Omni Hotel | Tutorial - C</room>
      <date>2018/01/08</date>
      <start_time>11:00</start_time>
      <end_time>12:00</end_time>
      <description>Functional programming has been revolutionized by our understanding of its connection to intuitionistic logic and type theory. In this tutorial we report on the progress of a long-term effort to provide a similar logical underpinning for message-passing concurrent programming. We show how substructural logics give rise to session types characterizing communication, and how substructural proofs can be interpreted as processes. Program examples will focus on recent progress on incorporating sharing of resources, such as shared queues, the classic dining philosophers problem, and a representation of the untyped asynchronous pi-calculus.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Frank</first_name>
          <last_name>Pfenning</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>Frank Pfenning is Joseph F. Traub Professor and Head of the Computer Science Department at Carnegie Mellon University. He obtained his PhD in Mathematics at Carnegie Mellon University in 1987. He served as trustee and president of CADE, chaired several conferences and program committees including FoSSaCS 2013, LICS 2008, CADE 2007, and RTA 2006, and served on the editorial board of TCS, JAR, and JSC, and was named Fellow of the ACM in 2015. His current research interests include expressive type systems for functional, concurrent, and logic programming languages, computer security, logical frameworks, and automated deduction.</bio>
          <homepage_url>https://www.cs.cmu.edu/~fp/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/frankpfenning/407fbe95-d5ea-4319-97a2-57fe882ade13/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1b452abb-a525-4254-a65d-1887476a1825</subevent_id>
    <title>TutorialFest: Iris - A Modular Foundation for Higher-Order Concurrent Separation Logic</title>
    <subevent_type type="regular"/>
    <room>Tutorial - C</room>
    <date>2018/01/08</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>2bb9975f-6f89-49ac-82c0-9e0b54532fe8</slot_id>
      <title>Iris - A Modular Foundation for Higher-Order Concurrent Separation Logic.</title>
      <room>Omni Hotel | Tutorial - C</room>
      <date>2018/01/08</date>
      <start_time>14:00</start_time>
      <end_time>15:30</end_time>
      <description>Iris is a framework for higher-order concurrent separation logic, which has been implemented in the Coq proof assistant and deployed very effectively in a wide variety of verification projects. These projects include but are not limited to: verification of fine-grained concurrent data structures, logical-relations for relational reasoning, program logics for relaxed memory models, program logics for object capabilities, and a safety proof for a realistic subset of the Rust programming language. In this tutorial, you will learn how use the Iris framework to reason about concurrent programs. This tutorial will be hands-on: we will use the Coq implementation of Iris to mechanize our proofs. It is recommended to come with Coq and Iris pre-installed on your machine so that you can play with Iris yourself.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jacques-Henri</first_name>
          <last_name>Jourdan</last_name>
          <affiliation>CNRS, LRI, Université Paris-Sud</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jhjourdan.mketjh.fr/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/jacqueshenrijourdan/4214e3a4-2811-4db8-8ecb-7d4aeb554543/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Robbert</first_name>
          <last_name>Krebbers</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://robbertkrebbers.nl</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>785ab8a5-93c1-4b3e-bcd8-e3cd56d4a71d</subevent_id>
    <title>TutorialFest: Message-Passing Concurrency and Substructural Logics</title>
    <subevent_type type="regular"/>
    <room>Tutorial - C</room>
    <date>2018/01/08</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>d718c8b3-c208-4840-a92d-9e4e0764f6b5</slot_id>
      <title>Message-Passing Concurrency and Substructural Logics</title>
      <room>Omni Hotel | Tutorial - C</room>
      <date>2018/01/08</date>
      <start_time>09:00</start_time>
      <end_time>10:30</end_time>
      <description>Functional programming has been revolutionized by our understanding of its connection to intuitionistic logic and type theory. In this tutorial we report on the progress of a long-term effort to provide a similar logical underpinning for message-passing concurrent programming. We show how substructural logics give rise to session types characterizing communication, and how substructural proofs can be interpreted as processes. Program examples will focus on recent progress on incorporating sharing of resources, such as shared queues, the classic dining philosophers problem, and a representation of the untyped asynchronous pi-calculus.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Frank</first_name>
          <last_name>Pfenning</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>Frank Pfenning is Joseph F. Traub Professor and Head of the Computer Science Department at Carnegie Mellon University. He obtained his PhD in Mathematics at Carnegie Mellon University in 1987. He served as trustee and president of CADE, chaired several conferences and program committees including FoSSaCS 2013, LICS 2008, CADE 2007, and RTA 2006, and served on the editorial board of TCS, JAR, and JSC, and was named Fellow of the ACM in 2015. His current research interests include expressive type systems for functional, concurrent, and logic programming languages, computer security, logical frameworks, and automated deduction.</bio>
          <homepage_url>https://www.cs.cmu.edu/~fp/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/frankpfenning/407fbe95-d5ea-4319-97a2-57fe882ade13/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e5eee2dc-1c0c-41ba-9da0-76f93b133a88</subevent_id>
    <title>TutorialFest: Introduction to Algebraic Program analysis</title>
    <subevent_type type="regular"/>
    <room>Tutorial - B</room>
    <date>2018/01/08</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>7e1704a3-ffad-47b8-bcb3-3f2d120b38b4</slot_id>
      <title>Introduction to Algebraic Program analysis.</title>
      <room>Omni Hotel | Tutorial - B</room>
      <date>2018/01/08</date>
      <start_time>16:00</start_time>
      <end_time>17:00</end_time>
      <description>The purpose of program analysis is to over-approximate the run-time behavior of programs. The classical method for analyzing programs is iterative program analysis, in which one begins with some property that over-approximates (just) the initial states of the program, and repeatedly transforms the property until converging upon a property that over-approximates all of the reachable states of the program. An alternative to iterative program analysis is algebraic program analysis, in which the space of program properties forms an algebraic structure, and one computes a property that over-approximates the executions of a program by breaking it into smaller parts, analyzing each part, and then using the operations of the algebraic structure to combine the results into a property that over-approximates the execution of the whole program. The purpose of this tutorial is to provide an introduction to algebraic program analysis, and teach participants how to design program analyses in the algebraic style. The first part of the tutorial will introduce the algebraic framework, following Tarjan’s path-expression method for intraprocedural analysis. We will motivate algebraic program analysis with compositional recurrence analysis, which computes numerical loop invariants over an expressive abstract domain without requiring a widening operator. The second part of the tutorial will cover recent work on interprocedural algebraic program analysis. We will focus on a family of techniques that take inspiration from Newton’s method for finding roots of real-valued functions to compute solutions to interprocedural program-analysis problems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Zachary</first_name>
          <last_name>Kincaid</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.princeton.edu/~zkincaid</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/zacharykincaid/a26b486e-94a5-45f1-a8b3-9a2221495ff7/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Reps</last_name>
          <affiliation>University of Wisconsin - Madison and GrammaTech, Inc.</affiliation>
          <bio>Thomas W. Reps is the J. Barkley Rosser Professor &amp;amp; Rajiv and Ritu Batra Chair in the Computer Sciences Department of the University of Wisconsin, which he joined in 1985. Reps is the author or co-author of four books and more than one hundred seventy-five papers describing his research (see http://pages.cs.wisc.edu/~reps/). His work has concerned a wide variety of topics, including program slicing, dataflow analysis, pointer analysis, model checking, computer security, code instrumentation, language-based program-development environments, the use of program profiling in software testing, software renovation, incremental algorithms, and attribute grammars.
His collaboration with Professor Tim Teitelbaum at Cornell University from 1978 to 1985 led to the creation of two systems—the Cornell Program Synthesizer and the Synthesizer Generator—that explored how to build interactive programming tools that incorporate knowledge about the programming language being supported. The systems that they created were similar to modern program-development environments, such as Microsoft Visual Studio and Eclipse, but pre-dated them by more than two decades. Reps is President of GrammaTech, Inc., which he and Teitelbaum founded in 1988 to commercialize this work.
At Wisconsin, Professor Reps and collaborator Professor Susan Horwitz carried out many investigations of program slicing and its applications in software engineering. Reps’s most recent work concerns program analysis, computer security, and software model checking.
In 1996, Reps served as a consultant to DARPA to help them plan a project aimed at reducing the impact of the Year 2000 Problem on the U.S. Department of Defense. In 2003, he served on the F/A-22 Avionics Advisory Team, which provided advice to the U.S. Department of Defense about problems uncovered during integration testing of the plane’s avionics software.
Professor Reps received his Ph.D. in Computer Science from Cornell University in 1982. His Ph.D. dissertation won the 1983 ACM Doctoral Dissertation Award.
Reps’s 1988 paper on interprocedural slicing, with Susan Horwitz and his then-student David Binkley, was selected as one of the 50 most influential papers from the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), 1979-99. According to Google Scholar, the 1988 paper and the subsequent journal version have received over 1,780 citations.
His 2004 paper about analysis of assembly code, with his student Gogul Balakrishnan, received the ETAPS Best-Paper Award for 2004 from the European Association for Programming Languages and Systems (EAPLS). His 2008 paper about a system for generating static analyzers for machine instructions, with his student Junghee Lim, received the ETAPS Best-Paper Award for 2008 from EAPLS. In 2010, his 1984 paper “The Synthesizer Generator,” with Tim Teitelbaum, received an ACM SIGSOFT Retrospective Impact Paper Award. In 2011, his 1994 paper “Speeding up slicing,” with Susan Horwitz, Mooly Sagiv, and Genevieve Rosay, also received an ACM SIGSOFT Retrospective Impact Paper Award.
Four of his students, Gogul Balakrishnan, Akash Lal, Junghee Lim, and Aditya Thakur, have been recipients of the Outstanding Graduate Student Research Award given by the University of Wisconsin Computer Sciences Department. Akash Lal was also a co-recipient of the 2009 SIGPLAN Outstanding Doctoral Dissertation Award, and he was named as one of the 18 awardees selected for the 2011 India TR-35 list (top innovators under 35).
Reps has also been the recipient of an NSF Presidential Young Investigator Award (1986), a Packard Fellowship (1988), a Humboldt Research Award (2000), and a Guggenheim Fellowship (2000). He is also an ACM Fellow (2005). In 2013, Reps was elected a foreign member of Academia Europaea.
Reps has held visiting positions at the Institut National de Recherche en Informatique et en Automatique (INRIA) in Rocquencourt, France (1982-83), the University of Copenhagen, Denmark (1993-94), the Consiglio Nazionale delle Ricerche in Pisa, Italy (2000-2001), and the University Paris Diderot—Paris 7 (2007-2008).</bio>
          <homepage_url>http://pages.cs.wisc.edu/~reps/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/thomasreps/bc5323a6-d318-42c9-a136-d3252ecda280/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e953c54b-d4cd-4673-8ae4-164ad8920ac7</subevent_id>
    <title>TutorialFest: One Weird Trick: Relational Interpreters for Program Synthesis</title>
    <subevent_type type="regular"/>
    <room>Tutorial - D</room>
    <date>2018/01/08</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>3b94ce8a-be6d-4859-b768-1359d92b5fa3</slot_id>
      <title>One Weird Trick: Relational Interpreters for Program Synthesis.</title>
      <room>Omni Hotel | Tutorial - D</room>
      <date>2018/01/08</date>
      <start_time>16:00</start_time>
      <end_time>17:00</end_time>
      <description>In an ideal world we would directly express the operational semantics or type judgements of a programming language as a high-level executable semantics. We could then perform tasks like program synthesis or type inference/type inhabitation by writing queries with variables representing “holes” in a program or a type, and letting an advanced reasoning system efficiently fill in those holes. This is the promise and challenge of relational programming, a pure form of constraint logic programming. Over the past dozen years we and our colleagues have experimented with this approach, using the relational programming language miniKanren (http://minikanren.org/). In the past two years we have applied a variety of optimizations and heuristics to the relational interpreters we use to encode an operational semantics, speeding up some synthesis queries by 9 orders of magnitude. This speed up allows us to synthesize small but interesting higher-order and recursive Racket programs, as shown in our 2017 ICFP Pearl ‘A unified approach to solving seven programming problems’, Byrd, Ballantyne, Rosenblatt, Might.
In this tutorial we will show how we write and extend an interpreter for a Turing-complete subset of Racket as a relation in miniKanren, and then use this relational interpreter for program synthesis. Participants will follow along in the Racket version of miniKanren, and will write their own recursive miniKanren relations, including their own relational interpreter (and relational type inferencer, time allowing). We will also discuss the philosophy of relational programming, and describe open research problems in using relational interpreters for program synthesis. We assume participants have a basic knowledge of functional programming. Familiarity with writing simple interpreters will be helpful, but is not required. No knowledge of miniKanren, relational/logic programming, or program synthesis is assumed.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>William E.</first_name>
          <last_name>Byrd</last_name>
          <affiliation>University of Alabama at Birmingham, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://webyrd.net/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/williamebyrd/2a4d1ebd-5e55-4fdd-a807-8f7b593d0445/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f8b22059-7b7e-4bb5-ac9d-2ba947474636</subevent_id>
    <title>TutorialFest: Computational Higher Type Theory</title>
    <subevent_type type="regular"/>
    <room>Tutorial - A</room>
    <date>2018/01/08</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>cf45b390-f8ae-41d3-a344-58642481b01d</slot_id>
      <title>Computational Higher Type Theory</title>
      <room>Omni Hotel | Tutorial - A</room>
      <date>2018/01/08</date>
      <start_time>16:00</start_time>
      <end_time>17:00</end_time>
      <description>Computational type theory is a semantic formulation of dependent type theory that starts with a programming language equipped with a deterministic operational semantics and derives types as specifications of program behavior. Thus, a type is a program specification, two types are exactly equal only if they specify the same behavior, and a program inhabits a type if it behaves according to specification, and two programs are exactly equal as elements of a type when they exhibit the same specified behavior. The range of possible programs is open-ended in that no specification precludes the existence of any program, and the forms of type that may be considered are unlimited, the presence of one type never interfering with another. Among the types are those arising from logic, including the usual connectives and quantifiers. From the logical perspective computational type theory is a theory of truth, not a theory of formal proof, thereby providing a direct realization of Brouwer’s program of intuitionistic foundations for mathematics. The role of formalisms is strictly secondary, and never imposes definitional limits on the theory. Whereas computational type theory is consistent with the familiar constructs of formal type theory, it is both possible and advantageous to consider proof theories, such as refinement logics, that lie outside the scope of formal type theory. As mentioned, computational type theory has its roots in Brouwer’s program of intuitionistic mathematics in which the truth of a proposition is identified with the existence of a construction (program) that obeys the proposition as a specification. This perspective was developed by Martin-Loef in his paper “Constructive Mathematics and Computer Programming”, and was developed more fully by Constable and his co-workers in the NuPRL type theory and proof assistant. More recently, computational type theory has been extended by the authors to account for higher-dimensional phenomena (as suggested by Hofmann, Streicher, Moerdijk, Berg, Warren, Awodey, and Voevodsky), such as the identification of equivalent types, or the formation of abstract higher-dimensional objects in type theory.
The purpose of this tutorial is to present the semantics of computational higher type theory, and to relate the semantics to its implementation in the RedPRL proof development system.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Robert</first_name>
          <last_name>Harper</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Robert Harper is a professor of Computer Science at Carnegie Mellon University, where he has been on faculty since 1988. He is author of the textbook Practical Foundations for Programming Languages (Cambridge, 2016).</bio>
          <homepage_url>http://www.cs.cmu.edu/~rwh/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/robertharper1/90009a36-154c-45b8-849c-92552d8837bf/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Carlo</first_name>
          <last_name>Angiuli</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a575d424-b228-4f8c-be1d-b25070ec6b1f</subevent_id>
    <title>TutorialFest: Computational Higher Type Theory</title>
    <subevent_type type="regular"/>
    <room>Tutorial - A</room>
    <date>2018/01/08</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>14a29762-95fb-4be6-bb8b-217ad3281b93</slot_id>
      <title>Computational Higher Type Theory</title>
      <room>Omni Hotel | Tutorial - A</room>
      <date>2018/01/08</date>
      <start_time>14:00</start_time>
      <end_time>15:30</end_time>
      <description>Computational type theory is a semantic formulation of dependent type theory that starts with a programming language equipped with a deterministic operational semantics and derives types as specifications of program behavior. Thus, a type is a program specification, two types are exactly equal only if they specify the same behavior, and a program inhabits a type if it behaves according to specification, and two programs are exactly equal as elements of a type when they exhibit the same specified behavior. The range of possible programs is open-ended in that no specification precludes the existence of any program, and the forms of type that may be considered are unlimited, the presence of one type never interfering with another. Among the types are those arising from logic, including the usual connectives and quantifiers. From the logical perspective computational type theory is a theory of truth, not a theory of formal proof, thereby providing a direct realization of Brouwer’s program of intuitionistic foundations for mathematics. The role of formalisms is strictly secondary, and never imposes definitional limits on the theory. Whereas computational type theory is consistent with the familiar constructs of formal type theory, it is both possible and advantageous to consider proof theories, such as refinement logics, that lie outside the scope of formal type theory. As mentioned, computational type theory has its roots in Brouwer’s program of intuitionistic mathematics in which the truth of a proposition is identified with the existence of a construction (program) that obeys the proposition as a specification. This perspective was developed by Martin-Loef in his paper “Constructive Mathematics and Computer Programming”, and was developed more fully by Constable and his co-workers in the NuPRL type theory and proof assistant. More recently, computational type theory has been extended by the authors to account for higher-dimensional phenomena (as suggested by Hofmann, Streicher, Moerdijk, Berg, Warren, Awodey, and Voevodsky), such as the identification of equivalent types, or the formation of abstract higher-dimensional objects in type theory.
The purpose of this tutorial is to present the semantics of computational higher type theory, and to relate the semantics to its implementation in the RedPRL proof development system.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Robert</first_name>
          <last_name>Harper</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>Robert Harper is a professor of Computer Science at Carnegie Mellon University, where he has been on faculty since 1988. He is author of the textbook Practical Foundations for Programming Languages (Cambridge, 2016).</bio>
          <homepage_url>http://www.cs.cmu.edu/~rwh/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/robertharper1/90009a36-154c-45b8-849c-92552d8837bf/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Carlo</first_name>
          <last_name>Angiuli</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>818870a7-77a5-48f5-9e28-bd27af38671c</subevent_id>
    <title>TutorialFest: Code Obfuscation</title>
    <subevent_type type="regular"/>
    <room>Tutorial - A</room>
    <date>2018/01/08</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>76ff2573-a89c-4aaa-bd67-2032dd6c1875</slot_id>
      <title>Code Obfuscation - A Hacking view on program analysis and understanding. </title>
      <room>Omni Hotel | Tutorial - A</room>
      <date>2018/01/08</date>
      <start_time>11:00</start_time>
      <end_time>12:00</end_time>
      <description>The tutorial is intended to present the most recent achievements in code protecting methods and technologies, ranging from code obfuscation to tamper proofing technique, in a programming languages way. The battle scenario involves attackers intended to extract information by reverse engineering the code, and protecting code transformations modelled as distorted compilers devoted to inhibit these attacks. Attacks are inhibited by maximising imprecision in all attempts made by the attacker to exploit control and data- flow of the obscured code. After a brief survey on the state of the art in the field, we introduce a model for code obfuscation which is general enough to include generic automated static and dynamic attacks. Protecting transformations are then systematically and formally derived as distorted compilers, obtained by specialising a suitably distorted interpreter for the given programming language with respect to the source code to protect. Interestingly this distortion corresponds precisely to defeat the potency of the expected attacker, which is itself an interpreter and whose potency consists in its ability to extract a complete and precise view of program’s execution.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Roberto</first_name>
          <last_name>Giacobazzi</last_name>
          <affiliation>University of Verona and IMDEA Software Institute</affiliation>
          <bio>Roberto Giacobazzi received the Laurea degree in Computer Science in 1988 from the University of Pisa, and in 1993 he received the Ph.D. in Computer Science from the same university, with a Ph.D. thesis on Semantic aspects of logic program analysis, under the supervision of Prof. Giorgio Levi. From 1993 to 1995 he had a Post Doctoral Research position at Laboratoire d’Informatique (LIX), Ecole Polytechnique (Paris) in the equipe Cousot. From 1995 to 1998 he was (tenured) Assistant Professor in Computer Science at the University of Pisa. From May 2000 until now he is Full Professor in Computer Science at the University of Verona. The research interests of Roberto Giacobazzi include abstract interpretation, static program analysis, semantics of programming languages, program verification, abstract model-checking, program transformation and optimization, digital asset protection, code obfuscation, malware detection, software watermarking and lattice theory. He has been Program Chair of SAS, VMCAI, of workshops in programming languages and language based security, and General Chair of ACM POPL2013. He is currently in the Steering committee of SAS and ACM POPL. From 2006 to 2012 he has been Dean of the College of Science of the University of Verona. He is now in his sabbatical year at IMDEA Software Institute.</bio>
          <homepage_url>http://profs.sci.univr.it/~giaco/index.html</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/robertogiacobazzi/3a292abe-6f69-4d5d-bfa3-305417b39cba/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>533837e2-5862-4aea-a1d2-5493a84e0333</subevent_id>
    <title>TutorialFest: Programming and Reasoning with Infinite Data in Isabelle/HOL</title>
    <subevent_type type="regular"/>
    <room>Tutorial - D</room>
    <date>2018/01/08</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>53a4fb1c-8933-4c29-bcdf-e9783bd5dc90</slot_id>
      <title>Programming and Reasoning with Infinite Data in Isabelle/HOL.</title>
      <room>Omni Hotel | Tutorial - D</room>
      <date>2018/01/08</date>
      <start_time>09:00</start_time>
      <end_time>10:30</end_time>
      <description>Recently we have endowed the proof assistant Isabelle/HOL with a powerful framework for programming with, and reasoning about, infinite objects such as streams and infinite-depth trees. It implements the paradigm of total/productive coprogramming, and is based on a modular design of coinductive datatypes. The tutorial will present this framework through examples taken from the field of programming languages.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mathias</first_name>
          <last_name>Fleury</last_name>
          <affiliation>MPI-INF</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-inf.mpg.de/~mfleury</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/mathiasfleury/2a650d8c-0793-42e2-add2-8498088fe591/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andreas</first_name>
          <last_name>Lochbihler</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Andrei</first_name>
          <last_name>Popescu</last_name>
          <affiliation>Middlesex University, London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.andreipopescu.uk/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/andreipopescu/4c35986e-7c13-4d2c-9e25-4de4c785ba36/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>25798315-06f4-4dcb-9c9e-4652efe0e55c</subevent_id>
    <title>TutorialFest: Introduction to Algebraic Program analysis</title>
    <subevent_type type="regular"/>
    <room>Tutorial - B</room>
    <date>2018/01/08</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>91f7611e-d802-463f-9680-498ed14f88d5</slot_id>
      <title>Introduction to Algebraic Program analysis.</title>
      <room>Omni Hotel | Tutorial - B</room>
      <date>2018/01/08</date>
      <start_time>14:00</start_time>
      <end_time>15:30</end_time>
      <description>The purpose of program analysis is to over-approximate the run-time behavior of programs. The classical method for analyzing programs is iterative program analysis, in which one begins with some property that over-approximates (just) the initial states of the program, and repeatedly transforms the property until converging upon a property that over-approximates all of the reachable states of the program. An alternative to iterative program analysis is algebraic program analysis, in which the space of program properties forms an algebraic structure, and one computes a property that over-approximates the executions of a program by breaking it into smaller parts, analyzing each part, and then using the operations of the algebraic structure to combine the results into a property that over-approximates the execution of the whole program. The purpose of this tutorial is to provide an introduction to algebraic program analysis, and teach participants how to design program analyses in the algebraic style. The first part of the tutorial will introduce the algebraic framework, following Tarjan’s path-expression method for intraprocedural analysis. We will motivate algebraic program analysis with compositional recurrence analysis, which computes numerical loop invariants over an expressive abstract domain without requiring a widening operator. The second part of the tutorial will cover recent work on interprocedural algebraic program analysis. We will focus on a family of techniques that take inspiration from Newton’s method for finding roots of real-valued functions to compute solutions to interprocedural program-analysis problems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Zachary</first_name>
          <last_name>Kincaid</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.princeton.edu/~zkincaid</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/zacharykincaid/a26b486e-94a5-45f1-a8b3-9a2221495ff7/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Reps</last_name>
          <affiliation>University of Wisconsin - Madison and GrammaTech, Inc.</affiliation>
          <bio>Thomas W. Reps is the J. Barkley Rosser Professor &amp;amp; Rajiv and Ritu Batra Chair in the Computer Sciences Department of the University of Wisconsin, which he joined in 1985. Reps is the author or co-author of four books and more than one hundred seventy-five papers describing his research (see http://pages.cs.wisc.edu/~reps/). His work has concerned a wide variety of topics, including program slicing, dataflow analysis, pointer analysis, model checking, computer security, code instrumentation, language-based program-development environments, the use of program profiling in software testing, software renovation, incremental algorithms, and attribute grammars.
His collaboration with Professor Tim Teitelbaum at Cornell University from 1978 to 1985 led to the creation of two systems—the Cornell Program Synthesizer and the Synthesizer Generator—that explored how to build interactive programming tools that incorporate knowledge about the programming language being supported. The systems that they created were similar to modern program-development environments, such as Microsoft Visual Studio and Eclipse, but pre-dated them by more than two decades. Reps is President of GrammaTech, Inc., which he and Teitelbaum founded in 1988 to commercialize this work.
At Wisconsin, Professor Reps and collaborator Professor Susan Horwitz carried out many investigations of program slicing and its applications in software engineering. Reps’s most recent work concerns program analysis, computer security, and software model checking.
In 1996, Reps served as a consultant to DARPA to help them plan a project aimed at reducing the impact of the Year 2000 Problem on the U.S. Department of Defense. In 2003, he served on the F/A-22 Avionics Advisory Team, which provided advice to the U.S. Department of Defense about problems uncovered during integration testing of the plane’s avionics software.
Professor Reps received his Ph.D. in Computer Science from Cornell University in 1982. His Ph.D. dissertation won the 1983 ACM Doctoral Dissertation Award.
Reps’s 1988 paper on interprocedural slicing, with Susan Horwitz and his then-student David Binkley, was selected as one of the 50 most influential papers from the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), 1979-99. According to Google Scholar, the 1988 paper and the subsequent journal version have received over 1,780 citations.
His 2004 paper about analysis of assembly code, with his student Gogul Balakrishnan, received the ETAPS Best-Paper Award for 2004 from the European Association for Programming Languages and Systems (EAPLS). His 2008 paper about a system for generating static analyzers for machine instructions, with his student Junghee Lim, received the ETAPS Best-Paper Award for 2008 from EAPLS. In 2010, his 1984 paper “The Synthesizer Generator,” with Tim Teitelbaum, received an ACM SIGSOFT Retrospective Impact Paper Award. In 2011, his 1994 paper “Speeding up slicing,” with Susan Horwitz, Mooly Sagiv, and Genevieve Rosay, also received an ACM SIGSOFT Retrospective Impact Paper Award.
Four of his students, Gogul Balakrishnan, Akash Lal, Junghee Lim, and Aditya Thakur, have been recipients of the Outstanding Graduate Student Research Award given by the University of Wisconsin Computer Sciences Department. Akash Lal was also a co-recipient of the 2009 SIGPLAN Outstanding Doctoral Dissertation Award, and he was named as one of the 18 awardees selected for the 2011 India TR-35 list (top innovators under 35).
Reps has also been the recipient of an NSF Presidential Young Investigator Award (1986), a Packard Fellowship (1988), a Humboldt Research Award (2000), and a Guggenheim Fellowship (2000). He is also an ACM Fellow (2005). In 2013, Reps was elected a foreign member of Academia Europaea.
Reps has held visiting positions at the Institut National de Recherche en Informatique et en Automatique (INRIA) in Rocquencourt, France (1982-83), the University of Copenhagen, Denmark (1993-94), the Consiglio Nazionale delle Ricerche in Pisa, Italy (2000-2001), and the University Paris Diderot—Paris 7 (2007-2008).</bio>
          <homepage_url>http://pages.cs.wisc.edu/~reps/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/thomasreps/bc5323a6-d318-42c9-a136-d3252ecda280/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8dbb26df-9282-4529-961b-6c69d76de9c1</subevent_id>
    <title>Research Papers: Types</title>
    <subevent_type type="regular"/>
    <room>POPL-Track-2</room>
    <date>2018/01/10</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>2e8246e5-4bea-4931-8883-0364d666a61d</slot_id>
      <title>Univalent Higher Categories via Complete Semi-Segal Types</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/10</date>
      <start_time>17:05</start_time>
      <end_time>17:30</end_time>
      <description>Category theory in homotopy type theory is intricate as categorical laws can only be stated “up to homotopy”, and thus require coherences. The established notion of a univalent category (Ahrens et al. 2015) solves this by considering only truncated types, and it roughly corresponds to an ordinary category. The drawback is that univalent categories fail to capture many naturally occurring structures, such as type universes or the type of univalent categories themselves. This stems from the fact that the natural notion of a category in homotopy type theory is not that of an ordinary, but rather a higher category.
Out of the large variety of approaches to higher category theory that mathematicians have proposed, we believe that, for type theory, the simplicial strategy is best suited. Given the first (n+3) levels of a semisimplicial type S, we can equip S with three properties: first, contractibility of the types of certain horn fillers; second, a completeness property; and third, a truncation condition. We call this a complete semi-Segal n-type.
The definition of a univalent (1-) category by (Ahrens et al. 2015) can easily be extended or restricted to the definition of a univalent n-category (more precisely, (n,1)-category) for $n \in {0,1,2}$, and we show that the type of complete semi-Segal n-types is equivalent to the type of univalent n-categories in these cases. Thus, we believe that the notion of a complete semi-Segal n-type can be taken as the definition of a univalent n-category.
We develop most of the material of the paper without assuming truncatedness conditions. While this makes some of the intermediate categorical notions not completely well-behaved, or “wild”, it has the advantage of making our constructions more modular, since every new level of wild structure can be built on top of the previous levels.
The paper comes with an electronic appendix containing a formalisation in the proof assistant Agda using a completely explicit representation of semi-simplicial types for levels up to 4.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Paolo</first_name>
          <last_name>Capriotti</last_name>
          <affiliation>University of Nottingham</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nicolai</first_name>
          <last_name>Kraus</last_name>
          <affiliation>University of Nottingham</affiliation>
          <bio>Currently postdoc at the University of Nottingham.</bio>
          <homepage_url>http://www.cs.nott.ac.uk/~psznk/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/nicolaikraus/1e6ad344-d5db-4f04-b56b-60bd567678b3/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a265876a-110a-4845-9938-e2426cdcab90</slot_id>
      <title>A Principled approach to Ornamentation in ML</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/10</date>
      <start_time>15:50</start_time>
      <end_time>16:15</end_time>
      <description>Ornaments are a way to describe changes in datatype definitions reorganizing, adding, or dropping some pieces of data so that functions operating on the bare definition can be partially and sometimes totally lifted into functions operating on the ornamented structure. We propose an extension of ML with higher-order ornaments, demonstrate its expressiveness with a few typical examples, study the metatheoretical properties of ornaments, and describe their elaboration process. We formalize ornamentation via an a posteriori abstraction of the bare code, called a generic lifting, which lives a meta-language above ML. The lifted code is obtained by application of the generic lifting to well-chosen arguments, followed by staged reduction, and some remaining simplifications. We use logical relations to closely relate the ornamented code to the bare code.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Williams</last_name>
          <affiliation>Inria</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Didier</first_name>
          <last_name>Rémy</last_name>
          <affiliation>Inria</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c1fba444-d62b-4958-b90e-5bbc0b0278be</slot_id>
      <title>Type-Preserving CPS Translation of Σ and Π Types is Not Not Possible</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/10</date>
      <start_time>16:15</start_time>
      <end_time>16:40</end_time>
      <description>Dependently typed languages such as Coq are used to specify and prove functional correctness of source programs, but what we ultimately need are guarantees about correctness of compiled code. By preserving dependent types through each compiler pass, we could preserve source-level specifications and correctness proofs into the generated target-language programs. Unfortunately, type-preserving compilation of dependent types is hard. In 2002, Barthe and Uustalu showed that type-preserving CPS is \emph{not possible} for languages such as Coq. Specifically, they showed that for strong dependent pairs ($\Sigma$ types), the standard typed call-by-name CPS is \emph{not type preserving}. They further proved that for dependent case analysis on sums, a class of typed CPS translations—including the standard translation—is \emph{not possible}. In 2016, Morrisett noticed a similar problem with the standard call-by-value CPS translation for dependent functions ($\Pi$ types). In essence, the problem is that the standard typed CPS translation by double-negation, in which computations are assigned types of the form $(A \rightarrow \bot) \rightarrow \bot$, disrupts the term/type equivalence that is used during type checking in a dependently typed language.
In this paper, we prove that type-preserving CPS translation for dependently typed languages is \emph{not} not possible. We develop both call-by-name and call-by-value CPS translations from the Calculus of Constructions with both $\Pi$ and $\Sigma$ types (CC) to a dependently typed target language, and prove type preservation and compiler correctness of each translation. Our target language is CC extended with an additional equivalence rule and an additional typing rule, which we prove consistent by giving a model in the extensional Calculus of Constructions. Our key observation is that we can use a CPS translation that employs \emph{answer-type polymorphism}, where CPS-translated computations have type $\forall \alpha. (A \rightarrow \alpha) \rightarrow \alpha$. This type justifies, by a \emph{free theorem}, the new equality rule in our target language and allows us to recover the term/type equivalences that CPS translation disrupts. Finally, we conjecture that our translation extends to dependent case analysis on sums, despite the impossibility result, and provide a proof sketch.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>William J.</first_name>
          <last_name>Bowman</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>I am a sixth year Ph.D. student at Northeastern University where I study Computer Science (specifically, programming languages).
I want to make programs easier to design, write, and understand. To that end, I work on verifying compilers. I am particularly interested in equivalence preserving (fully-abstract) compilers and type preserving compilation. I also dabble in dependent types and language design and implementation.</bio>
          <homepage_url>https://www.williamjbowman.com/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/williamjbowman/65b17dd6-298e-44ef-b32a-dc068c8c668b/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Youyou</first_name>
          <last_name>Cong</last_name>
          <affiliation>Ochanomizu University, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://sites.google.com/site/youyoucong212/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/youyoucong/55f54fd9-cac5-44ae-93c1-921409269efc/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nick</first_name>
          <last_name>Rioux</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl18.sigplan.org/getProfileImage/nickrioux/0c477e2a-a895-4459-aa6c-bdf45bc36f7b/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Amal</first_name>
          <last_name>Ahmed</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ccs.neu.edu/home/amal/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/amalahmed/301fd92b-d4ae-4998-8f6b-82cf081da653/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e0ddc84d-91b7-4f23-9310-47e908d53da9</slot_id>
      <title>Safety and Conservativity of Definitions in HOL and Isabelle/HOL</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/10</date>
      <start_time>16:40</start_time>
      <end_time>17:05</end_time>
      <description>Definitions are traditionally considered to be a safe mechanism for introducing concepts on top of a logic known to be consistent. In contrast to arbitrary axioms, definitions should in principle be treatable as a form of abbreviation, and thus compiled away from the theory without losing provability. In particular, definitions should form a conservative extension of the pure logic. These properties are crucial for modern interactive theorem provers, as they ensure the consistency of the logic and a suitable environment for total/certified functional programming.
We prove these properties, namely, safety and conservativity, for Higher-Order Logic (HOL), a logic implemented in several mainstream theorem provers and relied upon by thousands of users. Some unique features of HOL, such as the requirement to give non-emptiness proofs when defining new types and the impossibility to unfold type definitions, make the proof of these properties, and also the very formulation of safety, nontrivial.
Our study also factors in the essential variation of HOL definitions featured by Isabelle/HOL, a popular member of the HOL-based provers family. The current work improves on recent results which showed a weaker property, consistency of Isabelle/HOL’s definitions.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ondřej</first_name>
          <last_name>Kunčar</last_name>
          <affiliation>Technische Universität München, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www21.in.tum.de/~kuncar/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andrei</first_name>
          <last_name>Popescu</last_name>
          <affiliation>Middlesex University, London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.andreipopescu.uk/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/andreipopescu/4c35986e-7c13-4d2c-9e25-4de4c785ba36/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6632b324-7954-4e2a-bddb-d744ae8b4cb7</subevent_id>
    <title>Research Papers: Business Meeting</title>
    <subevent_type type="regular"/>
    <room>POPL-Keynote</room>
    <date>2018/01/11</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>4f976550-4c04-4ce5-b33a-85df3c0ea459</slot_id>
      <title>Program Chair's Report</title>
      <room>Omni Hotel | POPL-Keynote</room>
      <date>2018/01/11</date>
      <start_time>17:00</start_time>
      <end_time>17:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Andrew</first_name>
          <last_name>Myers</last_name>
          <affiliation>Cornell University</affiliation>
          <bio>Andrew Myers is a Professor in the Department of Computer Science at Cornell University in Ithaca, NY. His research interests include programming languages, computer security, and distributed and persistent programming systems. Myers is an ACM Fellow. He has received awards for papers appearing in POPL’99, SOSP’01, SOSP’07, CIDR’13, PLDI’13, and PLDI’15. Myers is currently the Editor-in-Chief for ACM Transactions on Programming Languages and Systems (TOPLAS). He has also served as program chair or co-chair for a few conferences: ACM POPL 2018, ACM CCS 2016, POST 2014, IEEE CSF 2010, and IEEE S&amp;amp;P 2009.</bio>
          <homepage_url>http://www.cs.cornell.edu/andru</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/andrewmyers/88baadd2-5ed8-4687-b205-3cbbe8b1a848/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c0392f02-6228-444b-9be7-3dd20abedc5a</slot_id>
      <title>SIGPLAN Town Hall</title>
      <room>Omni Hotel | POPL-Keynote</room>
      <date>2018/01/11</date>
      <start_time>17:30</start_time>
      <end_time>18:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Hicks</last_name>
          <affiliation>University of Maryland, College Park</affiliation>
          <bio>Michael Hicks is a Professor in the Computer Science department and UMIACS at the University of Maryland, where he co-directs the laboratory for Programming Languages research (PLUM); he is the former Director of the Maryland Cybersecurity Center (MC2).
His research focuses on using programming languages and analyses to improve the security, reliability, and availability of software. He is perhaps best known for his work exploring dynamic software updating, which is a technique by which software can be updated without shutting it down. He has explored the design of new programming languages and analysis tools for helping programmers find bugs and software vulnerabilities, and for identifying suspicious or incorrect program executions.
His recent work has combined ideas from PL and cryptography, e.g., to ensure privacy preserving computations. He also leads the development of a new security-oriented programming contest, “build-it, break-it, fix-it,” which has been offered to the public and to students in his Coursera class on software security. He is the co-editor of the Programming Languages Enthusiast blog and Tweets at @michael_w_hicks.</bio>
          <homepage_url>http://www.cs.umd.edu/~mwh/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/michaelhicks/aa64e3c6-3516-4e13-affe-77bc32c40565/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Benjamin C.</first_name>
          <last_name>Pierce</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>Benjamin Pierce is Henry Salvatori Professor of Computer and Information Science at the University of Pennsylvania and a Fellow of the ACM. His research interests include programming languages, type systems, language-based security, computer-assisted formal verification, differential privacy, and synchronization technologies. He is the author of the widely used graduate textbooks Types and Programming Languages and Software Foundations. He has served as co-Editor in Chief of the Journal of Functional Programming, as Managing Editor for Logical Methods in Computer Science, and as editorial board member of Mathematical Structures in Computer Science, Formal Aspects of Computing, and ACM Transactions on Programming Languages and Systems. He is also the lead designer of the popular Unison file synchronizer.</bio>
          <homepage_url>http://www.cis.upenn.edu/~bcpierce/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/benjamincpierce/f2ee6f41-5bf7-4a0d-9b8d-71de6a666b1b/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e38aed8a-4140-400e-bd6d-c89c4bca2131</subevent_id>
    <title>Research Papers: Verification I</title>
    <subevent_type type="regular"/>
    <room>POPL-Track-1</room>
    <date>2018/01/10</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>31c44097-3a45-4ce1-b094-1307c2919bb2</slot_id>
      <title>Foundations for Natural Proofs and Quantifier Instantiation</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/10</date>
      <start_time>14:05</start_time>
      <end_time>14:30</end_time>
      <description>We give foundational results that explain the efficacy of heuristics used for dealing with quantified formulas and recursive definitions. We develop a framework for first order logic (FOL) over an uninterpreted combination of background theories. Our central technical result is that systematic term instantiation is \emph{complete} for a fragment of FOL that we call safe. Coupled with the fact that unfolding recursive definitions is essentially term instantiation and with the observation that heap verification engines generate verification conditions in the safe fragment explains the efficacy of verification engines like natural proofs that resort to such heuristics. Furthermore, we study recursive definitions with least fixpoint semantics and show that though they are not amenable to complete procedures, we can systematically introduce induction principles that in practice bridge the divide between FOL and FOL with recursive definitions.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christof</first_name>
          <last_name>Löding</last_name>
          <affiliation>RWTH Aachen University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>P.</first_name>
          <last_name>Madhusudan</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://madhu.cs.illinois.edu</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/pmadhusudan/3775a90b-eb5d-4825-86d8-2a91a1e68fdf/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Lucas</first_name>
          <last_name>Peña</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>34352af2-c050-48f6-9076-9747b694cdff</slot_id>
      <title>Automated Lemma Synthesis in Symbolic-Heap Separation Logic</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/10</date>
      <start_time>13:40</start_time>
      <end_time>14:05</end_time>
      <description>The symbolic-heap fragment of separation logic has been actively developed and applied in verifying the memory-safety of imperative programs in recent years. At the current stage, one of its biggest challenges is how to effectively prove entailments containing inductive heap predicates. These entailments are usually proof obligations generated during the verification of programs manipulating complex data structures such as variants of linked lists, trees, or graphs.
To assist in proving such entailments (i.e. with inductive heap predicates in symbolic-heap separation logic), this paper introduces a lemma synthesis framework, which automatically discovers lemmas to serve as eureka steps in their proofs. Mathematical induction and template-based constraint solving are two pillars of our framework. To derive the supporting lemmas for a given entailment, the framework firstly identifies several possible lemma templates from the entailment’s heap structure, then sets up unknown relations among the variables of each template and conducts structural induction proof to generate constraints about these relations, and finally solves these constraints to find out the unknown relations’ actual definitions, thus discovers the lemmas. We have integrated this framework in a prototype separation logic prover and experiment it on various entailment benchmarks. The experimental results show that our lemma-synthesis-assisted prover can prove many entailments while the existing techniques cannot. This paper opens up opportunities to apply reasoning about inductive heap predicates into practical program verification.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Quang-Trung</first_name>
          <last_name>Ta</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ton Chanh</first_name>
          <last_name>Le</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.comp.nus.edu.sg/~chanhle/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Siau-Cheng</first_name>
          <last_name>Khoo</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.comp.nus.edu.sg/~khoosc/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Wei-Ngan</first_name>
          <last_name>Chin</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3f9162c5-fcac-4854-978b-f83ba13ba81a</slot_id>
      <title>Relatively Complete Refinement Type System for Verification of Higher-Order Non-Deterministic Programs</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/10</date>
      <start_time>14:55</start_time>
      <end_time>15:20</end_time>
      <description>This paper considers verification of {\em non-deterministic} higher-order functional programs. Our contribution is a novel type system in which the types are used to express and verify (conditional) safety, termination, non-safety, and non-termination properties in the presence of $\forall$-$\exists$ branching behavior due to non-determinism. For instance, the judgement $\vdash e:{u:\mathtt{int}\mid\phi(u)}^{\forall\forall}$ says that every evaluation of $e$ either diverges or reduces to some integer $u$ satisfying $\phi(u)$, whereas $\vdash e:{u:\mathtt{int}\mid\psi(u)}^{\exists\forall}$ says that there exists an evaluation of $e$ that either diverges or reduces to some integer $u$ satisfying $\psi(u)$. Note that the former is a safety property whereas the latter is a counterexample to a (conditional) termination property. Following the recent work on type-based verification methods for deterministic higher-order functional programs, we formalize the idea on the foundation of {\em dependent refinement types}, thereby allowing the type system to express and verify rich properties involving program values, branching behaviors, and the combination thereof.
Our type system is able to seamlessly combine deductions of both universal and existential facts within a unified framework, paving the way for an exciting opportunity for new type-based verification methods that combine both universal and existential reasoning. For example, our system can prove the existence of a path violating some safety property from a proof of termination that uses a well-foundedness termination argument. We prove that our type system is sound and relatively complete, and further, thanks to having both modes of non-determinism, we show that our types are closed under complement.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hiroshi</first_name>
          <last_name>Unno</last_name>
          <affiliation>University of Tsukuba</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yuki</first_name>
          <last_name>Satake</last_name>
          <affiliation>University of Tsukuba</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tachio</first_name>
          <last_name>Terauchi</last_name>
          <affiliation>Waseda University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.f.waseda.jp/terauchi</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/tachioterauchi/6781f2f6-f43f-4b02-966e-da5fa934809c/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c9ffc777-5862-477f-a136-bde21cabc596</slot_id>
      <title>Higher-Order Constrained Horn Clauses for Verification</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/10</date>
      <start_time>14:30</start_time>
      <end_time>14:55</end_time>
      <description>Motivated by applications in automated verification of higher-order functional programs, we develop a notion of constrained Horn clauses in higher-order logic and a decision problem concerning their satisfiability. We show that, although satisfiable systems of higher-order clauses do not generally have least models, there is a notion of canonical model obtained through a reduction to a problem concerning a kind of monotone logic program. Following work in higher-order program verification, we develop a refinement type system in order to reason about and automate the search for models. This provides a sound but incomplete method for solving the decision problem. Finally, we show that there is a sense in which we can use refinement types to express properties of terms whilst staying within the higher-order constrained Horn clause framework.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Toby Cathcart</first_name>
          <last_name>Burn</last_name>
          <affiliation>University of Oxford</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>C.-H. Luke</first_name>
          <last_name>Ong</last_name>
          <affiliation>University of Oxford</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ox.ac.uk/people/luke.ong/personal</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/lukeong/c257d95e-8eb2-4f79-a47b-c6c31c4a4db4/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Steven</first_name>
          <last_name>Ramsay</last_name>
          <affiliation>University of Oxford</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl18.sigplan.org/getProfileImage/stevenramsay/e8d1af0b-b8e5-48df-98f2-f8f19c1bac6c/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9ab93a19-9641-4df0-8e0f-03c7d154ee18</subevent_id>
    <title>Research Papers: Interpretation and Evaluation</title>
    <subevent_type type="regular"/>
    <room>POPL-Track-2</room>
    <date>2018/01/10</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>64284daf-8142-4096-9b2c-4b8e47babcf0</slot_id>
      <title>Unifying Analytic and Statically-Typed Quasiquotes</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/10</date>
      <start_time>13:40</start_time>
      <end_time>14:05</end_time>
      <description>Metaprograms are programs that manipulate (generate, analyze and evaluate) other programs. These tasks are greatly facilitated by quasiquotation, a technique to construct and deconstruct program fragments using quoted code templates expressed in the syntax of the manipulated language. We argue that two main flavors of quasiquotes have existed so far: Lisp-style quasiquotes, which can both construct and deconstruct programs but may produce code that contains type mismatches and unbound variables; and MetaML-style quasiquotes, which rely on static typing to prevent these errors, but can only construct programs. In this paper, we show how to combine the advantages of both flavors into a unified framework: we allow the construction, deconstruction and evaluation of program fragments while ensuring that generated programs are well-typed and well-scoped, a combination unseen in previous work. We formalize our approach as λ{}, a multi-stage calculus with code pattern matching and rewriting, and prove its type safety. We also present its realization in Squid, a metaprogramming framework for Scala, leveraging Scala’s expressive type system. To demonstrate the usefulness of our approach, we introduce speculative rewrite rules, a novel code transformation technique that makes decisive use of these capabilities, and we outline how it simplifies the design of some crucial query compiler optimizations.
Squid is open source, available online at https://github.com/epfldata/squid/.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lionel</first_name>
          <last_name>Parreaux</last_name>
          <affiliation>EPFL</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Antoine</first_name>
          <last_name>Voizard</last_name>
          <affiliation>University of Pennsylvannia</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Amir</first_name>
          <last_name>Shaikhha</last_name>
          <affiliation>EPFL</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Christoph E.</first_name>
          <last_name>Koch</last_name>
          <affiliation>EPFL</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>65e19e25-6eb8-4276-b151-d360177850d4</slot_id>
      <title>Jones-Optimal Partial Evaluation by Specialization-Safe Normalization</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/10</date>
      <start_time>14:05</start_time>
      <end_time>14:30</end_time>
      <description>We present partial evaluation by specialization-safe normalization, a novel partial evaluation technique that is Jones-optimal, that can be self-applied to achieve the Futamura projections and that can be type-checked to ensure it always generates code with the correct type. Jones-optimality is the gold-standard for nontrivial partial evaluation and guarantees that a specializer can remove an entire layer of interpretation. We achieve Jones-optimality by using a novel affine-variable static analysis that directs specialization-safe normalization to always decrease a program’s runtime.
We demonstrate the robustness of our approach by showing Jones-optimality in a variety of settings. We have formally proved that our partial evaluator is Jones-optimal for call-by-value reduction, and we have experimentally shown that it is Jones-optimal for call-by-value, normal-order, and memoized normal-order. Each of our experiments tests Jones-optimality with three different self-interpreters.
We implemented our partial evaluator in F$_\omega^{\mu i}$, a recent language for typed self-applicable meta-programming. It is the first Jones-optimal and self-applicable partial evaluator whose type guarantees that it always generates type-correct code.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matt</first_name>
          <last_name>Brown</last_name>
          <affiliation>UCLA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl18.sigplan.org/getProfileImage/mattbrown/c2008a4e-98ee-4ac7-9337-13b41183b9ca/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jens</first_name>
          <last_name>Palsberg</last_name>
          <affiliation>University of California, Los Angeles (UCLA)</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ucla.edu/~palsberg</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/jenspalsberg/9e470c6a-532d-472c-9fea-253b7fa22c7c/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9cf8540a-e9ab-416d-9f72-cd24b1bc32b6</slot_id>
      <title>Intrinsically-Typed Definitional Interpreters for Imperative Languages</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/10</date>
      <start_time>14:55</start_time>
      <end_time>15:20</end_time>
      <description>A definitional interpreter defines the semantics of an object language in terms of the (well-known) semantics of a host language, enabling understanding and validation of the semantics through execution. Combining a definitional interpreter with a separate type system requires a separate type safety proof. An alternative approach, at least for pure object languages, is to use a dependently-typed language to encode the object language type system in the definition of the abstract syntax. Using such intrinsically-typed abstract syntax definitions allows the host language type checker to verify automatically that the interpreter satisfies type safety. Does this approach scale to larger and more realistic object languages, and in particular to languages with mutable state and objects?
In this paper, we describe and demonstrate techniques and libraries in Agda that successfully scale up intrinsically-typed definitional interpreters to handle rich object languages with non-trivial binding structures and mutable state. While the resulting interpreters are certainly more complex than the simply-typed lambda-calculus interpreter we start with, we claim that they still meet the goals of being concise, comprehensible, and executable, while guaranteeing type safety for more elaborate object languages. We make the following contributions: (1) A dependent-passing style technique for hiding the weakening of indexed values as they propagate through monadic code. (2) An Agda library for programming with scope graphs and frames, which provides a uniform approach to dealing with name binding in intrinsically-typed interpreters. (3) Case studies of intrinsically-typed definitional interpreters for the simply-typed lambda-calculus with references (STLC+Ref) and for a large subset of Middleweight Java (MJ).</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Casper</first_name>
          <last_name>Bach Poulsen</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl18.sigplan.org/getProfileImage/casperbachpoulsen/2cddd6a9-d920-4f73-9fcf-f4d9462eb0e3/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Arjen</first_name>
          <last_name>Rouvoet</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Andrew</first_name>
          <last_name>Tolmach</last_name>
          <affiliation>Portland State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.pdx.edu/~apt</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/andrewtolmach/a92afdc6-45ac-4bbb-803c-f93b67dc4a4b/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Robbert</first_name>
          <last_name>Krebbers</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://robbertkrebbers.nl</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Eelco</first_name>
          <last_name>Visser</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>Eelco Visser is Antoni van Leeuwenhoek Professor of Computer Science at Delft University of Technology. He received a master’s and doctorate in computer science from the University of Amsterdam in 1993 and 1997, respectively. Previously he served as postdoc at the Oregon Graduate Institute, as Assistant Professor at Utrecht University, and as Associate Professor at TU Delft.
His research interests include programming languages, software language engineering, domain-specific programming languages, program transformation, software security, and interaction design. With his students he has designed and implemented the Spoofax language workbench, as well as many domain-specific languages, including DSLs for syntax definition (SDF2, SDF3), program transformation (Stratego), name binding (NaBL), dynamic semantics (DynSem), software deployment (Nix), web application development (WebDSL), and mobile phone applications (mobl). In the language designer’s workbench project he is pursuing high-level declarative language definition that serves for language implementation and verification.</bio>
          <homepage_url>http://eelcovisser.org</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/eelcovisser/3df68e8e-fc37-4ca4-bf4e-132e3d32b392/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bd71cca1-cd6d-4c01-8b6f-ac77a77228b9</slot_id>
      <title>Migrating Gradual Types</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/10</date>
      <start_time>14:30</start_time>
      <end_time>14:55</end_time>
      <description>Gradual typing allows programs to enjoy the benefits of both static typing and dynamic typing. While it is often desirable to migrate a program from more dynamically-typed to more statically-typed or vice versa, gradual typing itself does not provide a way to facilitate this migration. This places the burden on programmers who have to manually add or remove type annotations. Besides the general challenge of adding type annotations to dynamically typed code, there are subtle interactions between these annotations in gradually typed code that exacerbate the situation. For example, to migrate a program to be as static as possible, in general, all possible combinations of adding or removing type annotations from parameters must be tried out and compared.
In this paper, we address this problem by developing migrational typing, which efficiently types all possible ways of adding or removing type annotations from a gradually typed program. The typing result supports automatically migrating a program to be as static as possible, or introducing the least number of dynamic types necessary to remove a type error. The approach can be extended to support user-defined criteria about which annotations to modify. We have implemented migrational typing and evaluated it on large programs. The results show that migrational typing scales linearly with the size of the program and takes only 2–4 times longer than plain gradual typing.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>John Peter</first_name>
          <last_name>Campora</last_name>
          <affiliation>ULL Lafayette</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sheng</first_name>
          <last_name>Chen</last_name>
          <affiliation>ULL Lafayette</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ucs.louisiana.edu/~sxc2311/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Martin</first_name>
          <last_name>Erwig</last_name>
          <affiliation>Oregon State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.engr.oregonstate.edu/~erwig/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/martinerwig/8fd12ecd-2d70-44d3-a670-d5ef12393f9c/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Eric</first_name>
          <last_name>Walkingshaw</last_name>
          <affiliation>Oregon State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.engr.oregonstate.edu/~walkiner/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/ericwalkingshaw/090b81a2-4c39-4761-a90b-813f36d28814/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>cdaf40ac-92c3-41c3-8f0f-aa6f42d2e1b4</subevent_id>
    <title>Research Papers: Keynote-II</title>
    <subevent_type type="regular"/>
    <room>POPL-Keynote</room>
    <date>2018/01/11</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>e7bbe3e6-9fb6-4ac0-92e8-c4d4ad43e1c8</slot_id>
      <title>Some Principles of Differential Programming Languages</title>
      <room>Omni Hotel | POPL-Keynote</room>
      <date>2018/01/11</date>
      <start_time>08:30</start_time>
      <end_time>10:00</end_time>
      <description>TBA</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gordon</first_name>
          <last_name>Plotkin</last_name>
          <affiliation>University of Edinburgh, UK</affiliation>
          <bio>Gordon David Plotkin, FRS, FRSE (born 9 September 1946) is a theoretical computer scientist in the School of Informatics at the University of Edinburgh. Plotkin is probably best known for his introduction of structural operational semantics (SOS) and his work on denotational semantics. In particular, his notes on A Structural Approach to Operational Semantics were very influential.
Plotkin was elected a Fellow of the Royal Society in 1992, is a Fellow of the Royal Society of Edinburgh and a Member of the Academia Europæa. He is also a winner of the Royal Society Wolfson Research Merit Award. Plotkin received the 2012 Royal Society Milner Award for “his fundamental research into programming semantics with lasting impact on both the principles and design of programming languages.”[19]
His nomination for the Royal Society reads:

 Plotkin has contributed to Artificial Intelligence, Logic, Linguistics and especially to Computer Science. In AI he worked on hypothesis-formation and universal unification; in Logic, on frameworks for arbitrary logics; in Linguistics, on formalising situation theory. His main general contribution has been to establish a semantic framework for Computer Science, especially programming languages. Particular significant results are in the lambda-calculus (elementary models, definability, call-by-value), non-determinism (powerdomain theory), semantic formalisms (structured operational semantics, metalanguages), and categories of semantic domains (coherent, pro-finite, concrete). Further contributions concern the semantic paradigm of full abstraction, concurrency theory (event structures), programming logic and type theory.

(from https://en.wikipedia.org/wiki/Gordon_Plotkin)</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/gdp/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/gordonplotkin/59cadfdf-4bbc-4207-8f4e-159a1fd53ade/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>25e0514b-79bd-417b-94fb-f3f868ac671e</subevent_id>
    <title>Research Papers: Types and Effects</title>
    <subevent_type type="regular"/>
    <room>POPL-Track-2</room>
    <date>2018/01/10</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>a797297f-5edf-4084-9e39-7226235c5895</slot_id>
      <title>Handle with Care: Relational Interpretation of Algebraic Effects and Handlers</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/10</date>
      <start_time>11:45</start_time>
      <end_time>12:10</end_time>
      <description>Algebraic effects and handlers have received a lot of attention recently, both from the theoretical point of view and in practical language design. This stems from the fact that algebraic effects give the programmer unprecedented freedom to define, combine, and interpret computational effects. This plenty-of-rope, however, demands not only a deep understanding of the underlying semantics, but also access to practical means of reasoning about effectful code, including correctness and program equivalence. In this paper we tackle this problem by constructing a step-indexed relational interpretation of a call-by-value calculus with algebraic effect handlers and row-based polymorphic type-and-effect system. Our calculus, while striving for simplicity, enjoys desirable theoretical properties, and is close to the cores of programming languages with algebraic effects used in the wild, while the logical relation we build for it can be used to reason about non-trivial properties, such as contextual equivalence and contextual approximation of programs. Our development has been fully formalised in the Coq proof assistant.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dariusz</first_name>
          <last_name>Biernacki</last_name>
          <affiliation>University of Wrocław</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Maciej</first_name>
          <last_name>Piróg</last_name>
          <affiliation>University of Wrocław</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ii.uni.wroc.pl/~mpirog/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/maciejpirog/6d35caec-bf73-4a63-b16b-9ee7f05d2a71/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Piotr</first_name>
          <last_name>Polesiuk</last_name>
          <affiliation>University of Wrocław</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Filip</first_name>
          <last_name>Sieczkowski</last_name>
          <affiliation>University of Wrocław</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl18.sigplan.org/getProfileImage/filipsieczkowski/798bba62-e2ef-466f-8548-ab13f479cd83/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>dec6fc60-2bab-47cc-962c-b18e76210f7e</slot_id>
      <title>Handling fibred algebraic effects</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/10</date>
      <start_time>11:20</start_time>
      <end_time>11:45</end_time>
      <description>We study algebraic computational effects and their handlers in the dependently typed setting. We describe computational effects using a generalisation of Plotkin and Pretnar’s effect theories, whose dependently typed operations allow us to capture precise notions of computation, e.g., state with location-dependent store types and dependently typed update monads. Our treatment of handlers is based on an observation that their conventional term-level definition leads to unsound program equivalences being derivable in languages that include a notion of homomorphism. We solve this problem by giving handlers a novel type-based treatment via a new computation type, the user-defined algebra type, which pairs a value type (the carrier) with a family of value terms (the operations), capturing Plotkin and Pretnar’s insight that handlers denote algebras. We show that the conventional presentation of handlers can then be routinely derived. We also demonstrate that this type-based treatment of handlers provides a useful mechanism for reasoning about effectful computations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Danel</first_name>
          <last_name>Ahman</last_name>
          <affiliation>Inria Paris</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/s1225336/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e5c37f00-d89b-408b-8775-72dee8f11de8</slot_id>
      <title>Polyadic Approximations, Fibrations and Intersection Types</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/10</date>
      <start_time>10:55</start_time>
      <end_time>11:20</end_time>
      <description>Starting from an exact correspondence between affine approximations and non-idempotent intersection types, we develop a general framework for building intersection types systems characterizing normalization properties. We show how this construction, which uses in a fundamental way Melliès and Zeilberger’s ``type systems as functors'' viewpoint, allows us to recover equivalent versions of every well known intersection type system (including Coppo and Dezani’s original system, as well as its non-idempotent variants independently introduced by Gardner and de Carvalho). We also show how new systems of intersection types may be built almost automatically in this way.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Damiano</first_name>
          <last_name>Mazza</last_name>
          <affiliation>CNRS</affiliation>
          <bio>I am chargé de recherche (resarcher) at CNRS, working at the Laboratoire d’Informatique de Paris Nord, Université Paris 13. I’ve held this position since 2008. Previously, I was post-doc at Preuves, Programmes et Systèmes and at LIPN. I did my Ph.D. thesis (which I defended in 2006) at the Institut de Mathématiques de Luminy, in Marseille. Before that, I studied CS Engineering in Rome, Italy (which is where I am from).</bio>
          <homepage_url>http://lipn.univ-paris13.fr/~mazza</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/damianomazza/f50f3f4f-0c19-4250-9bbd-c1e3d9a275f1/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Luc</first_name>
          <last_name>Pellissier</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Pierre</first_name>
          <last_name>Vial</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f1a9942d-aaf8-4951-8400-7df2ed593142</slot_id>
      <title>Linear Haskell: practical linearity in a higher-order polymorphic language</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/10</date>
      <start_time>10:30</start_time>
      <end_time>10:55</end_time>
      <description>Linear type systems have a long and storied history, but not a clear path forward to integrate with existing languages such as Ocaml or Haskell. In this paper, we introduce and study a linear type system designed with two crucial properties in mind: backwards-compatibility and code reuse across linear and non-linear users of a library. Only then can the benefits of linear types permeate conventional functional programming. Rather than bifurcate types into linear and non-linear counterparts, we instead attach linearity to function arrows. Linear function types can receive inputs from linearly-bound values, but can also operate over unrestricted, regular values.
To demonstrate the efficacy of our linear type system—both how easy it can be integrated in an existing language implementation and how streamlined it makes it to write program with linear types—we implemented our type system in a branch of GHC, the leading Haskell compiler, and demonstrate, with it, two kinds of applications of linear types: making functions, that otherwise would be considered to have side effects, pure; and enforcing protocols in I/O-performing functions.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jean-Philippe</first_name>
          <last_name>Bernardy</last_name>
          <affiliation>University of Gothenburg</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mathieu</first_name>
          <last_name>Boespflug</last_name>
          <affiliation>Tweag I/O</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ryan R.</first_name>
          <last_name>Newton</last_name>
          <affiliation>Indiana University</affiliation>
          <bio>From South Florida. Ph.D. 2009 at MIT.</bio>
          <homepage_url>http://cs.indiana.edu/~rrnewton</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/ryanrnewton/4dff7d06-8ca4-46f3-981b-52049bc71c54/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Simon Peyton</first_name>
          <last_name>Jones</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>Simon Peyton Jones, MA, MBCS, CEng, graduated from Trinity College Cambridge in 1980. After two years in industry, he spent seven years as a lecturer at University College London, and nine years as a professor at Glasgow University, before moving to Microsoft Research (Cambridge) in 1998. His main research interest is in functional programming languages, their implementation, and their application. He has led a succession of research projects focused around the design and implementation of production-quality functional-language systems for both uniprocessors and parallel machines. He was a key contributor to the design of the now-standard functional language Haskell, and is the lead designer of the widely-used Glasgow Haskell Compiler (GHC). He has written two textbooks about the implementation of functional languages.
More generally, he is interested in language design, rich type systems, software component architectures, compiler technology, code generation, runtime systems, virtual machines, and garbage collection. He is particularly motivated by direct use of principled theory to practical language design and implementation – that’s one reason he loves functional programming so much.</bio>
          <picture_url>https://popl18.sigplan.org/getProfileImage/simonpaytonjones/61daea4a-3a8b-4363-925e-b38fe6eac90d/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Arnaud</first_name>
          <last_name>Spiwack</last_name>
          <affiliation>Tweag I/O</affiliation>
          <bio>Arnaud Spiwack spend the first 10 years of his working life in Academia, between Chalmers university in Gothenburg, Sweden, and École Polytechnique, Inria, and Mines ParisTech, in the Paris area. He spent this time researching dependent types, computer-verified proof, and sequent calculus. During his time in Academia, Arnaud got involved in the development of the Coq Proof Assistant, where he, in particular, re-engineered Coq’s tactic engine and gave it an abstract interface. After leaving Academia, he remained a member of the core development team of the Coq Proof Assistant. He is now a senior architect at Tweag I/O, and is working at making the world better typed.</bio>
          <homepage_url>http://assert-false.net/arnaud/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/arnaudspiwack/2658428c-5eaf-48b9-9ff9-322b4260141e/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a82ed8d1-73f4-4c84-8166-11987385c032</subevent_id>
    <title>Research Papers: Memory and Concurrency</title>
    <subevent_type type="regular"/>
    <room>POPL-Track-1</room>
    <date>2018/01/10</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>20c3783a-e780-4916-8db1-7affe028aa89</slot_id>
      <title>Transactions in Relaxed Memory Architectures</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/10</date>
      <start_time>16:15</start_time>
      <end_time>16:40</end_time>
      <description>The integration of transactions into hardware relaxed memory architectures is a topic of research both in industry and academia. In this paper, we provide a general architectural framework (that includes the SC, TSO and ARM8 models) for the introduction of transactions into models of relaxed memory in hardware. Our model incorporates flexible and expressive forms of transaction abort and execution that have hitherto been in the realm of Software Transactional Memory. In contrast to Software transactional memory, we account for the characteristics of relaxed memory as a (restricted form of a) distributed system without a notion of global time. We prove abstraction theorems to demonstrate that the programmer API matches the intuitions and expectations about transactions.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Brijesh</first_name>
          <last_name>Dongol</last_name>
          <affiliation>Brunel University London</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Radha</first_name>
          <last_name>Jagadeesan</last_name>
          <affiliation>DePaul University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>James</first_name>
          <last_name>Riely</last_name>
          <affiliation>DePaul University</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>27d6b3d0-da25-4140-abc2-3ec1a8daefe0</slot_id>
      <title>Effective Stateless Model Checking for C/C++ Concurrency</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/10</date>
      <start_time>15:50</start_time>
      <end_time>16:15</end_time>
      <description>We present a stateless model checking algorithm for verifying concurrent programs running under RC11, a repaired version of the C/C++11 weak memory model without dependency cycles. Unlike previous approaches, which enumerate thread interleavings up to some partial order reduction improvements, our approach works directly on execution graphs and (in the absence of RMW instructions) avoids redundant exploration by construction. We have implemented a model checker, called RCMC, based on this approach and apply it to a number of challenging concurrent programs. Our experiments confirm that our tool leads to much faster verification times than other model checking tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michalis</first_name>
          <last_name>Kokologiannakis</last_name>
          <affiliation>National Technical University of Athens, Greece</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://michaliskok.github.io</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/michaliskokologiannakis/614e1cef-e53d-4f80-b693-c95f02ff7953/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ori</first_name>
          <last_name>Lahav</last_name>
          <affiliation>Tel Aviv University, Israel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~orilahav/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/orilahav/89b656f6-7634-49d1-9917-4b74da70a976/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Konstantinos</first_name>
          <last_name>Sagonas</last_name>
          <affiliation>Uppsala University, Sweden</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Viktor</first_name>
          <last_name>Vafeiadis</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>Viktor Vafeiadis is a tenured faculty at the Max Planck Institute for Software Systems (MPI-SWS) in Germany. He got his BA and PhD from the University of Cambridge, and held post-doctoral researcher positions at the University of Cambridge and at Microsoft Research Cambridge before joining MPI-SWS in October 2010.</bio>
          <homepage_url>http://www.mpi-sws.org/~viktor/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/viktorvafeiadis/6a063832-47ca-4c32-8047-4bf4f74ae764/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4de4e0be-ee4c-420b-942e-a631ecdb6f86</slot_id>
      <title>Progress of Concurrent Objects with Partial Methods</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/10</date>
      <start_time>17:05</start_time>
      <end_time>17:30</end_time>
      <description>Various progress properties have been proposed for concurrent objects, such as wait-freedom, lock-freedom, starvation-freedom and deadlock-freedom. However, none of them apply for concurrent objects with partial methods, i.e. methods that are supposed not to return under certain circumstances. A typical example is the lock_acquire method.
In this paper we propose two new progress properties, partial starvation-freedom (PSF) and partial deadlockfreedom (PDF), for concurrent objects with partial methods. We also design four patterns to write abstract specifications for PSF or PDF objects under strongly or weakly fair scheduling, so that these objects contextually refine the abstract specifications. Our Abstraction Theorem shows the equivalence between PSF (or PDF) and the progress-aware contextual refinement. Finally, we generalize the program logic LiLi to have a new logic to verify the PSF or PDF property and linearizability of concurrent objects.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hongjin</first_name>
          <last_name>Liang</last_name>
          <affiliation>University of Science and Technology of China</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Xinyu</first_name>
          <last_name>Feng</last_name>
          <affiliation>University of Science and Technology of China</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://staff.ustc.edu.cn/~xyfeng</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/xinyufeng/172c86f2-3d81-4344-9652-6aba9e9d0cb3/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d23ed660-19cb-4aaa-8f26-e4ddf2d01c49</slot_id>
      <title>Simplifying ARM Concurrency: Multicopy-Atomic Axiomatic and Operational Models for ARMv8</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/10</date>
      <start_time>16:40</start_time>
      <end_time>17:05</end_time>
      <description>ARM has a relaxed memory model, previously specified in informal prose for ARMv7 and ARMv8. Over time, and partly due to work building formal semantics for ARM concurrency, it has become clear that some of the complexity of the model is not justified by the potential benefits. In particular, the model was originally non-multicopy-atomic: writes could become visible to some other threads before becoming visible to all — but this has not been exploited in production implementations, the corresponding potential hardware optimisations are thought to have insufficient benefits in the ARM context, and it gives rise to subtle complications when combined with other ARMv8 features. The ARMv8 architecture has therefore been revised: it now has a multicopy-atomic model. It has also been simplified in other respects, including more straightforward notions of dependency, and the architecture now includes a formal concurrency model.
In this paper we detail these changes and discuss their motivation. We define two formal concurrency models: an operational one, simplifying the Flowing model of Flur et al., and the axiomatic model of the revised ARMv8 specification. The models were developed by an academic group and by ARM staff, respectively, and this extended collaboration partly motivated the above changes. We prove the equivalence of the two models. The operational model is integrated into an executable exploration tool with new web interface, demonstrated by exhaustively checking the possible behaviours of a loop-unrolled version of a Linux kernel lock implementation, a previously known bug due to unprevented speculation, and a fixed version.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christopher</first_name>
          <last_name>Pulte</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Shaked</first_name>
          <last_name>Flur</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Will</first_name>
          <last_name>Deacon</last_name>
          <affiliation>ARM Ltd.</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jon</first_name>
          <last_name>French</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Susmit</first_name>
          <last_name>Sarkar</last_name>
          <affiliation>University of St. Andrews</affiliation>
          <bio>undefined</bio>
          <homepage_url>www.cs.st-andrews.ac.uk/~ss265</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Peter</first_name>
          <last_name>Sewell</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cl.cam.ac.uk/~pes20/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/petersewell/ba28b120-f5b2-42d2-90b8-0559f144abee/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>aae4a8c0-856e-4167-a331-c7fedc2160dd</subevent_id>
    <title>Research Papers: Dependent Types</title>
    <subevent_type type="regular"/>
    <room>POPL-Track-2</room>
    <date>2018/01/11</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>05653c28-25ef-47f2-9f80-86b4328a60c7</slot_id>
      <title>Up-to Techniques Using Sized Types</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/11</date>
      <start_time>15:50</start_time>
      <end_time>16:15</end_time>
      <description>Up-to techniques are used to make it easier—or feasible—to construct, for instance, proofs of bisimilarity. This text shows how many up-to techniques can be framed as size-preserving functions, using sized types to keep track of sizes. Through a number of examples it is argued that this approach to up-to techniques is convenient to use in practice.
On the more theoretical side a class of up-to techniques intended to capture a natural mode of use of such size-preserving functions is defined. This class turns out to correspond closely to “functions below the companion”, a notion recently introduced by Pous.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nils Anders</first_name>
          <last_name>Danielsson</last_name>
          <affiliation>University of Gothenburg, Chalmers University of Technology</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>779e5ddf-164b-43fe-8cfb-ce4641e50c5a</slot_id>
      <title>Decidability of Conversion for Type Theory in Type Theory</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/11</date>
      <start_time>16:15</start_time>
      <end_time>16:40</end_time>
      <description>Type theory should be able to handle its own meta-theory, both to justify its foundational claims and to obtain a verified implementation. At the core of a type checker for intensional type theory lies an algorithm to check equality of types, or in other words, to check whether two types are convertible. We have formalized in Agda a practical conversion checking algorithm for a dependent type theory with one universe à la Russell, natural numbers, and $\eta$-equality for $\Pi$ types. We prove the algorithm correct via a Kripke logical relation parameterized by a suitable notion of equivalence of terms. We then instantiate the parameterized fundamental lemma twice: once to obtain canonicity and injectivity of type formers, and once again to prove the completeness of the algorithm. Our proof relies on inductive-recursive definitions, but not on the uniqueness of identity proofs. Thus, it is valid in variants of intensional Martin-Löf Type Theory as long as they support induction-recursion, for instance, Extensional, Observational, or Homotopy Type Theory.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Andreas</first_name>
          <last_name>Abel</last_name>
          <affiliation>Gothenburg University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Joakim</first_name>
          <last_name>Öhman</last_name>
          <affiliation>IMDEA Software Institute</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Andrea</first_name>
          <last_name>Vezzosi</last_name>
          <affiliation>Chalmers University of Technology</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>68bebb3c-ce6d-4a77-8752-f6318261de5b</subevent_id>
    <title>Research Papers: Synthesis</title>
    <subevent_type type="regular"/>
    <room>POPL-Track-1</room>
    <date>2018/01/12</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>baccd5c1-9c6d-493c-8cc9-02a045676430</slot_id>
      <title>Bonsai: Synthesis-Based Reasoning for Type Systems</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/12</date>
      <start_time>16:23</start_time>
      <end_time>16:56</end_time>
      <description>We describe algorithms for symbolic reasoning about executable models of type systems, supporting three queries intended for designers of type systems. First, we check for type soundness bugs and synthesize a counterexample program if such a bug is found. Second, we compare two versions of a type system, synthesizing a program accepted by one but rejected by the other. Third, we minimize the size of synthesized counterexample programs.
These algorithms symbolically evaluate typecheckers and interpreters, producing formulas that characterize the set of programs that fail or succeed in the typechecker and the interpreter. However, symbolically evaluating interpreters poses efficiency challenges, which are caused by having to merge execution paths of the various possible input programs. Our main contribution is the Bonsai tree, a novel symbolic representation of programs and program states which addresses these challenges. Bonsai trees encode complex syntactic information in terms of logical constraints, enabling more efficient merging.
We implement these algorithms in the BONSAI tool, an assistant for type system designers. We perform case studies on how BONSAI helps test and explore a variety of type systems. BONSAI efficiently synthesizes counterexamples for soundness bugs that have been inaccessible to automatic tools, and is the first automated tool to find a counterexample for the recently discovered Scala soundness bug SI-9633.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kartik</first_name>
          <last_name>Chandra</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://stanford.edu/~kach/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Rastislav</first_name>
          <last_name>Bodik</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.berkeley.edu/~bodik</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/rastislavbodik/ae16ae8e-9d00-41c4-9067-0c37da65dde7/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>def185a4-42d7-4130-9b23-45d76646291a</slot_id>
      <title>Program Synthesis using Abstraction Refinement</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/12</date>
      <start_time>16:56</start_time>
      <end_time>17:30</end_time>
      <description>We present a new approach to example-guided program synthesis based on counterexample-guided abstraction refinement. Our method uses the abstract semantics of the underlying DSL to find a program $P$ whose abstract behavior satisfies the examples. However, since program $P$ may be spurious with respect to the concrete semantics, our approach iteratively refines the abstraction until we either find a program that satisfies the examples or prove that no such DSL program exists. Because many programs have the same input-output behavior in terms of their abstract semantics, this synthesis methodology significantly reduces the search space compared to existing techniques that use purely concrete semantics.
While synthesis using abstraction refinement (SYNGAR) could be implemented in different settings, we propose a refinement-based synthesis algorithm that uses abstract finite tree automata (AFTA). Our technique uses a coarse initial program abstraction to construct an initial AFTA, which is iteratively refined by constructing a proof of incorrectness of any spurious program. In addition to ruling out the spurious program accepted by the previous AFTA, proofs of incorrectness are also useful for ruling out many other spurious programs.
We implement these ideas in a framework called Blaze, which can be instantiated in different domains by providing a suitable DSL and its corresponding concrete and abstract semantics. We have used the Blaze framework to build synthesizers for string and matrix transformations, and we compare Blaze with existing techniques. Our results for the string domain show that Blaze compares favorably with FlashFill, a domain-specific synthesizer that is now deployed in Microsoft PowerShell. In the context of matrix manipulations, we compare Blaze against Prose, a state-of-the-art general-purpose VSA-based synthesizer, and show that Blaze results in a 90x speed-up over Prose. In both application domains, Blaze also consistently improves upon the performance of two other existing techniques by at least an order of magnitude.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xinyu</first_name>
          <last_name>Wang</last_name>
          <affiliation>UT Austin</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.utexas.edu/~xwang</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/xinyuwang/ccbe37b1-293c-4205-8386-295e20bce0d7/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Isil</first_name>
          <last_name>Dillig</last_name>
          <affiliation>UT Austin</affiliation>
          <bio>Isil Dillig is an Associate Professor of Computer Science at the University of Texas at Austin where she leads the UToPiA research group. Her main research area is programming languages, with a specific emphasis on static analysis, verification, and program synthesis. The techniques developed by her group aim to make software systems more reliable, secure, and easier to build in a robust way. Dr. Dillig is a Sloan Fellow and a recipient of the NSF CAREER award. She obtained all her degrees (BS, MS, and PhD) from Stanford University.</bio>
          <homepage_url>http://www.cs.utexas.edu/~isil/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/isildillig/e4fa3855-0ae4-4638-84e3-1fe224e64e3f/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Rishabh</first_name>
          <last_name>Singh</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>Rishabh Singh is a researcher at Microsoft Research, Redmond. His research interests span the areas of programming languages and deep learning. His recent work has focused on developing neural architectures for program synthesis. He obtained his PhD in Computer Science from MIT in 2014, where he was a Microsoft Research PhD fellow and was awarded the MIT’s George M. Sprowls Award for Best PhD Dissertation in Computer Science. He obtained his BTech in Computer Science from IIT Kharagpur in 2008, where he was awarded the Institute Silver Medal and Bigyan Sinha Memorial Award.</bio>
          <homepage_url>http://people.csail.mit.edu/rishabh/website/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/rishabhsingh/4a1b1d69-0e64-4fe5-bce3-055fdeb94b32/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ebedb6f5-eb63-45ef-99eb-ba4e07d73b46</slot_id>
      <title>Strategy Synthesis for Linear Arithmetic Games</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/12</date>
      <start_time>15:50</start_time>
      <end_time>16:23</end_time>
      <description>Many problems in formal methods can be formalized as two-player games. For several applications, program synthesis for example, we are interested not just in the determining which player wins the game, but in computing a winning strategy for that player. This paper studies the strategy synthesis problem for games defined within the theory of linear rational arithmetic. Two types of games are considered. A satisfiability game is described by a quantified formula, and is played by two players that take turns instantiating quantifiers. The objective of each player is to prove (or disprove) satisfiability of the formula. A reachability game is described by a pair of formulas defining the legal moves of each player, and is played by two players that take turns choosing positions – rational vectors of some fixed dimension. The objective of each player is to reach a position where the opposing player has no legal moves (or to play the game forever). We give a complete algorithm for synthesizing winning strategies for satisfiability games and a sound (but necessarily incomplete) algorithm for synthesizing winning strategies for reachability games.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Azadeh</first_name>
          <last_name>Farzan</last_name>
          <affiliation>University of Toronto</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.toronto.edu/~azadeh/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/azadehfarzan/f0942c46-887a-4f22-bf78-74fd48f6f0ed/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Zachary</first_name>
          <last_name>Kincaid</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.princeton.edu/~zkincaid</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/zacharykincaid/a26b486e-94a5-45f1-a8b3-9a2221495ff7/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ac8917e8-30e4-470e-917f-51eac2a0b88d</subevent_id>
    <title>Research Papers: Strings</title>
    <subevent_type type="regular"/>
    <room>POPL-Track-1</room>
    <date>2018/01/10</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>0534a839-12fe-4498-9554-94e2f5cbe852</slot_id>
      <title>WebRelate: Integrating Web Data with Spreadsheets using Examples</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/10</date>
      <start_time>10:55</start_time>
      <end_time>11:20</end_time>
      <description>Data integration between web sources and relational data is a key challenge faced by data scientists and spreadsheet users. There are two main challenges in programmatically joining web data with relational data. First, most websites do not expose a direct interface to obtain tabular data, so the user needs to formulate a logic to get to different webpages for each input row in the relational table. Second, after reaching the desired webpage, the user needs to write complex scripts to extract the relevant data, which is often conditioned on the input data. Since many data scientists and end-users come from diverse backgrounds, writing such complex regular-expression based logical scripts to perform data integration tasks is unfortunately often beyond their programming expertise.
We present WebRelate, a system that allows users to join semi-structured web data with relational data in spreadsheets using input-output examples. WebRelate decomposes the web data integration task into two sub-tasks. The first sub-task generates the URLs for the webpages containing the desired data for all rows in the relational table. WebRelate achieves this by learning a string transformation program using a few example URLs. The second sub-task uses examples of desired data to be extracted from the corresponding webpages and learns a program to extract the data for the other rows.We design expressive domain-specific languages for URL generation and web data extraction, and present efficient synthesis algorithms for learning programs in these DSLs from few input-output examples. We evaluate WebRelate on 88 real-world data integration tasks taken from online help forums and other anonymous sources, and show that WebRelate can learn the programs to perform desired web data integration tasks within few seconds using only 1 example for the majority of the tasks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jeevana Priya</first_name>
          <last_name>Inala</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Rishabh</first_name>
          <last_name>Singh</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>Rishabh Singh is a researcher at Microsoft Research, Redmond. His research interests span the areas of programming languages and deep learning. His recent work has focused on developing neural architectures for program synthesis. He obtained his PhD in Computer Science from MIT in 2014, where he was a Microsoft Research PhD fellow and was awarded the MIT’s George M. Sprowls Award for Best PhD Dissertation in Computer Science. He obtained his BTech in Computer Science from IIT Kharagpur in 2008, where he was awarded the Institute Silver Medal and Bigyan Sinha Memorial Award.</bio>
          <homepage_url>http://people.csail.mit.edu/rishabh/website/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/rishabhsingh/4a1b1d69-0e64-4fe5-bce3-055fdeb94b32/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1adb63ad-14f4-4093-bad0-9d0343884db8</slot_id>
      <title>What's Decidable About String Constraints with ReplaceAll Function?</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/10</date>
      <start_time>11:20</start_time>
      <end_time>11:45</end_time>
      <description>The theory of strings with concatenation has been widely argued as the basis of constraint solving for verifying string-manipulating programs. However, this theory is far from adequate for expressing many string constraints that are also needed in practice; for example, the use of regular constraints (pattern matching against a regular expression), and the string-replace function (replacing either the first occurrence or all occurrences of a pattern'' string constant/variable/regular expression by areplacement'' string constant/variable), among many others. Both regular constraints and the string-replace function are crucial for such applications as analysis of JavaScript (or more generally HTML5 applications) against cross-site scripting (XSS) vulnerabilities, which motivates us to consider a richer class of string constraints. The importance of the string-replace function (especially the replace-all facility) is increasingly recognised, which can be witnessed by the incorporation of the function in the input languages of several string constraint solvers.
Recently, it was shown that any theory of strings containing the string-replace function (even the most restricted version where pattern/replacement strings are both constant strings) becomes undecidable if we do not impose some kind of straight-line (aka acyclicity) restriction on the formulas. Despite this, the straight-line restriction is still practically sensible since this condition is typically met by string constraints that are generated by symbolic execution. In this paper, we provide the first systematic study of straight-line string constraints with the string-replace function and the regular constraints as the basic operations. We show that a large class of such constraints (i.e. when only a constant string or a regular expression is permitted in the pattern) is decidable. We note that the string-replace function, even under this restriction, is sufficiently powerful for expressing the concatenation operator and much more (e.g. extensions of regular expressions with string variables). This gives us the most expressive decidable logic containing concatenation, replace, and regular constraints under the same umbrella. Our decision procedure for the straight-line fragment follows an automata-theoretic approach, and is modular in the sense that the string-replace terms are removed one by one to generate more and more regular constraints, which can then be discharged by the state-of-the-art string constraint solvers. We also show that this fragment is, in a way, a maximal decidable subclass of the straight-line fragment with string-replace and regular constraints. To this end, we show undecidability results for the following two extensions: (1) variables are permitted in the pattern parameter of the replace function, (2) length constraints are permitted.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Taolue</first_name>
          <last_name>Chen</last_name>
          <affiliation>Birkbeck, University of London</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yan</first_name>
          <last_name>Chen</last_name>
          <affiliation>State Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Sciences &amp; University of Chinese Academy of Sciences</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Hague</last_name>
          <affiliation>Royal Holloway, University of London</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Anthony Widjaja</first_name>
          <last_name>Lin</last_name>
          <affiliation>Oxford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://anthonywlin.github.io/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/anthonywidjajalin/de8e94c9-268b-45b3-9436-54dcca280b28/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Zhilin</first_name>
          <last_name>Wu</last_name>
          <affiliation>State Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Sciences</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3591886d-7dc8-494d-ae83-4e92477911cf</slot_id>
      <title>String Constraints with Concatenation and Transducers Solved Efficiently</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/10</date>
      <start_time>11:45</start_time>
      <end_time>12:10</end_time>
      <description>String analysis is the problem of reasoning about how strings are manipulated by a program. It has numerous applications including automatic detection of cross-site scripting, and automatic test-case generation. A popular string analysis technique includes symbolic executions, which at their core use constraint solvers over string domains, a.k.a. string solvers. Such solvers typically reason about constraints expressed in theories over strings with the concatenation operator as an atomic constraint. In recent years, researchers started to recognise the importance of incorporating the replace-all operator (i.e. replace all occurrences of a string by another string) and, more generally, finite-state transductions in the theories of strings with concatenation. Such string operations are typically crucial for reasoning about XSS vulnerabilities in web applications, especially for modelling sanitisation functions and implicit browser transductions (e.g. innerHTML). Although this results in an undecidable theory in general, it was recently shown that the straight-line fragment of the theory is decidable, and is sufficiently expressive in practice for many applications. In this paper, we provide the first string solver that can reason about constraints involving both concatenation and finite-state transductions, and that is a decision procedure for several relevant fragments, including straight-line. The main challenge that we address in the paper is the prohibitive worst-case computational complexity of the theory (double-exponential time), which is exponentially harder than the case without finite-state transductions. To this end, we propose a method that exploits succinct alternating finite-state automata as concise symbolic representations of string constraints. Compared to methods that use representations based on nondeterministic machines, alternation offers not only (expected) exponential savings in space when representing Boolean combinations of transducers, but, importantly, also a possibility of succinct representation of otherwise costly combinations of transducers and concatenation. Reasoning about the emptiness of the AFA language requires a state-space exploration in an exponential-sized graph. To this end, we use the model checking algorithms like IC3 for solving the problem. We have implemented our algorithm and demonstrated its efficacy on string benchmarks that are derived from cross-site scripting analysis and other examples in the literature.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lukas</first_name>
          <last_name>Holik</last_name>
          <affiliation>Brno University of Technology</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Anthony Widjaja</first_name>
          <last_name>Lin</last_name>
          <affiliation>Oxford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://anthonywlin.github.io/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/anthonywidjajalin/de8e94c9-268b-45b3-9436-54dcca280b28/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Petr</first_name>
          <last_name>Janku</last_name>
          <affiliation>Brno University of Technology</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Philipp</first_name>
          <last_name>Ruemmer</last_name>
          <affiliation>Uppsala University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.philipp.ruemmer.org</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/philippruemmer/c563ff7b-5e11-4bb5-85bc-e1e4cb75bf8b/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Tomas</first_name>
          <last_name>Vojnar</last_name>
          <affiliation>Brno University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>www.fit.vutbr.cz/~vojnar</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7edd99f8-4b2c-40c6-b055-3d8966d00b8e</slot_id>
      <title>Synthesizing Bijective Lenses</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/10</date>
      <start_time>10:30</start_time>
      <end_time>10:55</end_time>
      <description>Bidirectional transformations between different data representations occur frequently in modern software systems. They appear as serializers and deserializers, as parsers and pretty printers, as database views and view updaters, and as a multitude of different kinds of ad hoc data converters. Manually building bidirectional transformations—by writing two separate functions that are intended to be inverses—is tedious and error prone. A better approach is to use a domain-specific language in which both directions can be written as a single expression. However, these domain-specific languages can be difficult to program in, requiring programmers to manage fiddly details while working in a complex type system.
We present an alternative approach. Instead of coding transformations manually, we synthesize them from declarative format descriptions and examples. Specifically, we present Optician, a tool for type-directed synthesis of bijective string transformers. The inputs to Optician are a pair of ordinary regular expressions representing two data formats and a few concrete examples for disambiguation. The output is a well-typed program in Boomerang (a bidirectional language based on the theory of lenses). The main technical challenge involves navigating the vast program search space efficiently enough. In particular, and unlike most prior work on type-directed synthesis, our system operates in the context of a language with a rich equivalence relation on types (the theory of regular expressions). Consequently, program synthesis requires search in two dimensions: First, our synthesis algorithm must find a pair of “syntactically compatible types,” and second, using the structure of those types, it must find a type- and example-compliant term. Our key insight is that it is possible to reduce the size of this search space without losing any computational power by defining a new language of lenses designed specifically for synthesis. The new language is free from arbitrary function composition and operates only over types and terms in a new disjunctive normal form. We prove (1) our new language is just as powerful as a more natural, compositional, and declarative language and (2) our synthesis algorithm is sound and complete with respect to the new language. We also demonstrate empirically that our new language changes the synthesis problem from one that admits intractable solutions to one that admits highly efficient solutions, able to synthesize lenses between complex file formats with great variation in seconds. We evaluate Optician on a benchmark suite of 39 examples that includes both microbenchmarks and realistic examples derived from other data management systems including Flash Fill, a tool for synthesizing string transformations in spreadsheets, and Augeas, a tool for bidirectional processing of Linux system configuration files.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Anders</first_name>
          <last_name>Miltner</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.princeton.edu/~amiltner/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kathleen</first_name>
          <last_name>Fisher</last_name>
          <affiliation>Tufts University</affiliation>
          <bio>Kathleen Fisher is Professor in the Computer Science Department at Tufts. Previously, she was a Principal Member of the Technical Staff at AT&amp;amp;T Labs Research, a Consulting Faculty Member in the Computer Science Department at Stanford University, and a program manager at DARPA where she started and managed the HACMS and PPAML programs. Kathleen’s research focuses on advancing the theory and practice of programming languages and on applying ideas from the programming language community to the problem of ad hoc data management. The main thrust of her work has been in domain-specific languages to facilitate programming with massive amounts of ad hoc data, including the Hancock system for efficiently building signatures from massive transaction streams and the PADS system for managing ad hoc data. Recently, she has been exploring synergies between machine learning and programming languages and studying how to apply advances in programming languages to the problem of building more secure systems.
Kathleen is an ACM Fellow. She has served as program chair for FOOL, ICFP, CUFP, and OOPSLA and as General Chair for ICFP 2015. Kathleen is past Chair of the ACM Special Interest Group in Programming Languages (SIGPLAN), past Co-Chair of CRA’s Committee on the Status of Women (CRA-W), and a former editor of the Journal of Functional Programming. She is an Associate Editor for TOPLAS.</bio>
          <homepage_url>http://www.cs.tufts.edu/~kfisher</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/kathleenfisher/04a1b289-f7fe-4e91-b686-6b34a7a45cb2/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benjamin C.</first_name>
          <last_name>Pierce</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>Benjamin Pierce is Henry Salvatori Professor of Computer and Information Science at the University of Pennsylvania and a Fellow of the ACM. His research interests include programming languages, type systems, language-based security, computer-assisted formal verification, differential privacy, and synchronization technologies. He is the author of the widely used graduate textbooks Types and Programming Languages and Software Foundations. He has served as co-Editor in Chief of the Journal of Functional Programming, as Managing Editor for Logical Methods in Computer Science, and as editorial board member of Mathematical Structures in Computer Science, Formal Aspects of Computing, and ACM Transactions on Programming Languages and Systems. He is also the lead designer of the popular Unison file synchronizer.</bio>
          <homepage_url>http://www.cis.upenn.edu/~bcpierce/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/benjamincpierce/f2ee6f41-5bf7-4a0d-9b8d-71de6a666b1b/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>David</first_name>
          <last_name>Walker</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.princeton.edu/~dpw/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/davidwalker/8763137a-03a5-4963-8639-e9f2a3cc8ac9/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Steve</first_name>
          <last_name>Zdancewic</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cis.upenn.edu/~stevez</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/stevezdancewic/41b883c6-4689-4ae3-b6f1-6b7a24622e99/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>bbe30fa0-9715-43e6-b82a-f919a1579e9e</subevent_id>
    <title>Research Papers: Dynamic Languages</title>
    <subevent_type type="regular"/>
    <room>POPL-Track-2</room>
    <date>2018/01/12</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>10d66f46-e628-4656-b7e0-f26db753312e</slot_id>
      <title>JaVerT: JavaScript Verification Toolchain</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/12</date>
      <start_time>10:55</start_time>
      <end_time>11:20</end_time>
      <description>The dynamic nature of JavaScript and its complex semantics make it a difficult target for logic-based verification. We introduce JaVerT, a semi-automatic JavaScript Verification Toolchain based on separation logic. To specify JavaScript programs, we design abstractions that capture its key heap structures (e.g. prototype chains, function closures), allowing the user to write clear and succinct specifications with minimal knowledge of the JavaScript internals. To verify JavaScript programs, we develop JaVerT, a verification pipeline consisting of: JS-2-JSIL, a well-tested compiler from JavaScript to JSIL, an intermediate goto language capturing the fundamental dynamic features of JavaScript; JSIL Verify, a semi-automatic verification tool based on a sound JSIL separation logic; and verified axiomatic specifications of the JavaScript internal functions. Using JaVerT, we verify functional correctness properties of data-structure libraries (key-value map, priority queue) written in object-oriented style; operations on data structures such as BSTs and lists; examples illustrating function closures; and test cases from the official ECMAScript test suite. The verification times suggest that reasoning about larger, more complex code using JaVerT is feasible.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>José Fragoso</first_name>
          <last_name>Santos</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Petar</first_name>
          <last_name>Maksimović</last_name>
          <affiliation>Imperial College London, Mathematical Institute SANU</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Daiva</first_name>
          <last_name>Naudžiūnienė</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~dn911/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Wood</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Philippa</first_name>
          <last_name>Gardner</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~pg/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>670344e9-892d-4aee-a13b-435115253b45</slot_id>
      <title>Soft Contract Verification for Higher-order Stateful Programs</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/12</date>
      <start_time>11:20</start_time>
      <end_time>11:45</end_time>
      <description>Software contracts allow programmers to state rich program properties using the full expressive power of an object language. However, since they are enforced at runtime, monitoring contracts imposes significant overhead and delays error discovery. So contract verification aims to guarantee all or most of these properties ahead of time, enabling valuable optimizations and yielding a more general assurance of correctness. Existing methods for static contract verification satisfy the needs of more restricted target languages, but fail to address the challenges unique to those conjoining untyped, dynamic programming, higher-order functions, modularity, and statefulness. Our approach tackles all these features at once, in the context of the full Racket system—a mature environment for stateful, higher-order, multi-paradigm programming with or without types. Evaluating our method using a set of both pure and stateful benchmarks, we are able to verify 99.94% of checks statically (all but 28 of 51, 713).
Stateful, higher-order functions pose significant challenges for static contract verification in particular. In the presence of these features, a modular analysis must permit code from the current module to escape permanently to an opaque context (unspecified code from outside the current module) that may be stateful and therefore store a reference to the escaped closure. Also, contracts themselves, being predicates written in unrestricted Racket, may exhibit stateful behavior; a sound approach must be robust to contracts which are arbitrarily expressive and interwoven with the code they monitor. In this paper, we present and evaluate our solution based on higher-order symbolic execution, explain the techniques we used to address such thorny issues, formalize a notion of behavioral approximation, and use it to provide a mechanized proof of soundness.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Phúc C.</first_name>
          <last_name>Nguyễn</last_name>
          <affiliation>University of Maryland</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl18.sigplan.org/getProfileImage/phucnguyen/fa918d3c-90fd-4629-880b-dfa4de159a3a/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Gilray</last_name>
          <affiliation>University of Maryland</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sam</first_name>
          <last_name>Tobin-Hochstadt</last_name>
          <affiliation>Indiana University</affiliation>
          <bio>I am an Assistant Professor in the Department of Computer Science at Indiana University.
Research Interests: my research focuses on the design and analysis of software and programming languages. I am particularly interested in how programs grow from prototype scripts to robust software, and how programming language design can support this process. My research concerns type systems, software contracts, modularity, and extensibility. I’m currently working with the DARPA CRASH program on Racket and with Mozilla Labs on JavaScript.</bio>
          <homepage_url>http://samth.github.io</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/samtobinhochstadt/d817e5c9-fe1c-4664-a4d1-6af45d4d4586/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>David</first_name>
          <last_name>Van Horn</last_name>
          <affiliation>University of Maryland</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.umd.edu/~dvanhorn/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/davidvanhorn/1683f65c-07ad-48e0-9e25-712586a45b51/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7c9c729d-6902-4937-a064-9fec17640b9e</slot_id>
      <title>Collapsing Towers of Interpreters</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/12</date>
      <start_time>11:45</start_time>
      <end_time>12:10</end_time>
      <description>Given a tower of interpreters, i.e., a sequence of multiple interpreters interpreting one another as input programs, we aim to collapse this tower into a compiler that removes all interpretive overhead and runs in a single pass. In the real world, a use case might be Python code executed by an x86 runtime, on a CPU emulated in a JavaScript VM, running on an ARM CPU. Collapsing such a tower can not only exponentially improve runtime performance, but also enable the use of base-language tools for interpreted programs, e.g., for analysis and verification. In this paper, we lay the foundations in an idealized but realistic setting.
We present a multi-level lambda calculus that features staging constructs and stage polymorphism: based on runtime parameters, an evaluator either executes source code (thereby acting as an interpreter) or generates code (thereby acting as a compiler). We identify stage polymorphism, a programming model from the domain of high-performance program generators, as the key mechanism to make such interpreters compose in a collapsible way.
We present Pink, a meta-circular Lisp-like evaluator on top of this calculus, and demonstrate that we can collapse arbitrarily many levels of self-interpretation, including levels with semantic modi cations. We discuss several examples: compiling regular expressions through an interpreter to base code, building program transformers from modified interpreters, and others. We develop these ideas further to include re reflection and reification, culminating in Purple, a reflective language inspired by Brown, Blond, and Black, which realizes a conceptually infinite tower, where every aspect of the semantics can change dynamically. Addressing an open challenge, we show how user programs can be compiled and recompiled under user-modified semantics.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nada</first_name>
          <last_name>Amin</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://namin.net</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/nadaamin/b083e70b-31f9-4a88-89ba-ae54f8ec9315/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tiark</first_name>
          <last_name>Rompf</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>Tiark Rompf is an assistant professor at Purdue University. His work focuses on runtime code generation, advanced compiler technology, and associated language support. From 2008 to 2014 he was a member of Martin Odersky’s Scala team at EPFL where he developed the LMS compiler framework and made various contributions to the Scala language and toolchain (delimited continuations, efficient immutable data structures, compiler speedups, type system work).</bio>
          <homepage_url>http://tiarkrompf.github.io/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/tiarkrompf/0262a01e-7fda-45b0-92d8-4ba269ad7997/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f5d03ce0-269e-4dfa-83de-ce7c828e8923</slot_id>
      <title>Correctness of Speculative Optimizations with Dynamic Deoptimization</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/12</date>
      <start_time>10:30</start_time>
      <end_time>10:55</end_time>
      <description>High-performance dynamic language implementations make heavy use of speculative optimizations to achieve speeds close to statically compiled languages. These optimizations are typically performed by a just-in-time compiler that generates code under a set of assumptions about the state of the program and its environment. In certain cases, a program may execute code compiled under assumptions that are no longer valid. The implementation must then deoptimize the program on-the-fly; this entails finding a semantically equivalent code fragment that does not rely on invalid assumptions, translating program state to that expected by the target code, and transferring control. This paper looks at the interaction between optimization and deoptimization, and shows that reasoning about speculation is surprisingly easy when assumptions are made explicit in the program representation. This insight is demonstrated on a compiler intermediate representation, named sourir, modeled after the high-level representation for a dynamic language. Traditional compiler optimizations such constant folding, dead code elimination and function inlining are shown to be correct in the presence of assumption. Furthermore, the paper establishes the correctness of compiler transformations specific to deoptimization: namely unrestricted deoptimization, predicate hoisting and assume composition.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Fluckiger</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl18.sigplan.org/getProfileImage/olivierfluckiger/6051271d-0eac-48f3-b931-bff878bbce61/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Gabriel</first_name>
          <last_name>Scherer</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://gallium.inria.fr/~scherer/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/gabrielscherer/12b45ebf-b3bf-4d6e-a8eb-fb44283475f9/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ming-Ho</first_name>
          <last_name>Yee</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://mhyee.com</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/minghoyee/08a14dbb-fa05-492f-8171-06194583eb87/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Aviral</first_name>
          <last_name>Goel</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl18.sigplan.org/getProfileImage/aviralgoel/aefb57df-77b4-45d0-aac2-1bda11fd94dd/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Amal</first_name>
          <last_name>Ahmed</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ccs.neu.edu/home/amal/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/amalahmed/301fd92b-d4ae-4998-8f6b-82cf081da653/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Jan</first_name>
          <last_name>Vitek</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>Jan Vitek is a Professor of Computer Science at Northeastern University. Dr. Vitek was born in Czechoslovakia and educated in Switzerland. Over the years, he worked on topics related to programming languages, their design, use, and implementation. With Noble and Potter, he proposed the notion of flexible alias control which became know as Ownership Types. He led the Ovm project which produced the first real-time Java virtual machine to be flight tested on a ScanEagle drone (he claims no one was harmed). Outcomes of this project include the Schism real-time garbage collector and the FijiVM – a production VM for embedded systems. More recently, he worked on dynamic languages, trying to make sense of JavaScript and to design a new language called, Thorn. Nowadays, he spends his time with statisticians and data scientists. Jan believes that his 2012 election as Chair of SIGPLAN was an accident; since has been busy trying to rock the boat to ensure this does not happen again. In his spare time, Jan enjoys organizing conferences and sitting on PCs (over 25 in the last decade). He founded the MOS (mobile objects), IWACO (alias control), STOP (gradual typing), and TRANSACT (transactional memory) workshop series. He was the first program chair of VEE and chaired ESOP, ECOOP, Coordination and TOOLS. He was the general chair of PLDI (in Beijing!), ISMM and LCTES. He may still be sitting on the steering committees of ECOOP, JTRES, ICFP, OOPLSA, POPL, PLDI, LCTES, ESOP.</bio>
          <homepage_url>http://janvitek.org</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/janvitek/213b9734-8942-47ea-933d-6ffad4bb1ee6/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>155ba45b-8ce5-41d2-a3b2-827018417d30</subevent_id>
    <title>Research Papers: Language Design</title>
    <subevent_type type="regular"/>
    <room>POPL-Track-1</room>
    <date>2018/01/11</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>542316b4-0a16-431b-8a96-5151e26c596c</slot_id>
      <title>Simplicitly: Foundations and Applications of Implicit Function Types</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/11</date>
      <start_time>16:15</start_time>
      <end_time>16:40</end_time>
      <description>Understanding a program entails understanding its context; dependencies, configurations and even implementations are all forms of contexts. Modern programming languages and theorem provers offer an array of constructs to define contexts, implicitly. Scala offers implicit parameters which are used pervasively, but which cannot be abstracted over.
This paper describes a generalization of implicit parameters to implicit function types, a powerful way to abstract over the context in which some piece of code is run. We provide a formalization based on bidirectional type-checking that closely follows the semantics implemented by the Scala compiler.
To demonstrate their range of abstraction capabilities, we present several applications that make use of implicit function types. We show how to encode the builder pattern, tagless interpreters, reader and free monads and we assess the performance of the monadic structures presented.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Martin</first_name>
          <last_name>Odersky</last_name>
          <affiliation>EPFL, Switzerland</affiliation>
          <bio>Martin Odersky is a professor at EPFL in Lausanne, Switzerland. He has been working on programming languages for most of his career. He first studied structured and object-oriented programming as a PhD student of Niklaus Wirth, then fell in love with functional programming while working as a post doc at IBM and Yale. When Java came out, he started to add functional programming constructs to the new platform. This led to Pizza and GJ and eventually to Java 5 with generics. During that time he also developed javac, the current reference compiler for Java.
Over the last 10 years, Martin worked on unifying object-oriented and functional programming in the Scala language. Scala quickly escaped from the research lab and became a popular open source tool and industrial language. He now oversees development of Scala as head of the programming group at EPFL and as academic director of the Scala center.</bio>
          <homepage_url>http://lampwww.epfl.ch/~odersky/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/martinodersky/fc1dd696-d0d4-47cb-9d9a-bba012d98f9e/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Olivier</first_name>
          <last_name>Blanvillain</last_name>
          <affiliation>EPFL</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Fengyun</first_name>
          <last_name>Liu</last_name>
          <affiliation>EPFL, Switzerland</affiliation>
          <bio>I’m a PhD student at EPFL. My interested areas are type systems, effect systems, programming languages, and various logics.</bio>
          <picture_url>https://popl18.sigplan.org/getProfileImage/fengyunliu/7967ca32-789c-44f7-a256-c5eae78909c1/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Aggelos</first_name>
          <last_name>Biboudis</last_name>
          <affiliation>Ecole Polytechnique Federale de Lausanne</affiliation>
          <bio>Postdoctoral Researcher at EPFL, LAMP
Interests: programming language design, stream oriented programming, staging/meta-programming.
@biboudis</bio>
          <homepage_url>http://biboudis.github.io/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/aggelosbiboudis/89ee406d-41be-466b-a4e8-bf4c6aef486d/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Heather</first_name>
          <last_name>Miller</last_name>
          <affiliation>Ecole Polytechnique Federale de Lausanne</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://heather.miller.am/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/heathermiller/a4b5f5d7-4b93-4536-9881-8c0574f75694/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Sandro</first_name>
          <last_name>Stucki</last_name>
          <affiliation>EPFL</affiliation>
          <bio>Sandro is a recent PhD graduate. He did his doctoral studies at the Programming Methods Laboratory (LAMP) at EPFL, supervised by Martin Odersky. His research interests include type systems and type theory, the design and semantics of domain-specific languages and formal methods for modeling systems biology. He is participating in the ongoing effort to formalize Scala’s type system and likes to hack on type soundness proofs and other theories in Agda.</bio>
          <homepage_url>https://sstucki.github.io/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/sandrostucki/4e64a916-bd68-410c-a42c-3f34ec621ed7/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>aae76b12-615d-4f9a-9c12-326ba02159f5</slot_id>
      <title>An Axiomatic Basis for Bidirectional Programming</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/11</date>
      <start_time>15:50</start_time>
      <end_time>16:15</end_time>
      <description>Among the frameworks of bidirectional transformations proposed for addressing various synchronisation (consistency maintenance) problems, Foster et al.’s [2007] asymmetric lenses have influenced the design of a generation of bidirectional programming languages. Most of these languages are based on a declarative programming model, and only allow the programmer to describe a consistency specification with ad hoc and/or awkward control over the consistency restoration behaviour. However, synchronisation problems are diverse and require vastly different consistency restoration strategies, and to cope with the diversity, the programmer must have the ability to fully control and reason about the consistency restoration behaviour. The putback-based approach to bidirectional programming aims to provide exactly this ability, and this paper strengthens the putback-based position by proposing the first fully fledged reasoning framework for a bidirectional language — a Hoare-style logic for Ko et al.’s [2016] putback-based language BiGUL. The Hoare-style logic lets the BiGUL programmer precisely characterise the bidirectional behaviour of their programs by reasoning solely in the putback direction, thereby offering a unidirectional programming abstraction that is reasonably straightforward to work with and yet provides full control not achieved by previous approaches. The theory has been formalised and checked in Agda, but this paper presents the Hoare-style logic in a semi-formal way to make it easily understood and usable by the working BiGUL programmer.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hsiang-Shang ‘Josh’</first_name>
          <last_name>Ko</last_name>
          <affiliation>National Institute of Informatics</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://josh-hs-ko.github.io</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/hsiangshangko/9c5db602-95a9-413b-a2d8-a4121be09c2c/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Zhenjiang</first_name>
          <last_name>Hu</last_name>
          <affiliation>National Institute of Informatics</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl18.sigplan.org/getProfileImage/zhenjianghu/5d426480-5589-46be-b4f6-f98cf2acc80e/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>bd25b8ae-4329-4222-b6f8-743843784bce</subevent_id>
    <title>Research Papers: Testing and Verification</title>
    <subevent_type type="regular"/>
    <room>POPL-Track-1</room>
    <date>2018/01/12</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>02a0061a-f234-430d-b0cf-5569d3d93663</slot_id>
      <title>On Automatically Proving the Correctness of math.h Implementations</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/12</date>
      <start_time>11:20</start_time>
      <end_time>11:45</end_time>
      <description>Industry standard implementations of {\tt math.h} claim (often without formal proof) tight bounds on floating-point errors. We demonstrate a novel static analysis that proves these bounds and verifies the correctness of these implementations. Our key insight is a reduction of this verification task to a set of mathematical optimization problems that can be solved by off-the-shelf computer algebra systems. We use this analysis to prove the correctness of implementations in Intel’s math library automatically. Prior to this work, these implementations could only be verified with significant manual effort.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Wonyeol</first_name>
          <last_name>Lee</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://wonyeol.com</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Rahul</first_name>
          <last_name>Sharma</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>Rahul Sharma is a researcher at Microsoft Research India. He received a Ph.D. in Computer Science from Stanford University, where he was advised by Prof. Alex Aiken. Before Stanford, he graduated with a B.Tech. from IIT Delhi. His research interests include program analysis, compilers, machine learning, and secure cloud computing.</bio>
          <homepage_url>http://cs.stanford.edu/people/sharmar</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/rahulsharma/6d60eca8-356f-4141-af5d-4c6af0fadcd8/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Alex</first_name>
          <last_name>Aiken</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>48e45ea1-0ab5-4a09-85a1-55819380ac63</slot_id>
      <title>Generating Good Generators for Inductive Relations</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/12</date>
      <start_time>10:30</start_time>
      <end_time>10:55</end_time>
      <description>Property-based random testing (PBRT) is widely used in the functional programming and verification communities. For testing simple properties, PBRT tools such as QuickCheck can automatically generate random inputs of a given type. But for more complex properties, effective testing often demands generators for random inputs that belong to a given type and satisfy some logical condition. QuickCheck provides a library of combinators for building such generators by hand, but this can be tedious for simple conditions and error prone for more complex ones. Fortunately, the process can often be automated. The most prominent method, narrowing, works by traversing the structure of the condition, lazily instantiating parts of the data structure as constraints involving them are met.
We show how to use ideas from narrowing to compile a large subclass of Coq’s inductive relations into efficient generators, avoiding the interpretive overhead of previous implementations. More importantly, the same compilation technique allows us to produce proof terms certifying that each derived generator is good—i.e., sound and complete with respect to the inductive relation it was derived from. We implement our algorithm as an extension of QuickChick, an existing tool for property-based testing in Coq. We evaluate our method by automatically deriving good generators for the majority of the specifications in Software Foundations, a formalized textbook on programming language foundations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Leonidas</first_name>
          <last_name>Lampropoulos</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cis.upenn.edu/~llamp/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/leonidaslampropoulos/0533948d-2e45-449e-b1d5-5fe451706ede/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Zoe</first_name>
          <last_name>Paraskevopoulou</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://zoep.github.io/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benjamin C.</first_name>
          <last_name>Pierce</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>Benjamin Pierce is Henry Salvatori Professor of Computer and Information Science at the University of Pennsylvania and a Fellow of the ACM. His research interests include programming languages, type systems, language-based security, computer-assisted formal verification, differential privacy, and synchronization technologies. He is the author of the widely used graduate textbooks Types and Programming Languages and Software Foundations. He has served as co-Editor in Chief of the Journal of Functional Programming, as Managing Editor for Logical Methods in Computer Science, and as editorial board member of Mathematical Structures in Computer Science, Formal Aspects of Computing, and ACM Transactions on Programming Languages and Systems. He is also the lead designer of the popular Unison file synchronizer.</bio>
          <homepage_url>http://www.cis.upenn.edu/~bcpierce/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/benjamincpierce/f2ee6f41-5bf7-4a0d-9b8d-71de6a666b1b/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7cc473c8-7807-4daf-b640-b16c87fd5bbc</slot_id>
      <title>Why is Random Testing Effective for Partition Tolerance Bugs?</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/12</date>
      <start_time>10:55</start_time>
      <end_time>11:20</end_time>
      <description>Random testing has proven to be an extremely effective way to catch subtle bugs in distributed systems in the presence of network partition faults. This is surprising, as the space of potentially faulty executions is enormous, and the bugs depend on a subtle interplay between sequences of operations and faults.
We provide a theoretical justification of the effectiveness of random testing in this context. First, we show a general construction, using the probabilistic method from combinatorics, that shows that whenever a random test covers a fixed coverage goal with sufficiently high probability, there is a small set of random tests which achieves full coverage with high probability. In particular, we show that our construction can give test sets exponentially smaller than systematic enumeration. Second, based on an empirical study of many bugs found by random testing in production distributed systems, we introduce notions of test coverage relating to network partition faults which are effective in finding bugs. Finally, we show using combinatorial arguments that for these notions of test coverage we introduce, we can find a lower bound on the probability that a random test covers a given goal. Our general construction then explains why random testing tools achieve good coverage—and hence, find bugs—quickly.
While we formulate our results in terms of network partition faults, our construction provides a step towards rigorous analysis of random testing algorithms. We demonstrate that several other random testing approaches in the literature can be explained using our main result.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Rupak</first_name>
          <last_name>Majumdar</last_name>
          <affiliation>MPI-SWS</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-sws.org/~rupak</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/rupakmajumdar/3289b197-9f9a-4880-94c5-d9cf6d764bb1/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Filip</first_name>
          <last_name>Niksic</last_name>
          <affiliation>MPI-SWS</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9973ea48-e42f-4ba3-b115-92a4647e3a01</slot_id>
      <title>Online Detection of Effectively Callback Free Objects with Applications to Smart Contracts</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/12</date>
      <start_time>11:45</start_time>
      <end_time>12:10</end_time>
      <description>Callbacks are essential in many programming environments, but drastically complicate program understanding and reasoning because they allow to mutate object’s local states by external objects in unexpected fashions, thus breaking modularity. The famous DAO bug in the cryptocurrency framework \emph{Ethereum}, employed callbacks to steal $150M. We define the notion of Effectively Callback Free (ECF) objects in order to allow callbacks without preventing modular reasoning.
An object is ECF in a given execution trace if there exists an equivalent execution trace without callbacks to this object. An object is ECF if it is ECF in every possible execution trace. We study the decidability of dynamically checking ECF in a given execution trace and statically checking if an object is ECF. We also show that dynamically checking ECF in Ethereum is feasible and can be done online. By running the history of all execution traces in Ethereum, we were able to verify that virtually all existing contracts, excluding the DAO or contracts with similar known vulnerabilities, are ECF. Finally, we show that ECF, whether it is verified dynamically or statically, enables modular reasoning about objects with encapsulated state.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shelly</first_name>
          <last_name>Grossman</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl18.sigplan.org/getProfileImage/shellygrossman/c4b389a6-6165-44ef-a938-4b1acbecaaa8/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ittai</first_name>
          <last_name>Abraham</last_name>
          <affiliation>VMWare Research</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Guy</first_name>
          <last_name>Golan-Gueta</last_name>
          <affiliation>VMWare Research</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yan</first_name>
          <last_name>Michalevsky</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.stanford.edu/~yanm2</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/yanmichalevsky/3c304ec6-53b4-48a9-b3a8-b4af9f8327b3/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Noam</first_name>
          <last_name>Rinetzky</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~maon/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/noamrinetzky/1ea9bd0d-bd16-4b15-bb66-a8a576ffaa40/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Mooly</first_name>
          <last_name>Sagiv</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Yoni</first_name>
          <last_name>Zohar</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>3a592152-378c-4f32-b7cd-956a7d8acd3b</subevent_id>
    <title>Research Papers: Probability</title>
    <subevent_type type="regular"/>
    <room>POPL-Track-2</room>
    <date>2018/01/12</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>1e30d192-ee06-437f-ae6d-389d1fb89c02</slot_id>
      <title>Denotational validation of higher-order Bayesian inference</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/12</date>
      <start_time>14:55</start_time>
      <end_time>15:20</end_time>
      <description>We present a modular semantic account of Bayesian inference algorithms for probabilistic programming languages, as used in Bayesian data science and machine learning. Sophisticated inference algorithms are often explained in terms of composition of smaller parts. However, neither their theoretical justification nor their implementation reflects this modularity. We show how to conceptualise and analyse such inference algorithms as manipulating intermediate representations of probabilistic programs using higher-order functions and inductive types, and their denotational semantics.
Semantic accounts of continuous distributions use measurable spaces. However, our use of higher-order functions presents a substantial technical difficulty: it is impossible to define a measurable space structure over the collection of measurable functions between arbitrary measurable spaces that is compatible with standard operations on those functions, such as function application. We overcome this difficulty using quasi-Borel spaces, a recently proposed mathematical structure that supports both function spaces and continuous distributions.
We define a class of semantic structures for representing probabilistic programs, and semantic validity criteria for transformations of these representations in terms of distribution preservation. We develop a collection of building blocks for composing representations. We use these building blocks to validate common inference algorithms such as Sequential Monte Carlo and Markov Chain Monte Carlo. To emphasize the connection between the semantic manipulation and its traditional measure theoretic origins, we use Kock’s synthetic measure theory. We demonstrate its usefulness by proving a quasi-Borel counterpart to the Metropolis-Hastings-Green theorem. Finally, although not discussed in the paper, we provide an implementation of the concepts described in this paper as a Haskell library.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Adam</first_name>
          <last_name>Ścibior</last_name>
          <affiliation>University of Cambridge and MPI Tuebingen</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://mlg.eng.cam.ac.uk/adam/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ohad</first_name>
          <last_name>Kammar</last_name>
          <affiliation>University of Oxford</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ox.ac.uk/people/ohad.kammar/main.html</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/ohadkammar/1336a5cb-4d72-49de-898d-ce768d425a55/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Matthijs</first_name>
          <last_name>Vákár</last_name>
          <affiliation>University of Oxford</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl18.sigplan.org/getProfileImage/matthijsvakar/41a8f9d6-0c06-4001-99a9-fb316abcf3ac/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Sam</first_name>
          <last_name>Staton</last_name>
          <affiliation>University of Oxford</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ox.ac.uk/people/samuel.staton/main.html</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Hongseok</first_name>
          <last_name>Yang</last_name>
          <affiliation>University of Oxford</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ox.ac.uk/people/hongseok.yang/Public/Home.html</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/hongseokyang/852e33b1-6c2a-41bf-9e12-cccadbf70d70/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Yufei</first_name>
          <last_name>Cai</last_name>
          <affiliation>University of Tuebingen</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Klaus</first_name>
          <last_name>Ostermann</last_name>
          <affiliation>University of Tuebingen</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ps.informatik.uni-tuebingen.de/team/ostermann/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/klausostermann/3b2188f0-6472-4a18-b97c-765414c990c8/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Sean K.</first_name>
          <last_name>Moss</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>9</sort_key>
          <first_name>Chris</first_name>
          <last_name>Heunen</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/cheunen/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>10</sort_key>
          <first_name>Zoubin</first_name>
          <last_name>Ghahramani</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://mlg.eng.cam.ac.uk/zoubin/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>248df186-8f10-4655-b85d-3c14e2167bc3</slot_id>
      <title>Synthesizing Coupling Proofs of Differential Privacy</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/12</date>
      <start_time>14:05</start_time>
      <end_time>14:30</end_time>
      <description>In this paper, we present a push-button, automated technique for verifying $\epsilon$-differential privacy of sophisticated randomized algorithms. We make a range of conceptual, algorithmic,and practical contributions: (1) Inspired by the recent advances on approximate couplings and randomness alignment, we present a new proof technique called coupling strategies, which casts differential privacy proofs as discovering a strategy in a game where we have finite privacy resources to expend. (2) To discover a winning strategy, we present a constraint-based formulation of the problem as solving a set of Horn modulo couplings (HMC) constraints, a novel kind of constraints combining first-order Horn clauses with probabilistic constraints. (3) We present a technique for solving HMC constraints by transforming probabilistic constraints into logical constraints with uninterpreted functions. (4) Finally, we implement our technique and provide the first automated proofs of a number of algorithms from the differential privacy literature, including Report Noisy Max, the Exponential Mechanism, and the Sparse Vector Mechanism.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aws</first_name>
          <last_name>Albarghouthi</last_name>
          <affiliation>University of Wisconsin-Madison</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl18.sigplan.org/getProfileImage/awsalbarghouthi/3a3382aa-47f5-4e02-ac71-509eb94703ff/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Justin</first_name>
          <last_name>Hsu</last_name>
          <affiliation>University College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.justinh.su</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/justinhsu/a2c25b60-0dc3-48ad-a41d-238071e3fbab/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>892abf3e-c7d3-48d4-bf49-acd001b13fef</slot_id>
      <title>Measurable cones and stable, measurable functions</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/12</date>
      <start_time>14:30</start_time>
      <end_time>14:55</end_time>
      <description>We define a notion of stable and measurable map between cones endowed with measurability tests and show that it forms a cpo-enriched cartesian closed category. This category gives the first denotational model of an extension of PCF supporting the main primitives of probabilistic functional programming, like continuous and discrete probabilistic distributions, sampling, conditioning and full recursion. We prove the soundness and adequacy of this model with respect to a call-by-name operational semantics and give some examples of its denotations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Ehrhard</last_name>
          <affiliation>CNRS and University Paris Diderot</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michele</first_name>
          <last_name>Pagani</last_name>
          <affiliation>University Paris Diderot</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.irif.fr/~michele/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/michelepagani/b95489cb-5699-4224-9b57-f73a1be75efd/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Christine</first_name>
          <last_name>Tasson</last_name>
          <affiliation>University Paris Diderot</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e1cf294d-48e1-4293-bb88-3b82953b6829</slot_id>
      <title>Proving expected sensitivity of probabilistic programs</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/12</date>
      <start_time>13:40</start_time>
      <end_time>14:05</end_time>
      <description>Program sensitivity, also known as Lipschitz continuity, describes how small changes in a program’s input lead to bounded changes in the output. We propose an average notion of program sensitivity for probabilistic programs—expected sensitivity—that averages a distance function over a probabilistic coupling of the two output distributions from two nearby inputs. By varying the distance functions, expected sensitivity captures useful notions of probabilistic function sensitivity, including algorithmic stability of machine learning algorithms and convergence of Markov chains.
Furthermore, expected sensitivity satisfies clean compositional properties and is amenable to formal verification. We develop a relational program logic called ExSeL for proving expected sensitivity properties, featuring two key components. First, relational pre-conditions and post-conditions are expressed using distances, which can be seen as a real-valued generalization of typical boolean-valued (relational) assertions. Second, judgments —with distances as pre-conditions and post-conditions— are interpreted in terms of expectation coupling, a novel, quantitative generalization of probabilistic couplings which supports compositional reasoning.
We demonstrate our logic on two classes of examples: uniform stability of the Stochastic Gradient Method algorithm from machine learning, and rapid mixing for a model of asexual population dynamics. We also extend our logic with a transitivity principle for expectation couplings to capture the path coupling, and we demonstrate our extension by proving rapid mixing of the Glauber dynamics from statistical physics.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gilles</first_name>
          <last_name>Barthe</last_name>
          <affiliation>IMDEA Software Institute</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://software.imdea.org/~gbarthe/index.html</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Espitau</last_name>
          <affiliation>Universite Pierre et Marie Curie</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benjamin</first_name>
          <last_name>Gregoire</last_name>
          <affiliation>INRIA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www-sop.inria.fr/members/Benjamin.Gregoire/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Justin</first_name>
          <last_name>Hsu</last_name>
          <affiliation>University College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.justinh.su</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/justinhsu/a2c25b60-0dc3-48ad-a41d-238071e3fbab/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Pierre-Yves</first_name>
          <last_name>Strub</last_name>
          <affiliation>Ecole Polytechnique</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.strub.nu/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/pierreyvesstrub/da650c05-b1b5-4167-911c-ac0ee26a27f1/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9ef2914c-09bc-4e24-adc9-e43a18807689</subevent_id>
    <title>Research Papers: Program Analysis I</title>
    <subevent_type type="regular"/>
    <room>POPL-Track-2</room>
    <date>2018/01/11</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>43439f45-e2e1-4847-bfb0-ac86952e6770</slot_id>
      <title>Analytical Modeling of Cache Behavior for Affine Programs</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/11</date>
      <start_time>11:45</start_time>
      <end_time>12:10</end_time>
      <description>Modern optimizing compiler design integrates program transformation strategies aimed at reducing data movement to/from main memory, exploiting the data cache hierarchy. But in reality, the effect of these transformations on the actual cache miss count is ignored in compilers, due to the lack of precise compile-time models of misses for hierarchical caches. Going a step further, when considering real-life systems, the data is vulnerable to hardware faults (e.g., bit flip) when it is stored in a cache without automatic error detection/correction. Determining the cache vulnerability of a program requires the computation of the lifetime of each data element in the cache, and the current state of practice for both cache miss analysis as well as vulnerability analysis is based on accurate simulation.
This paper takes a fundamentally different approach, made possible by focusing on polyhedral programs with static control flow: instead of relying on costly simulation, this paper develops the first closed-form solution for exact modeling of misses in a set-associative cache hierarchy. It then develops the first closed-form solution to cache vulnerability analysis for general polyhedral programs, enabling simulation-less selection of program transformations at compile-time to optimize cache misses, vulnerability, or a mix of both. A push-button tool implementing the approach is developed and used for extensive validation of the complete framework.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Wenlei</first_name>
          <last_name>Bao</last_name>
          <affiliation>Ohio State University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sriram</first_name>
          <last_name>Krishnamoorthy</last_name>
          <affiliation>Pacific Northwest National Laboratories</affiliation>
          <bio>Sriram Krishnamoorthy currently is a research scientist and the System Software and Applications Team Leader in PNNL’s High Performance Computing group, where he focuses on parallel programming models, fault tolerance, and compile-time/runtime optimizations for high-performance computing. He has more than 80 peer-reviewed conference and journal publications, receiving Best Paper awards for his publications at the International Conference on High Performance Computing (HiPC’03) and the International Parallel and Distributed Processing Symposium (IPDPS’04). In 2013, he received a U.S. Department of Energy Early Career award. That year, he also earned PNNL’s Ronald L. Brodzinski Award for Early Career Exceptional Achievement. In 2008, he received The Ohio State University’s Outstanding Researcher award. Dr. Krishnamoorthy is a senior member of the Institute of Electrical and Electronics Engineers. He earned his B.E. from the College of Engineering, Guindy (Chennai, India) and M.S. and Ph.D. degrees from The Ohio State University.</bio>
          <homepage_url>http://hpc.pnl.gov/people/sriram/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/sriramkrishnamoorthy/473cc601-1284-4417-bc71-6230b1548b0a/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Louis-Noel</first_name>
          <last_name>Pouchet</last_name>
          <affiliation>Colorado State University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl18.sigplan.org/getProfileImage/louisnoelpouchet/d72d9a63-a296-4c80-bb9e-201cf64a0294/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>P.</first_name>
          <last_name>Sadayappan</last_name>
          <affiliation>Ohio State University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.cse.ohio-state.edu/~saday/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b3418ef4-88bc-49b9-8cbe-7e0369609d17</slot_id>
      <title>Inference of Static Semantics for Incomplete C Programs</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/11</date>
      <start_time>10:30</start_time>
      <end_time>10:55</end_time>
      <description>Incomplete source code naturally emerges in software development: during design phase, while evolving, testing and analyzing programs. Therefore, the ability to understand partial programs is a valuable asset. However, this problem is still unsolved in the C programming language. Difficulties stem from the fact that parsing C requires, not only syntax, but also semantic information. Furthermore, inferring types so that they respect C’s type system is a challenging task. In this paper we present a technique the lets us solve these problems. We provide a unification-based type inference capable of dealing with C intricacies. The ideas we present let us reconstruct partial C programs into complete well-typed ones. Such program reconstruction has several applications: enabling static-analysis tools in scenarios where software components may be absent; improving static-analysis tools that do not rely on build-specifications; allowing stub-generation and testing tools to work on snippets; and assisting programmers on the extraction of reusable data-structures out of the program parts that use them. Our evaluation is performed on source code from a variety of C libraries such as GNU’s Coreutils, GNULib, GNOME’s GLib, GDSL, and igraph; on implementations from Sedgewick’s books; and on snippets from popular open-source projects like CPython, FreeBSD, and Git.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Leandro T. C.</first_name>
          <last_name>Melo</last_name>
          <affiliation>UFMG</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ltcmelo.com/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/leandrotcmelo/c77431a9-b47a-433f-87fb-0fdc7fa053b5/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Rodrigo Geraldo</first_name>
          <last_name>Ribeiro</last_name>
          <affiliation>UFOP</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Marcus Rodrigues</first_name>
          <last_name>de Araújo</last_name>
          <affiliation>UFMG</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Fernando Magno Quintão</first_name>
          <last_name>Pereira</last_name>
          <affiliation>UFMG</affiliation>
          <bio>Fernando got his Ph.D at UCLA in 2008, under the supervision of Jens Palsberg. He is currently an assistant professor at the Universidade Federal de Minas Gerais, Brazil. His main research interest are in code generation, compiler optimizations and static program analyses.</bio>
          <homepage_url>http://homepages.dcc.ufmg.br/~fernando/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/fernandomagnoquintaopereira/8f86b14f-fbc3-49a4-9f4f-1a8216564d39/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>efb25fd1-07ac-499e-b6fc-b1bf11871b4a</slot_id>
      <title>Data-centric Dynamic Partial Order Reduction</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/11</date>
      <start_time>11:20</start_time>
      <end_time>11:45</end_time>
      <description>We present a new dynamic partial-order reduction method for stateless model checking of concurrent programs. A common approach for exploring program behaviors relies on enumerating the traces of the program, without storing the visited states (aka stateless exploration). As the number of distinct traces grows exponentially, dynamic partial-order reduction (DPOR) techniques have been successfully used to partition the space of traces into equivalence classes (Mazurkiewicz partitioning), with the goal of exploring only few representative traces from each class.
We introduce a new equivalence on traces under sequential consistency semantics, which we call the observation equivalence. Two traces are observationally equivalent if every read event observes the same write event in both traces. While the traditional Mazurkiewicz equivalence is control-centric, our new definition is data-centric. We show that our observation equivalence is coarser than the Mazurkiewicz equivalence, and in many cases even exponentially coarser. We devise a DPOR exploration of the trace space, called data-centric DPOR, based on the observation equivalence.

  For acyclic architectures, our algorithm is guaranteed to explore exactly one representative trace from each observation class, while spending polynomial time per class. Hence, our algorithm is optimal wrt the observation equivalence, and in several cases explores exponentially fewer traces than any enumerative method based on the Mazurkiewicz equivalence.
  For cyclic architectures, we consider an equivalence between traces which is finer than the observation equivalence; but coarser than the Mazurkiewicz equivalence, and in some cases is exponentially coarser. Our data-centric DPOR algorithm remains optimal under this trace equivalence.

Finally, we perform a basic experimental comparison between the recently introduced, Mazurkiewicz-based source-DPOR and our data-centric DPOR. Our results show a significant reduction in both running time and the number of explored equivalence classes.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Marek</first_name>
          <last_name>Chalupa</last_name>
          <affiliation>Masaryk University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Krishnendu</first_name>
          <last_name>Chatterjee</last_name>
          <affiliation>IST Austria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pub.ist.ac.at/~kchatterjee/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Andreas</first_name>
          <last_name>Pavlogiannis</last_name>
          <affiliation>IST Austria</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Kapil</first_name>
          <last_name>Vaidya</last_name>
          <affiliation>IIT Bombay</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Nishant</first_name>
          <last_name>Sinha</last_name>
          <affiliation>IBM Research</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f642d95e-a4e5-49d4-80b7-0568d61b7916</slot_id>
      <title>Optimal Dyck Reachability for Data-dependence and Alias Analysis</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/11</date>
      <start_time>10:55</start_time>
      <end_time>11:20</end_time>
      <description>A fundamental algorithmic problem at the heart of static analysis is Dyck reachability. The input is a graph where the edges are labeled with different types of opening and closing parentheses, and the reachability information is computed via paths whose parentheses are properly matched. We present new results for Dyck reachability problems with applications to alias analysis and data-dependence analysis. Our main contributions, that include improved upper bounds as well as lower bounds that establish optimality guarantees, are as follows:
First, we consider Dyck reachability on bidirected graphs, which is the standard way of performing field-sensitive points-to analysis. Given a bidirected graph with $n$ nodes and $m$ edges, we present: (i)~an algorithm with worst-case running time $O(m + n \cdot \alpha(n))$, where $\alpha(n)$ is the inverse Ackermann function, improving the previously known $O(n^2)$ time bound; (ii)~a matching lower bound that shows that our algorithm is optimal wrt to worst-case complexity; and (iii)~an optimal average-case upper bound of $O(m)$ time, improving the previously known $O(m \cdot \log n)$ bound.
Second, we consider the problem of context-sensitive data-dependence analysis, where the task is to obtain analysis summaries of library code in the presence of callbacks. Our algorithm preprocesses libraries in almost linear time, after which the contribution of the library in the complexity of the client analysis is only linear, and only wrt the number of call sites.
Third, we prove that combinatorial algorithms for Dyck reachability on general graphs with truly sub-cubic bounds cannot be obtained without obtaining sub-cubic combinatorial algorithms for Boolean Matrix Multiplication, which is a long-standing open problem. Thus we establish that the existing combinatorial algorithms for Dyck reachability are (conditionally) optimal for general graphs.
Finally, we provide a prototype implementation of our algorithms for both alias analysis and data-dependence analysis. Our experimental evaluation demonstrates that the new algorithms significantly outperform all existing methods on the two problems, over real-world benchmarks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Krishnendu</first_name>
          <last_name>Chatterjee</last_name>
          <affiliation>IST Austria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pub.ist.ac.at/~kchatterjee/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andreas</first_name>
          <last_name>Pavlogiannis</last_name>
          <affiliation>IST Austria</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bhavya</first_name>
          <last_name>Choudhary</last_name>
          <affiliation>IIT Bombay</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>489b4100-b2dd-4160-bfc2-3dbcc5ea10be</subevent_id>
    <title>Research Papers: Program Analysis II</title>
    <subevent_type type="regular"/>
    <room>POPL-Track-1</room>
    <date>2018/01/12</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>43aba9ca-b955-4530-a2b6-ce3b4a1ff5f0</slot_id>
      <title>A Practical Construction for Decomposing Numerical Abstract Domains</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/12</date>
      <start_time>14:30</start_time>
      <end_time>14:55</end_time>
      <description>Numerical abstract domains such as Polyhedra, Octahedron, Octagon, Interval, and others are an essential component of static program analysis. The choice of domain offers a performance/precision tradeoff ranging from cheap and imprecise (Interval) to expensive and precise (Polyhedra). Recently, significant speedups were achieved for Octagon and Polyhedra by manually decomposing their transformers to work with the Cartesian product of projections associated with partitions of the variable set. While practically useful, this manual process is extremely time consuming, error-prone and has to be applied from scratch for every domain.
In this paper, we present a novel approach that can soundly decompose any sub-polyhedra domain. Unlike prior work, the method is generic in nature and does not require changes to the original abstract transformers or additional manual effort per domain. Further, it presents guarantees on the partitions achievable by each decomposed transformer. In general, our method achieves finer partitions than prior work.
We implemented our approach and applied it to the domains of Zones, Octagon, and Polyhedra. We then compared the performance of the decomposed transformers obtained with our generic method versus state-of-the art PPL and the faster ELINA (which uses manual decomposition). Against the latter we demonstrate finer partitions and an associated speedup of about 2x on average. Our results indicate that the construction presented in this work is a viable method for improving the performance of numerical domains. It enables designers of abstract domains to benefit from decomposition without re-writing all of their transformers from scratch (as required by prior methods).</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gagandeep</first_name>
          <last_name>Singh</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Markus</first_name>
          <last_name>Püschel</last_name>
          <affiliation>ETH Zürich</affiliation>
          <bio>Markus Püschel is a Professor and former Department Head of Computer Science at ETH Zurich, Switzerland. Before, he was a Professor of Electrical and Computer Engineering at Carnegie Mellon University, where he still has an adjunct status. He received his Diploma (M.Sc.) in Mathematics and his Doctorate (Ph.D.) in Computer Science, in 1995 and 1998, respectively, both from the University of Karlsruhe, Germany.</bio>
          <homepage_url>http://people.inf.ethz.ch/markusp/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/markuspuschel/531dfe05-df8b-4f25-acb6-59ea5e4e59ea/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Martin</first_name>
          <last_name>Vechev</last_name>
          <affiliation>ETH Zürich</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.srl.inf.ethz.ch/vechev.php</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/martinvechev/4ae74bfd-22ac-4e29-a171-3fc706a85e3a/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6e9d7b4b-d1a3-4217-b0f4-8c7b7f902968</slot_id>
      <title>Verifying Equivalence of Database-Driven Applications</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/12</date>
      <start_time>14:55</start_time>
      <end_time>15:20</end_time>
      <description>This paper addresses the problem of verifying equivalence between a pair of programs that operate over databases with different schemas. This problem is particularly important in the context of web applications, which typically undergo database refactoring either for performance or maintainability reasons. While the web application should have the same externally observable behavior before and after schema migration, there are no existing tools for proving equivalence of such programs. This paper takes a first step towards solving this problem by formalizing the equivalence and refinement checking problems for database-driven applications. We then propose a proof methodology based on the notion of bisimulation invariants over a new logic called the theory of relational algebra with updates. We also present a fully automated technique for synthesizing such bisimulation invariants and automatically verify their correctness. We have implemented the proposed technique in a tool called Mediator and show that it can verify the equivalence of real-world web applications containing hundreds of transactions.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yuepeng</first_name>
          <last_name>Wang</last_name>
          <affiliation>University of Texas at Austin</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Isil</first_name>
          <last_name>Dillig</last_name>
          <affiliation>UT Austin</affiliation>
          <bio>Isil Dillig is an Associate Professor of Computer Science at the University of Texas at Austin where she leads the UToPiA research group. Her main research area is programming languages, with a specific emphasis on static analysis, verification, and program synthesis. The techniques developed by her group aim to make software systems more reliable, secure, and easier to build in a robust way. Dr. Dillig is a Sloan Fellow and a recipient of the NSF CAREER award. She obtained all her degrees (BS, MS, and PhD) from Stanford University.</bio>
          <homepage_url>http://www.cs.utexas.edu/~isil/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/isildillig/e4fa3855-0ae4-4638-84e3-1fe224e64e3f/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Shuvendu K.</first_name>
          <last_name>Lahiri</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>William</first_name>
          <last_name>Cook</last_name>
          <affiliation>University of Texas at Austin</affiliation>
          <bio>William Cook is an Associate Professor in the Department of Computer Sciences at the University of Texas at Austin. His research is focused on object-oriented programming, programming languages, modeling languages, and the interface between programming languages and databases. Prior to joining UT in 2003, Dr. Cook was Chief Technology Officer and co-founder of Allegis Corporation. He was chief architect for several award-winning products, including the eBusiness Suite at Allegis, the Writer’s Solution for Prentice Hall, and the AppleScript language at Apple Computer. At HP Labs his research focused on the foundations of object-oriented languages, including formal models of mixins, inheritance, and typed models of object-oriented languages. He completed his Ph.D. in Computer Science at Brown University in 1989.</bio>
          <homepage_url>http://www.cs.utexas.edu/~wcook/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/williamcook/4b24e66e-5549-43f6-8e13-8010da47a4bf/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c45137ea-9b6b-4467-a9b3-dd17849a3f84</slot_id>
      <title>Refinement Reflection: Complete Verification with SMT</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/12</date>
      <start_time>13:40</start_time>
      <end_time>14:05</end_time>
      <description>We introduce Refinement Reflection, a new framework for building SMT-based deductive verifiers. The key idea is to reflect the code implementing a user-defined function into the function’s (output) refinement type. As a consequence, at uses of the function, the function definition is instantiated in a precise fashion that permits decidable verification. We show how reflection allows the user to write equational proofs of programs just by writing other programs e.g., using pattern-matching and recursion to perform case-splitting and induction. Thus, via, the propositions-as-types principle we show that reflection permits the specification of arbitrary functional correctness properties. While equational proofs are easy, writing them out can be exhausting. We introduce a proof-search algorithm called Proof by Logical Evaluation that uses techniques from model checking and abstract interpretation, to completely automate equational reasoning. We have implemented reflection in Liquid Haskell and used it to verify that the widely used instances of the Monoid, Applicative, Functor, and Monad typeclasses actually satisfy key algebraic laws required to make the clients safe, and to build the first library that actually verifies assumptions about associativity and ordering that are crucial for safe deterministic parallelism.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Niki</first_name>
          <last_name>Vazou</last_name>
          <affiliation>University of Maryland</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://nikivazou.github.io/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/nikivazou/8cc6ddec-154b-47e9-b40d-c66e78476391/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Anish</first_name>
          <last_name>Tondwalkar</last_name>
          <affiliation>UCSD</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ani.sh</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/anishtondwalkar/99a3d2db-c710-43a2-9f11-e8d6700f548b/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Vikraman</first_name>
          <last_name>Choudhury</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ryan</first_name>
          <last_name>Scott</last_name>
          <affiliation>Indiana University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ryanglscott.github.io/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/ryanscott/4e3ab376-a146-4946-9e77-752c3ed3aab5/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ryan R.</first_name>
          <last_name>Newton</last_name>
          <affiliation>Indiana University</affiliation>
          <bio>From South Florida. Ph.D. 2009 at MIT.</bio>
          <homepage_url>http://cs.indiana.edu/~rrnewton</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/ryanrnewton/4dff7d06-8ca4-46f3-981b-52049bc71c54/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Philip</first_name>
          <last_name>Wadler</last_name>
          <affiliation>University of Edinburgh, UK</affiliation>
          <bio>Philip Wadler is Professor of Theoretical Computer Science at the University of Edinburgh. He is an ACM Fellow and a Fellow of the Royal Society of Edinburgh, past chair of ACM SIGPLAN, past holder of a Royal Society-Wolfson Research Merit Fellowship, winner of the SIGPLAN Distinguished Service Award, and a winner of the POPL Most Influential Paper Award. Previously, he worked or studied at Stanford, Xerox Parc, CMU, Oxford, Chalmers, Glasgow, Bell Labs, and Avaya Labs, and visited as a guest professor in Copenhagen, Sydney, and Paris. He has an h-index of 60, with more than 20,000 citations to his work according to Google Scholar. He contributed to the designs of Haskell, Java, and XQuery, and is a co-author of Introduction to Functional Programming (Prentice Hall, 1988), XQuery from the Experts (Addison Wesley, 2004) and Generics and Collections in Java (O’Reilly, 2006). He has delivered invited talks in locations ranging from Aizu to Zurich.</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/wadler/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/philipwadler/55a9683e-908b-4052-9d49-20fb795c74cf/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Ranjit</first_name>
          <last_name>Jhala</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>Nom nom. Chomp. Burp.</bio>
          <homepage_url>http://ranjitjhala.github.io</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/ranjitjhala/afbdab69-ed23-4022-b7a4-2c57128f20ec/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f2632e39-3173-4163-9838-931d921a460a</slot_id>
      <title>Non-Linear Reasoning For Invariant Synthesis</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/12</date>
      <start_time>14:05</start_time>
      <end_time>14:30</end_time>
      <description>The ability of program-analysis tools to identify program invariants is hampered by the capabilities of present-day solvers for handling non-linear arithmetic—including polynomials, exponentials, and logarithms. Improved capabilities for reasoning about non-linear functions would help program analyzers establish important program invariants. For instance, reasoning about exponentials provides a way to find invariants of digital-filter programs; reasoning about polynomials and/or logarithms is needed for establishing invariants that describe the time or memory usage of many well-known algorithms. This paper describes the techniques used in an arithmetic-reasoning kit to represent logarithmic and exponential relationships indirectly, using uninterpreted-function symbols and integrity constraints. It also describes a recurrence-relation solver—used to find invariants of loops—that handles two classes of recurrences: * Ones of the form $x_{n+1} = b*x_n + f(n)$, where $b$ is a constant, and $f(n)$ is a sum of polynomials, exponentials, or products of a polynomial and an exponential. * Ones of the form $\mathbf{y_{n+1}} = \mathbf{A}\mathbf{y_n} + \mathbf{f(n)}$, where $\mathbf{y_n}$ is a vector of variables, $\mathbf{A}$ is a rational matrix, and $\mathbf{f(n)}$ is a vector of functions, where each entry is a sum of polynomials, exponentials, or products of a polynomial and an exponential.
Our technique has been implemented in a program analyzer that can analyze general loops—including loops that contain branches and nested loops—and mutually recursive functions. Our experiments show that our technique shows promise for non-linear assertion-checking and resource-bound generation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Zachary</first_name>
          <last_name>Kincaid</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.princeton.edu/~zkincaid</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/zacharykincaid/a26b486e-94a5-45f1-a8b3-9a2221495ff7/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>John</first_name>
          <last_name>Cyphert</last_name>
          <affiliation>University of Wisconsin - Madison</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jason</first_name>
          <last_name>Breck</last_name>
          <affiliation>University of Wisconsin - Madison</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Reps</last_name>
          <affiliation>University of Wisconsin - Madison and GrammaTech, Inc.</affiliation>
          <bio>Thomas W. Reps is the J. Barkley Rosser Professor &amp;amp; Rajiv and Ritu Batra Chair in the Computer Sciences Department of the University of Wisconsin, which he joined in 1985. Reps is the author or co-author of four books and more than one hundred seventy-five papers describing his research (see http://pages.cs.wisc.edu/~reps/). His work has concerned a wide variety of topics, including program slicing, dataflow analysis, pointer analysis, model checking, computer security, code instrumentation, language-based program-development environments, the use of program profiling in software testing, software renovation, incremental algorithms, and attribute grammars.
His collaboration with Professor Tim Teitelbaum at Cornell University from 1978 to 1985 led to the creation of two systems—the Cornell Program Synthesizer and the Synthesizer Generator—that explored how to build interactive programming tools that incorporate knowledge about the programming language being supported. The systems that they created were similar to modern program-development environments, such as Microsoft Visual Studio and Eclipse, but pre-dated them by more than two decades. Reps is President of GrammaTech, Inc., which he and Teitelbaum founded in 1988 to commercialize this work.
At Wisconsin, Professor Reps and collaborator Professor Susan Horwitz carried out many investigations of program slicing and its applications in software engineering. Reps’s most recent work concerns program analysis, computer security, and software model checking.
In 1996, Reps served as a consultant to DARPA to help them plan a project aimed at reducing the impact of the Year 2000 Problem on the U.S. Department of Defense. In 2003, he served on the F/A-22 Avionics Advisory Team, which provided advice to the U.S. Department of Defense about problems uncovered during integration testing of the plane’s avionics software.
Professor Reps received his Ph.D. in Computer Science from Cornell University in 1982. His Ph.D. dissertation won the 1983 ACM Doctoral Dissertation Award.
Reps’s 1988 paper on interprocedural slicing, with Susan Horwitz and his then-student David Binkley, was selected as one of the 50 most influential papers from the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), 1979-99. According to Google Scholar, the 1988 paper and the subsequent journal version have received over 1,780 citations.
His 2004 paper about analysis of assembly code, with his student Gogul Balakrishnan, received the ETAPS Best-Paper Award for 2004 from the European Association for Programming Languages and Systems (EAPLS). His 2008 paper about a system for generating static analyzers for machine instructions, with his student Junghee Lim, received the ETAPS Best-Paper Award for 2008 from EAPLS. In 2010, his 1984 paper “The Synthesizer Generator,” with Tim Teitelbaum, received an ACM SIGSOFT Retrospective Impact Paper Award. In 2011, his 1994 paper “Speeding up slicing,” with Susan Horwitz, Mooly Sagiv, and Genevieve Rosay, also received an ACM SIGSOFT Retrospective Impact Paper Award.
Four of his students, Gogul Balakrishnan, Akash Lal, Junghee Lim, and Aditya Thakur, have been recipients of the Outstanding Graduate Student Research Award given by the University of Wisconsin Computer Sciences Department. Akash Lal was also a co-recipient of the 2009 SIGPLAN Outstanding Doctoral Dissertation Award, and he was named as one of the 18 awardees selected for the 2011 India TR-35 list (top innovators under 35).
Reps has also been the recipient of an NSF Presidential Young Investigator Award (1986), a Packard Fellowship (1988), a Humboldt Research Award (2000), and a Guggenheim Fellowship (2000). He is also an ACM Fellow (2005). In 2013, Reps was elected a foreign member of Academia Europaea.
Reps has held visiting positions at the Institut National de Recherche en Informatique et en Automatique (INRIA) in Rocquencourt, France (1982-83), the University of Copenhagen, Denmark (1993-94), the Consiglio Nazionale delle Ricerche in Pisa, Italy (2000-2001), and the University Paris Diderot—Paris 7 (2007-2008).</bio>
          <homepage_url>http://pages.cs.wisc.edu/~reps/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/thomasreps/bc5323a6-d318-42c9-a136-d3252ecda280/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5097d9ca-9a42-4665-a047-228131a47c5a</subevent_id>
    <title>Research Papers: Outside the box</title>
    <subevent_type type="regular"/>
    <room>POPL-Track-2</room>
    <date>2018/01/11</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>2a8af9b5-12de-4c60-ac66-3d8b07909e57</slot_id>
      <title>Linearity in Higher-Order Recursion Schemes</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/11</date>
      <start_time>14:30</start_time>
      <end_time>14:55</end_time>
      <description>Higher-order recursive schemes (HORS) have recently emerged as a promising foundation for higher-order program verification. We examine the impact of enriching HORS with linear types. To that end, we introduce two frameworks that blend non-linear and linear types: a variant of the lambda-Y-calculus and an extension of HORS, called linear HORS (LHORS).
First we prove that the two formalisms are equivalent and there exist polynomial-time translations between them. Then, in order to support model-checking of (trees generated by) LHORS, we propose a refined version of alternating parity tree automata, called LNAPTA, whose behaviour depends on information about linearity. We show that the complexity of LNAPTA model-checking for LHORS depends on two type-theoretic parameters: linear order and linear depth. The former is in general smaller than the standard notion of order and ignores linear function spaces. In contrast, the latter measures the depth of linear clusters inside a type. Our main result states that LNAPTA model-checking of LHORS of linear order n is n-EXPTIME-complete, when linear depth is fixed. This generalizes and improves upon the classic result of Ong, which relies on the standard notion of order.
To illustrate the significance of the result, we consider two applications: the MSO model-checking problem on variants of HORS with case distinction (RSFD and HORSC) on a finite domain and a call-by-value resource verification problem. In both cases, decidability can be established by translation into HORS, but the implied complexity bounds will be suboptimal due to increases in type order. In contrast, we show that the complexity bounds derived by translations into LHORS and appealing to our result are optimal in that they match the respective hardness results.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Pierre</first_name>
          <last_name>Clairambault</last_name>
          <affiliation>CNRS &amp; ENS Lyon</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Charles</first_name>
          <last_name>Grellois</last_name>
          <affiliation>INRIA Sophia Antipolis &amp; Aix-Marseille Université</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.grellois.fr</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Andrzej</first_name>
          <last_name>Murawski</last_name>
          <affiliation>University of Warwick</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ox.ac.uk/andrzej.murawski</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/andrzejmurawski/c0aebdbf-59a7-49c7-980b-2d24b501390a/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>34be748f-eb71-4efb-ae69-305c40e249f2</slot_id>
      <title>Parametricity versus the Universal Type</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/11</date>
      <start_time>14:05</start_time>
      <end_time>14:30</end_time>
      <description>There has long been speculation in the scientific literature on how to dynamically enforce parametricity such as that yielded by System F. Almost 20 years ago, Sumii and Pierce proposed a formal compiler from System F into the cryptographic lambda calculus: an untyped lambda calculus extended with an idealised model of encryption. They conjectured that this compiler was fully abstract, i.e. that compiled terms are contextually equivalent if and only if the original terms were, a property that can be seen as a form of secure compilation. The conjecture has received attention in several other publications since then, but remains open to this day.
More recently, several researchers have been looking at gradually-typed languages that extend System~F. In this setting it is natural to wonder whether embedding System F into these gradually-typed languages preserves contextual equivalence and thus parametricity.
In this paper, we answer both questions negatively. We provide a concrete counterexample: two System F terms whose contextual equivalence is not preserved by the Sumii-Pierce compiler, nor the embedding into the polymorphic blame calculus. This counterexample relies on the absence in System F of what we called a ``Universal'' type, i.e., a type where all other types can be injected to and extracted from. As the languages in which System F is compiled have a universal type, the compilation cannot be fully abstract; this paper explains why.
We believe this paper thus sheds light on recent results in the field of gradually typed languages and it provides a perspective for further research into secure compilation of polymorphic languages.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dominique</first_name>
          <last_name>Devriese</last_name>
          <affiliation>KU Leuven</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://distrinet.cs.kuleuven.be/people/dominiqu</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/dominiquedevriese/08b1fc2d-d157-4905-9c9a-e1ff279ab345/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marco</first_name>
          <last_name>Patrignani</last_name>
          <affiliation>Saarland University, CISPA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-sws.org/~marcopat/marcopat/Home.html</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/marcopatrignani/1dc2d601-e85a-4b78-b8cc-8bbabb1191f5/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Frank</first_name>
          <last_name>Piessens</last_name>
          <affiliation>KU Leuven</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>538a9ec3-7111-4163-8431-9d428f4e3c4a</slot_id>
      <title>Symbolic Types for Lenient Symbolic Execution</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/11</date>
      <start_time>14:55</start_time>
      <end_time>15:20</end_time>
      <description>We present \lcsym, a typed $\lambda$-calculus for lenient symbolic execution, where some language constructs do not recognize symbolic values. Its type system, however, ensures safe behavior of all symbolic values in a program. Our calculus extends a base occurrence typing system with symbolic types and mutable state, making it a suitable model for both functional and imperative symbolically executed languages. Naively allowing mutation in this mixed setting introduces soundness issues, however, so we further add concreteness polymorphism, which restores soundness without rejecting too many valid programs. To show that our calculus is a useful model for a real language, we implemented Typed Rosette, a typed extension of the solver-aided Rosette language. We evaluate Typed Rosette by porting a large code base, demonstrating that our type system accommodates a wide variety of symbolically executed programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Chang</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ccs.neu.edu/home/stchang/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alex</first_name>
          <last_name>Knauth</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://github.com/AlexKnauth/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/alexknauth/3e0eb611-52bb-4b0f-a117-e1d063d6460a/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Emina</first_name>
          <last_name>Torlak</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>Emina Torlak is an Assistant Professor at the University of Washington, working at the intersection of programming languages, formal methods, and software engineering. She received her Bachelors (2003), Masters (2004), and Ph.D. (2009) degrees from MIT, and subsequently worked at IBM Research, LogicBlox, and as a research scientist at U.C. Berkeley. Her research focuses on developing automated tools and programming models for computer-aided design, verification, and synthesis of software. She is the creator of the Kodkod constraint solver, which has been used in over 70 academic and industrial tools for software engineering. Emina has applied her expertise to a broad range of problems, from verification of memory-consistency models to generation of test data for decision support applications. Her current work on the Rosette solver-aided language integrates constraint solvers into programming languages to support computer-aided verification, debugging, and synthesis of code, making programming a collaboration between humans and machines.</bio>
          <homepage_url>https://homes.cs.washington.edu/~emina/index.html</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/eminatorlak/b48dd8a1-4bf6-4d29-b6e3-fb0e9ea9ce8e/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fcd3c5f0-2a3b-4ec5-957a-111847e44dcb</slot_id>
      <title>Go with the Flow: Compositional Abstractions for Concurrent Data Structures</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/11</date>
      <start_time>13:40</start_time>
      <end_time>14:05</end_time>
      <description>Concurrent separation logics have helped to significantly simplify correctness proofs for concurrent data structures. However, a recurring problem in such proofs is that data structure abstractions that work well in the sequential setting are much harder to reason about in a concurrent setting due to complex sharing and overlays. To solve this problem, we propose a novel approach to abstracting regions in the heap by encoding the data structure invariant into a local condition on each individual node. This condition may depend on a quantity associated with the node that is computed as a fixpoint over the entire heap graph. We refer to this quantity as a \emph{flow}. Flows can encode both structural properties of the heap (e.g. the reachable nodes from the root form a tree) as well as data invariants (e.g. sortedness). We then introduce the notion of a \emph{flow interface}, which expresses the relies and guarantees that a heap region imposes on its context to maintain the local flow invariant with respect to the global heap. Our main technical result is that this notion leads to a new semantic model of separation logic. In this model, flow interfaces provide a general abstraction mechanism for describing complex data structures. This abstraction mechanism admits proof rules that generalize over a wide variety of data structures. To demonstrate the versatility of our approach, we show how to extend the logic RGSep with flow interfaces. We have used this new logic to prove linearizability and memory safety of nontrivial concurrent data structures. In particular, we obtain parametric linearizability proofs for concurrent dictionary algorithms that abstract from the details of the underlying data structure representation. These proofs cannot be easily expressed using the abstraction mechanisms provided by existing separation logics.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Siddharth</first_name>
          <last_name>Krishna</last_name>
          <affiliation>New York University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.nyu.edu/~siddharth/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dennis</first_name>
          <last_name>Shasha</last_name>
          <affiliation>New York University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Wies</last_name>
          <affiliation>New York University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.nyu.edu/wies/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/thomaswies/e43dd6b5-97dc-433f-9708-836bd6364a01/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ca841b1b-8ab4-45b7-ac33-ecc06cf33d9d</subevent_id>
    <title>Research Papers: Types for State</title>
    <subevent_type type="regular"/>
    <room>POPL-Track-2</room>
    <date>2018/01/12</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>39608bcb-b897-414d-9205-d6c595768ecc</slot_id>
      <title>A Logical Relation for Monadic Encapsulation of State: Proving contextual equivalences in the presence of runST</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/12</date>
      <start_time>15:50</start_time>
      <end_time>16:23</end_time>
      <description>We present a logical relations model of a higher-order functional programming language with impredicative polymorphism, recursive types, and a Haskell-style ST monad type with runST. We use our logical relations model to show that runST provides proper encapsulation of state, by showing that effectful computations encapsulated by runST are heap independent. Furthermore, we show that contextual refinements and equivalences that are expected to hold for pure computations do indeed hold in the presence of runST. This is the first time such relational results have been proven for a langauge with monadic encapsulation of state. We have formalized all the technical development and results in Coq.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Amin</first_name>
          <last_name>Timany</last_name>
          <affiliation>imec-Distrinet KU-Leuven</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://distrinet.cs.kuleuven.be/people/amin</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/amintimany/cfebdae6-0865-4649-98c1-10b0a0caf347/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Leo</first_name>
          <last_name>Stefanesco</last_name>
          <affiliation>ENS Lyon</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://stefanesco.com</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Morten</first_name>
          <last_name>Krogh-Jespersen</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Lars</first_name>
          <last_name>Birkedal</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.au.dk/~birke/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>69bb0629-53a2-4ca8-b98b-954d5e1ea288</slot_id>
      <title>Recalling a Witness: Foundations and Applications of Monotonic State</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/12</date>
      <start_time>16:23</start_time>
      <end_time>16:56</end_time>
      <description>We provide a practical way to ease the verification of programs whose state evolves monotonically. The main idea is that a property witnessed in a prior state can be recalled in the current state, provided (1) state evolves according to a given preorder, and (2) the property is preserved by this preorder. In many realistic scenarios, such monotonic reasoning yields concise modular proofs, saving the need for explicit program invariants. We distill our approach into the monotonic-state monad, a general yet compact interface for Hoare-style reasoning about monotonic state in a dependently typed language. We prove the soundness of the monotonic-state monad and use it as a unified foundation for reasoning about monotonic state in the F* verification system. Based on this foundation, we build libraries for various mutable data structures like monotonic references and apply these libraries at scale to the verification of several distributed applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Danel</first_name>
          <last_name>Ahman</last_name>
          <affiliation>Inria Paris</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/s1225336/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Cédric</first_name>
          <last_name>Fournet</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://research.microsoft.com/en-us/um/people/fournet/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Cătălin</first_name>
          <last_name>Hriţcu</last_name>
          <affiliation>Inria Paris</affiliation>
          <bio>Catalin is a tenured Research Scientist at Inria Paris where he develops rigorous formal techniques for solving security problems. He is particularly interested in formal methods for security (memory safety, compartmentalization, dynamic monitoring, integrity, security protocols, information flow), programming languages (type systems, verification, proof assistants, property-based testing, semantics, formal metatheory, certified tools), and the design and verification of security-critical systems (reference monitors, secure compilers, microkernels, secure hardware). He is actively involved in the design of the F* verification system and was recently awarded an ERC Starting Grant on secure compilation. Catalin was a PhD student at Saarland University and a Research Associate at University of Pennsylvania before joining Inria Paris in 2013.</bio>
          <homepage_url>http://prosecco.gforge.inria.fr/personal/hritcu/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/catalinhritcu/e262cec6-3e6b-47cc-ad61-b5c5b07953a1/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Kenji</first_name>
          <last_name>Maillard</last_name>
          <affiliation>Inria Paris and ENS Paris</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Aseem</first_name>
          <last_name>Rastogi</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.microsoft.com/en-us/research/people/aseemr/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/aseemrastogi/60be692f-f2e1-4eef-ac4a-85f7accdba8e/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Nikhil</first_name>
          <last_name>Swamy</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://research.microsoft.com/~nswamy</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/nikhilswamy/fcdbbbd2-b390-4c57-a305-b77c7386f260/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b505b296-7d00-4800-91c4-3d346ccf3d5e</slot_id>
      <title>RustBelt: Securing the Foundations of the Rust Programming Language</title>
      <room>Omni Hotel | POPL-Track-2</room>
      <date>2018/01/12</date>
      <start_time>16:56</start_time>
      <end_time>17:30</end_time>
      <description>Rust is a new systems programming language that promises to overcome the seemingly fundamental tradeoff between high-level safety guarantees and low-level control over resource management. Unfortunately, none of Rust’s safety claims have been formally proven, and there is good reason to question whether they actually hold. Specifically, Rust employs a strong, ownership-based type system, but then extends the expressive power of this core type system through libraries that internally use unsafe features. In this paper, we give the first formal (and machine-checked) safety proof for a language representing a realistic subset of Rust. Our proof is extensible in the sense that, for each new Rust library that uses unsafe features, we can say what verification condition it must satisfy in order for it to be deemed a safe extension to the language. We have carried out this verification for some of the most important libraries that are used throughout the Rust ecosystem.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ralf</first_name>
          <last_name>Jung</last_name>
          <affiliation>MPI-SWS</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-sws.org/~jung/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jacques-Henri</first_name>
          <last_name>Jourdan</last_name>
          <affiliation>CNRS, LRI, Université Paris-Sud</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jhjourdan.mketjh.fr/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/jacqueshenrijourdan/4214e3a4-2811-4db8-8ecb-7d4aeb554543/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Robbert</first_name>
          <last_name>Krebbers</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://robbertkrebbers.nl</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Derek</first_name>
          <last_name>Dreyer</last_name>
          <affiliation>MPI-SWS</affiliation>
          <bio>Derek Dreyer is a professor of computer science at the Max Planck Institute for Software Systems (MPI-SWS), and recipient of the 2017 ACM SIGPLAN Robin Milner Young Researcher Award. His research runs the gamut from the type theory of high-level functional languages, down to the verification of compilers and low-level concurrent programs under relaxed memory models. He is currently leading the RustBelt project, which focuses on building the first formal foundations for the Rust programming language. He also knows a thing or two about Scotch whisky.</bio>
          <homepage_url>http://www.mpi-sws.org/~dreyer</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/derekdreyer/35c3297e-34b7-4b24-bc9e-d4c927a19a40/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9d6f3e51-54bd-4789-8f8e-f515bbe35eb7</subevent_id>
    <title>Research Papers: Awards &amp; Keynote-I</title>
    <subevent_type type="regular"/>
    <room>POPL-Keynote</room>
    <date>2018/01/10</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>2e2065e7-864c-41a9-88b0-3d824c22a7f5</slot_id>
      <title>The Type Soundness Theorem That You Really Want to Prove (and Now You Can)</title>
      <room>Omni Hotel | POPL-Keynote</room>
      <date>2018/01/10</date>
      <start_time>08:30</start_time>
      <end_time>10:00</end_time>
      <description>Type systems—and the associated concept of “type soundness”—are one of the biggest success stories of foundational PL research. Originally proposed by Robin Milner in 1978, type soundness asserts that well-typed programs can’t “go wrong” (i.e., exhibit undefined behaviors), and it is widely viewed as the canonical theorem one must prove to establish that a type system is doing its job. In the early 1990s, Wright and Felleisen introduced a simple syntactic approach to proving type soundness, which was subsequently popularized as the method of “progress and preservation” and has had a huge impact on the study and teaching of PL foundations. Many research papers that propose new type systems conclude with a triumphant statement of syntactic type soundness, and for many students it is the only thing they learn to prove about a type system.
Unfortunately, syntactic type soundness is a rather weak theorem. First of all, its premise is too strong for many practical purposes. It only applies to programs that are completely well-typed, and thus tells us nothing about the many programs written in “safe” languages that make use of “unsafe” language features. Even worse, it tells us nothing about whether type systems achieve one of their main goals: enforcement of data abstraction. One can easily define a language that enjoys syntactic soundness and yet fails to support even the most basic modular reasoning principles for closures, objects, and ADTs.
In this talk, I argue that we should no longer be satisfied with just proving syntactic type soundness, and should instead start proving a stronger theorem—semantic type soundness—that captures more accurately what type systems are actually good for. In a semantic soundness proof, one defines a semantic model of types as predicates on values, and then verifies the soundness of typing rules as lemmas about the model. By explaining directly what types “mean”, the semantic approach to type soundness is a lot more informative than the syntactic one. In particular, it can serve to establish what data abstraction guarantees a language provides, as well as what it means for uses of unsafe language features to be “safely encapsulated”.
Semantic type soundness is a very old idea—Milner’s original formulation of type soundness was a semantic one—but it fell out of favor in the 1990s due to limitations and complexities of denotational models. In the succeeding decades, such limitations have been overcome and complexities tamed, via proof techniques that work directly over operational semantics. Thanks to the development of step-indexed Kripke logical relations, we can now scale semantic soundness to handle real languages, and thanks to advances in higher-order concurrent separation logic, we can now build (machine-checked) semantic soundness proofs at a much higher level of abstraction than was previously possible. The resulting “logical” approach to semantic type soundness yields proofs that are demonstrably more useful than their syntactic counterparts, and more fun as well.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Derek</first_name>
          <last_name>Dreyer</last_name>
          <affiliation>MPI-SWS</affiliation>
          <bio>Derek Dreyer is a professor of computer science at the Max Planck Institute for Software Systems (MPI-SWS), and recipient of the 2017 ACM SIGPLAN Robin Milner Young Researcher Award. His research runs the gamut from the type theory of high-level functional languages, down to the verification of compilers and low-level concurrent programs under relaxed memory models. He is currently leading the RustBelt project, which focuses on building the first formal foundations for the Rust programming language. He also knows a thing or two about Scotch whisky.</bio>
          <homepage_url>http://www.mpi-sws.org/~dreyer</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/derekdreyer/35c3297e-34b7-4b24-bc9e-d4c927a19a40/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2a924758-dbe5-4121-af79-1e8f7afdfa11</subevent_id>
    <title>Research Papers: Termination</title>
    <subevent_type type="regular"/>
    <room>POPL-Track-1</room>
    <date>2018/01/11</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>11e6e556-a1c3-402a-b5fd-2d37dcbfa7b4</slot_id>
      <title>Algorithmic Analysis of Termination Problems for Quantum Programs</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/11</date>
      <start_time>14:30</start_time>
      <end_time>14:55</end_time>
      <description>We introduce the notion of linear ranking super-martingale (LRSM) for quantum programs (with nondeterministic choices, namely angelic and demonic choices). Several termination theorems are established showing that the existence of the LRSMs of a quantum program implies its termination. Thus, the termination problems of quantum programs is reduced to realisability and synthesis of LRSMs. We further show that the realisability and synthesis problem of LRSMs for quantum programs can be reduced to an SDP (Semi-Definite Programming) problem, which can be settled with the existing SDP solvers. The techniques developed in this paper are used to analyse the termination of several example quantum programs, including quantum random walks and quantum Bernoulli factory for random number generation. This work is essentially a generalisation of constraint-based approach to the corresponding problems for probabilistic programs developed in the recent literature by adding two novel ideas: (1) employing the fundamental Gleason’s theorem in quantum mechanics to guide the choices of templates; and (2) a generalised Farkas’ lemma in terms of observables (Hermitian operators) in quantum physics.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yangjia</first_name>
          <last_name>Li</last_name>
          <affiliation>Institute of Software, Chinese Academy of Sciences</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mingsheng</first_name>
          <last_name>Ying</last_name>
          <affiliation>University of Technology Sydney</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>16eaa03d-c00b-4ba1-82cf-1fd1580cb49c</slot_id>
      <title>Monadic refinements for relational cost analysis</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/11</date>
      <start_time>14:55</start_time>
      <end_time>15:20</end_time>
      <description>Formal frameworks for cost analysis of programs have been widely studied in the unary setting and, to a limited extent, in the relational setting. However, many of these frameworks focus only on the cost aspect, largely side-lining functional properties that are often a pre-requisite for cost analysis, thus leaving many interesting programs out of their purview. In this paper, we show that elegant, simple, expressive proof systems combining cost analysis and functional properties can be built by combining already known ingredients: higher-order refinements and cost monads. Specifically, we derive two syntax-directed proof systems, $R^C$ and $U^C$, for relational and unary cost analysis, by adding a cost monad to a (syntax-directed) logic of higher-order programs. We study the metatheory of the systems, show that several nontrivial examples can be verified in them, and prove that existing frameworks for cost analysis (RelCost and RAML) can be embedded in them.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ivan</first_name>
          <last_name>Radicek</last_name>
          <affiliation>TU Vienna</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Gilles</first_name>
          <last_name>Barthe</last_name>
          <affiliation>IMDEA Software Institute</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://software.imdea.org/~gbarthe/index.html</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Marco</first_name>
          <last_name>Gaboardi</last_name>
          <affiliation>University at Buffalo, SUNY</affiliation>
          <bio>Marco Gaboardi is an assistant professor in the Department of Computer Science and Engineering at the University at Buffalo, SUNY. Previously, he was a faculty at the University of Dundee, Scotland. He received his PhD from the University of Torino, Italy, and the Institute National Polytechnique de Lorraine, France. He was a visitor scholar at the University of Pennsylvania and at Harvard’s CRCS center. He has been the recipient of a EU Marie Curie Fellowship. His research is in programming languages, differential privacy, and logic.</bio>
          <homepage_url>http://www.buffalo.edu/~gaboardi</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/marcogaboardi/76ff8963-9672-4f16-87bc-3f0d75ce589b/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Deepak</first_name>
          <last_name>Garg</last_name>
          <affiliation>Max Planck Institute for Software Systems</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-sws.org/~dg</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/deepakgarg/2a70fd29-76c7-4771-98ce-7d8c591f4e69/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Florian</first_name>
          <last_name>Zuleger</last_name>
          <affiliation>TU Vienna</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://forsyte.at/people/zuleger/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3c37c9db-b2d7-4ee1-a614-d692ecb3374b</slot_id>
      <title>A new proof rule for almost-sure termination</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/11</date>
      <start_time>13:40</start_time>
      <end_time>14:05</end_time>
      <description>We present a new proof rule for proving almost-sure termination of probabilistic programs, including those that contain demonic non-determinism. An important question for a probabilistic program is whether the probability mass of all its diverging runs is zero, that is that it terminates “almost surely”. Proving that can be hard, and this paper presents a new method for doing so. It applies directly to the program’s source code, even if the program contains demonic choice. We use variant functions (a.k.a. “super-martingales”) that are real-valued and decrease randomly on each loop iteration; but our key innovation is that the amount as well as the probability of the decrease are parametric. We prove the soundness of the new rule, indicate where its applicability goes beyond existing rules, and explain its connection to Blackwell’s classical results on denumerable (non-demonic) Markov chains.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Annabelle</first_name>
          <last_name>McIver</last_name>
          <affiliation>Macquarie University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Carroll</first_name>
          <last_name>Morgan</last_name>
          <affiliation>University of New South Wales; Data 61</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Benjamin Lucien</first_name>
          <last_name>Kaminski</last_name>
          <affiliation>RWTH Aachen University; University College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://moves.rwth-aachen.de/people/kaminski/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Joost-Pieter</first_name>
          <last_name>Katoen</last_name>
          <affiliation>RWTH Aachen University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www-i2.informatik.rwth-aachen.de/~katoen/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>89c63717-9c12-4d66-a3d7-c29c879cc1db</slot_id>
      <title>Lexicographic Ranking Supermartingales: An Efficient Approach to Termination of Probabilistic Programs</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/11</date>
      <start_time>14:05</start_time>
      <end_time>14:30</end_time>
      <description>Probabilistic programs extend classical imperative programs with real-valued random variables and random branching. The most basic liveness property for such programs is the termination property. The qualitative (aka almost-sure) termination problem given a probabilistic program asks whether the program terminates with probability~1. While ranking functions provide a sound and complete method for non-probabilistic programs, the extension of them to probabilistic programs is achieved via ranking supermartingales (RSMs). While deep theoretical results have been established about RSMs, their application to probabilistic programs with nondeterminism has been limited only to academic examples. For non-probabilistic programs, lexicographic ranking functions provide a compositional and practical approach for termination analysis of real-world programs. In this work we introduce lexicographic RSMs and show that they present a sound method for almost-sure termination of probabilistic programs with nondeterminism. We show that lexicographic RSMs provide a tool for compositional reasoning about almost-sure termination, and for probabilistic programs with linear arithmetic they can be synthesized efficiently (in polynomial time). We also show that with additional restrictions even asymptotic bounds on expected termination time can be obtained through lexicographic RSMs. Finally, we present experimental results on abstractions of real-world programs to demonstrate the effectiveness of our approach.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sheshansh</first_name>
          <last_name>Agrawal</last_name>
          <affiliation>IIT Bombay</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Krishnendu</first_name>
          <last_name>Chatterjee</last_name>
          <affiliation>IST Austria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pub.ist.ac.at/~kchatterjee/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Petr</first_name>
          <last_name>Novotny</last_name>
          <affiliation>IST Austria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pub.ist.ac.at/~pnovotny/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/petrnovotny/8d017ca1-52c5-4ae3-8742-393beb892447/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>259dab84-a5f1-4767-954b-b3803debf620</subevent_id>
    <title>Research Papers: Keynote-III</title>
    <subevent_type type="regular"/>
    <room>POPL-Keynote</room>
    <date>2018/01/12</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>fc88cff2-9966-4cc3-b7c6-e06f58adea2f</slot_id>
      <title>Formal Methods and the Law</title>
      <room>Omni Hotel | POPL-Keynote</room>
      <date>2018/01/12</date>
      <start_time>08:30</start_time>
      <end_time>10:00</end_time>
      <description>TBA</description>
      <persons>
        <person>
          <role>Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Sarah</first_name>
          <last_name>Lawsky</last_name>
          <affiliation>Northwestern University</affiliation>
          <bio>Sarah Lawsky is Professor of Law at Northwestern Pritzker School of Law. She teaches or has taught federal income tax, corporate tax, partnership tax, tax policy, tax deals, and contracts. Her research focuses on tax law and on the application of formal logic and artificial intelligence to the law.
Prior to joining Northwestern Pritzker in 2016, Lawsky taught at UC Irvine School of Law and George Washington University Law School, and as an adjunct in NYU’s tax LL.M. program. Before beginning her teaching career, she practiced tax law in New York.
Lawsky received her B.A. from the University of Chicago, her J.D. from Yale Law School, her LL.M. in tax from NYU School of Law, and her Ph.D. in philosophy from the UC Irvine Department of Logic and Philosophy of Science.</bio>
          <homepage_url>http://www.law.northwestern.edu/faculty/profiles/SarahLawsky/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/sarahlawsky/4cc609a3-a4d4-4aa7-8ff8-33695d92ab01/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6490146c-adbb-417c-bff4-876e389256b7</subevent_id>
    <title>Research Papers: Consistency</title>
    <subevent_type type="regular"/>
    <room>POPL-Track-1</room>
    <date>2018/01/11</date>
    <url>https://popl18.sigplan.org/track/POPL-2018-papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>13ce3e77-d87e-47a9-867d-6c7f3b6066ce</slot_id>
      <title>Alone Together: Compositional Reasoning and Inference for Weak Isolation</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/11</date>
      <start_time>11:20</start_time>
      <end_time>11:45</end_time>
      <description>Serializability is a well-understood correctness criterion that simplifies reasoning about the behavior of concurrent transactions by ensuring they are isolated from each other while they execute. However, enforcing serializable isolation comes at a steep cost in performance because it necessarily restricts opportunities to exploit concurrency even when such opportunities would not violate application-specific invariants. As a result, database systems in practice support, and often encourage, developers to implement transactions using weaker alternatives. These alternatives break the strong isolation guarantees offered by serializable transactions to permit greater concurrency. Unfortunately, the semantics of weak isolation is poorly understood, and usually explained only informally in terms of low-level implementation artifacts. Consequently, verifying high-level correctness properties in such environments remains a challenging problem. To address this issue, we present a novel program logic that enables compositional reasoning about the behavior of concurrently executing weakly-isolated transactions. Recognizing that the proof burden necessary to use this logic may dissuade application developers, we also describe an inference procedure based on this foundation that ascertains the weakest isolation level that still guarantees the safety of high-level consistency assertions associated with such transactions. The key to effective inference is the observation that weakly-isolated transactions can be viewed as functional (monadic) computations over an abstract database state, allowing us to treat their operations as state transformers over the database. This interpretation enables automated verification using off-the-shelf SMT solvers. Notably, our development is parametric over a transaction’s specific isolation semantics, allowing it to be applicable over a range of concurrency control mechanisms. Case studies and experiments on real-world applications (written in an embedded DSL in OCaml) demonstrate the utility of our approach, and provide strong evidence that automated verification of weakly-isolated transactions can be placed on the same formal footing as their strongly-isolated serializable counterparts.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gowtham</first_name>
          <last_name>Kaki</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl18.sigplan.org/getProfileImage/gowthamkaki/0ecc1c76-4bab-4b2b-bbf8-20104d29c38d/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kartik</first_name>
          <last_name>Nagar</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Mahsa</first_name>
          <last_name>Najafzadeh</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Suresh</first_name>
          <last_name>Jagannathan</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/suresh/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/sureshjagannathan/70e51299-573f-4211-a895-b2028c19c585/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1d9917e0-7edc-4571-a4f5-c844bf4fa08d</slot_id>
      <title>Reducing Liveness to Safety in First-Order Logic</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/11</date>
      <start_time>10:55</start_time>
      <end_time>11:20</end_time>
      <description>We develop a new technique for verifying temporal properties of infinite-state (distributed) systems. The main idea is to reduce the temporal verification problem to the problem of verifying the safety of infinite-state systems expressed in first-order logic. This allows to leverage existing techniques for safety verification to verify temporal properties of interesting distributed protocols, including some that have not been mechanically verified before.
We model infinite-state systems using first-order logic, and use first-order temporal logic (FO-LTL) to specify temporal properties. This general formalism allows to naturally model distributed systems, while supporting both \emph{unbounded-parallelism} (where the system is allowed to dynamically create processes), and infinite-state per process.
The traditional approach for verifying temporal properties of infinite-state systems employs well-founded relations (e.g. using linear arithmetic ranking functions). In contrast, our approach is based the idea of fair cycle detection. In finite-state systems, temporal verification can always be reduced to fair cycle detection (a system contains a fair cycle if it revisits a state after satisfying all fairness constraints). However, with both infinitely many states and infinitely many fairness constraints, a straightforward reduction to fair cycle detection is unsound. To regain soundness, we augment the infinite-state transition system by a dynamically computed finite set, that exploits the locality of transitions. This set lets us define a form of fair cycle detection that is sound in the presence of both infinitely many states, and infinitely many fairness constraints. Our approach allows a new style of temporal verification that does not explicitly involve ranking functions. This fits well with pure first order verification which does not explicitly reason about numerical values. In particular, it can be used with effectively propositional first-order logic (EPR), and thus guaranteeing that checking inductiveness is decidable.
We applied our technique to verify temporal properties of several interesting protocols. To the best of our knowledge, we have obtained the first mechanized liveness proof for both TLB Shootdown, and Stoppable Paxos.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Oded</first_name>
          <last_name>Padon</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~odedp/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/odedpadon/0b6f026e-1ef8-4890-abec-719522eb32bf/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jochen</first_name>
          <last_name>Hoenicke</last_name>
          <affiliation>Universität Freiburg</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://swt.informatik.uni-freiburg.de/staff/hoenicke</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/jochenhoenicke/7e5249eb-9086-4f85-9082-2bd5e68b0c1f/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Giuliano</first_name>
          <last_name>Losa</last_name>
          <affiliation>University of California at Los Angeles, USA</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Andreas</first_name>
          <last_name>Podelski</last_name>
          <affiliation>University of Freiburg, Germany</affiliation>
          <bio>Max Planck Institute for Computer Science, 1995-2006.
DEC PRL (Digital Paris Research Laboratory), 1992-94.
University of Paris 7, LITP, 1989-92
University of California at Berkeley, 1988-89
PhD, University of Paris 7. Supervisor Maurice Nivat.
Diplom, University of Münster. Supervisor Dieter Rödding.</bio>
          <homepage_url>http://swt.informatik.uni-freiburg.de/staff/podelski</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/andreaspodelski/f1a42650-d2d4-4ce6-b4cb-49a2b8ab8023/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Mooly</first_name>
          <last_name>Sagiv</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Sharon</first_name>
          <last_name>Shoham</last_name>
          <affiliation>Tel Aviv university</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.tau.ac.il/~sharonshoham/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/sharonshoham/52ca243a-805e-43b9-9f5a-bd1bae25fccb/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2d0e504d-ce61-4dab-9d39-89bea906ec97</slot_id>
      <title>Programming and Proving with Distributed Protocols</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/11</date>
      <start_time>11:45</start_time>
      <end_time>12:10</end_time>
      <description>Distributed systems play a crucial role in modern infrastructure, but are notoriously difficult to implement correctly. This difficulty arises from two main challenges: (a) correctly implementing core system components (e.g., two-phase commit), so all their internal invariants hold, and (b) correctly composing standalone system components into functioning trustworthy applications (e.g., persistent storage built on top of a two-phase commit instance). Recent work has developed several approaches for addressing (a) by means of mechanically verifying implementations of core distributed components, but no methodology exists to address (b) by composing such verified components into larger verified applications. As a result, expensive verification efforts for key system components are not easily reusable, which hinders further verification efforts.
In this paper, we present Disel, the first framework for implementation and compositional verification of distributed systems and their clients, all within the mechanized, foundational context of the Coq proof assistant. In Disel, users implement distributed systems using a domain specific language shallowly embedded in Coq and providing both high-level programming constructs as well as low-level communication primitives. Components of composite systems are specified in Disel as protocols, which capture system-specific logic and disentangle system definitions from implementation details. By virtue of Disel’s dependent type system, well-typed implementations always satisfy their protocols’ invariants and never go wrong, allowing users to verify system implementations interactively using Disel’s Hoare-style program logic, which extends state-of-the-art techniques for concurrency verification to the distributed setting. By virtue of the substitution principle and frame rule provided by Disel’s logic, system components can be composed leading to modular, reusable verified distributed systems.
We describe Disel, illustrate its use with a series of examples, outline its logic and metatheory, and report on our experience using it as a framework for implementing, specifying, and verifying distributed systems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ilya</first_name>
          <last_name>Sergey</last_name>
          <affiliation>University College London</affiliation>
          <bio>I am a lecturer (assistant professor) at University College London.
Prior to joining UCL, I was a postdoctoral researcher at IMDEA Software Institute (Madrid, Spain). I defended my PhD in 2012 in the DistriNet research group at the Department of Computer Sciences of KU Leuven (Belgium). Before that I received my MSc degree in Mathematics and Computer Science from Saint Petersburg State University (Russia) in 2008.
My research interests dwell in the area of the design and implementation of programming languages, including but not limited to program semantics, certified programming, concurrency and abstract interpretation. I am particularly interested in developing verification techniques and static analyses for higher-order and concurrent programs.</bio>
          <homepage_url>http://ilyasergey.net</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/ilyasergey/b2941c89-4843-4194-852a-81c8a30814fa/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>James R.</first_name>
          <last_name>Wilcox</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>I am a third year PhD student in the Computer Science and Engineering department at the University of Washington. My interests are in programming languages and applications of PL techniques to systems.</bio>
          <homepage_url>http://homes.cs.washington.edu/~jrw12/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/jamesrwilcox/92dfd071-3ff1-4a52-8f23-86215aca7f43/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zachary</first_name>
          <last_name>Tatlock</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>Assistant Professor at UW</bio>
          <homepage_url>https://homes.cs.washington.edu/~ztatlock/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/zacharytatlock/87af1196-2d8d-4bd5-a692-018d3939a00f/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>36d15f0f-3033-4cfd-8a1b-cc81d33c1f4e</slot_id>
      <title>Sound, Complete, and Tractable Linearizability Monitoring for Concurrent Collections</title>
      <room>Omni Hotel | POPL-Track-1</room>
      <date>2018/01/11</date>
      <start_time>10:30</start_time>
      <end_time>10:55</end_time>
      <description>While many program properties like the validity of assertions and in-bounds array accesses admit nearly-trivial monitoring algorithms, the standard correctness criterion for concurrent data structures does not. Given an implementation of an arbitrary abstract data type, checking whether the operations invoked in one single concurrent execution are linearizable, i.e., indistinguishable from an execution where the same operations are invoked atomically, requires exponential time in the number of operations.
In this work we identify a class of collection abstract data types which admit polynomial-time linearizability monitors. Collections capture the majority of concurrent data structures available in practice, including stacks, queues, sets, and maps. Although monitoring executions of arbitrary abstract data types requires enumerating exponentially-many possible linearizations, collections enjoy combinatorial properties which avoid the enumeration. We leverage these properties to reduce linearizability to Horn satisfiability. As far as we know, ours is the first sound, complete, and tractable algorithm for monitoring linearizability for types beyond single-value registers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Emmi</last_name>
          <affiliation>Nokia Bell Labs</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://michael-emmi.github.io</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/michaelemmi/6d406d04-28e2-4601-aedd-fb6a3c596f01/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Constantin</first_name>
          <last_name>Enea</last_name>
          <affiliation>Université Paris Diderot</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.irif.fr/~cenea/</homepage_url>
          <picture_url>https://popl18.sigplan.org/getProfileImage/constantinenea/2dfe8bfe-ddfe-4012-a2e2-01cc8b953734/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
</event>
