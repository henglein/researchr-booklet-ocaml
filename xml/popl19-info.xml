<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE event [<!ELEMENT zip_code (#PCDATA)><!ELEMENT url_link_display (#PCDATA)><!ELEMENT url (#PCDATA)><!ELEMENT tracks (track+)><!ELEMENT track (#PCDATA)><!ELEMENT title (#PCDATA)><!ELEMENT timeslot (slot_id?, title, room, date, start_time, end_time, description?, acm_doi?, persons?, tracks?, tags?)><!ELEMENT tags (tag+)><!ELEMENT tag (#PCDATA)><!ELEMENT suffix (#PCDATA)><!ELEMENT subevent_logo_url (#PCDATA)><!ELEMENT subevent_id (#PCDATA)>
<!ELEMENT subevent (subevent_id?, title, acronym?, timeslot*, subevent_type, description?, room, date, url?, url_link_display?, subevent_logo_url?, acm_doi?, persons?, tracks?, tags?, sponsor?, timeslot*)>
<!ELEMENT state (#PCDATA)><!ELEMENT start_time (#PCDATA)><!ELEMENT start_date (#PCDATA)><!ELEMENT sponsor (#PCDATA)><!ELEMENT sort_key (#PCDATA)><!ELEMENT slot_id (#PCDATA)><!ELEMENT subevent_type EMPTY><!ATTLIST subevent_type	type (case_study | demonstration | poster | regular | tutorial | workshop) #IMPLIED><!ELEMENT room (#PCDATA)><!ELEMENT role (#PCDATA)><!ELEMENT picture_url (#PCDATA)><!ELEMENT persons (person+)><!ELEMENT person (role, sort_key, first_name, middle_name?, last_name, suffix?, affiliation, acm_profile_id?, email?, bio?, homepage_url?, picture_url?)><!ELEMENT middle_name (#PCDATA)><!ELEMENT location (facility_name, facility_map_url?, address, city, state?, country, zip_code?)><!ELEMENT last_name (#PCDATA)><!ELEMENT homepage_url (#PCDATA)><!ELEMENT first_name (#PCDATA)><!ELEMENT facility_name (#PCDATA)><!ELEMENT facility_map_url (#PCDATA)><!ELEMENT event_type EMPTY><!ATTLIST event_type	type (conference|workshop|symposium) #IMPLIED><!ELEMENT event (event_details, subevent*, timeslot*)><!ELEMENT event_logo_url (#PCDATA)><!ELEMENT event_details (title, acronym, event_type, start_date, end_date, location, description, url?, url_link_display?, event_logo_url?, persons?)><!ELEMENT end_time (#PCDATA)><!ELEMENT end_date (#PCDATA)><!ELEMENT email (#PCDATA)><!ELEMENT description (#PCDATA)><!ELEMENT date (#PCDATA)><!ELEMENT country (#PCDATA)><!ELEMENT city (#PCDATA)><!ELEMENT bio (#PCDATA)><!ELEMENT affiliation (#PCDATA)><!ELEMENT address (#PCDATA)><!ELEMENT acronym (#PCDATA)><!ELEMENT acm_profile_id (#PCDATA)><!ELEMENT acm_doi (#PCDATA)>]>
<event>
  <event_details>
    <title>POPL 2019</title>
    <acronym>POPL 2019</acronym>
    <event_type type="conference"/>
    <start_date>2019/01/13</start_date>
    <end_date>2019/01/19</end_date>
    <location>
      <facility_name>Hotel Cascais Miragem</facility_name>
      <address>Av.Marginal n.8554</address>
      <city>Cascais/Lisbon</city>
      <country>Portugal</country>
    </location>
    <description>Registration is now open! 
 
 Booking a room at the conference hotel 
 Visa information 
 
Program of POPL 2019 and co-located events 
List of papers conditionally accepted for POPL 2019 
List of tutorials at TutorialFest 
Information for students 
 
 Student volunteers 
 Financial support 
 Programming Languages Mentoring Workshop (PLMW) 
 Student Research Competition 
</description>
    <url>https://popl19.sigplan.org/home</url>
    <url_link_display>POPL 2019</url_link_display>
    <persons>
      <person>
        <role>Committee Member in Steering Committee, General Chair in Organizing Committee</role>
        <sort_key>1</sort_key>
        <first_name>Fritz</first_name>
        <last_name>Henglein</last_name>
        <affiliation>Department of Computer Science, University of Copenhagen (DIKU)</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.diku.dk/~henglein</homepage_url>
        <picture_url>https://popl19.sigplan.org/getProfileImage/fritzhenglein/4984918d-01be-497a-b867-fbf1a77100e8/small.jpg</picture_url>
      </person>
      <person>
        <role>Chair in Steering Committee</role>
        <sort_key>2</sort_key>
        <first_name>Michael</first_name>
        <last_name>Hicks</last_name>
        <affiliation>University of Maryland, College Park</affiliation>
        <bio>Michael Hicks is a Professor in the Computer Science department and UMIACS at the University of Maryland, where he co-directs the laboratory for Programming Languages research (PLUM); he is the former Director of the Maryland Cybersecurity Center (MC2). 
His research focuses on using programming languages and analyses to improve the security, reliability, and availability of software. He is perhaps best known for his work exploring dynamic software updating, which is a technique by which software can be updated without shutting it down. He has explored the design of new programming languages and analysis tools for helping programmers find bugs and software vulnerabilities, and for identifying suspicious or incorrect program executions. 
His recent work has combined ideas from PL and cryptography, e.g., to ensure privacy preserving computations. He also leads the development of a new security-oriented programming contest, “build-it, break-it, fix-it,” which has been offered to the public and to students in his Coursera class on software security. He is the co-editor of the Programming Languages Enthusiast blog and Tweets at @michael_w_hicks.</bio>
        <homepage_url>http://www.cs.umd.edu/~mwh/</homepage_url>
        <picture_url>https://popl19.sigplan.org/getProfileImage/michaelhicks/aa64e3c6-3516-4e13-affe-77bc32c40565/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>3</sort_key>
        <first_name>Rastislav</first_name>
        <last_name>Bodik</last_name>
        <affiliation>University of Washington</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://homes.cs.washington.edu/~bodik</homepage_url>
        <picture_url>https://popl19.sigplan.org/getProfileImage/rastislavbodik/ae16ae8e-9d00-41c4-9067-0c37da65dde7/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>4</sort_key>
        <first_name>Giuseppe</first_name>
        <last_name>Castagna</last_name>
        <affiliation>CNRS, France / University of Paris Diderot, France</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.irif.fr/~gc/</homepage_url>
        <picture_url>https://popl19.sigplan.org/getProfileImage/giuseppecastagna/ca2a9ac8-d149-4486-87ed-b55ceb154a17/small.jpg</picture_url>
      </person>
      <person>
        <role>Artifact Evaluation Co-Chair in Organizing Committee</role>
        <sort_key>5</sort_key>
        <first_name>Benjamin</first_name>
        <last_name>Delaware</last_name>
        <affiliation>Purdue University</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://www.cs.purdue.edu/homes/bendy/</homepage_url>
        <picture_url>https://popl19.sigplan.org/getProfileImage/benjamindelaware/39bbf6b3-d145-435c-8956-8acf8cfcaffa/small.jpg</picture_url>
      </person>
      <person>
        <role>Workshops Co-Chair in Organizing Committee</role>
        <sort_key>6</sort_key>
        <first_name>Marco</first_name>
        <last_name>Gaboardi</last_name>
        <affiliation>University at Buffalo, SUNY</affiliation>
        <bio>Marco Gaboardi is an assistant professor in the Department of Computer Science and Engineering at the University at Buffalo, SUNY. Previously, he was a faculty at the University of Dundee, Scotland. He received his PhD from the University of Torino, Italy, and the Institute National Polytechnique de Lorraine, France. He was a visitor scholar at the University of Pennsylvania and at Harvard’s CRCS center. He has been the recipient of a EU Marie Curie Fellowship. His research is in programming languages, differential privacy, and logic.</bio>
        <homepage_url>http://www.buffalo.edu/~gaboardi</homepage_url>
        <picture_url>https://popl19.sigplan.org/getProfileImage/marcogaboardi/76ff8963-9672-4f16-87bc-3f0d75ce589b/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>7</sort_key>
        <first_name>Jeremy</first_name>
        <last_name>Gibbons</last_name>
        <affiliation>Department of Computer Science, University of Oxford</affiliation>
        <bio>I am Professor of Computing in the Department of Computer Science at the University of Oxford. I am currently Director of the Software Engineering Programme, which offers part-time professional Masters’ degrees in Software Engineering and in Software and Systems Security. I also lead the Algebra of Programming research group. I am Editor-in-Chief of the Journal of Functional Programming, Past Vice Chair of ACM SIGPLAN, Past Chair of IFIP WG2.1. Before taking up this post in 1999, I held lectureships at Oxford Brookes University and the University of Auckland, New Zealand.</bio>
        <homepage_url>http://www.cs.ox.ac.uk/jeremy.gibbons/</homepage_url>
        <picture_url>https://popl19.sigplan.org/getProfileImage/jeremygibbons/17403e55-a926-41cf-ae21-08abecea187c/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>8</sort_key>
        <first_name>Andrew D.</first_name>
        <last_name>Gordon</last_name>
        <affiliation>Microsoft Research and University of Edinburgh</affiliation>
        <bio>I am a Principal Researcher at Microsoft Research, Cambridge, where I manage Programming Principles and Tools. As a part-time position, I also hold the Chair in Computer Security and am a member of the Laboratory for Foundations of Computer Science and the Security and Privacy group in the School of Informatics in the University of Edinburgh. I convene the University of Edinburgh Microsoft Research Joint Initiative in Informatics. I participate in the Data Science PhD programme. My current research is on probabilistic programming for machine learning.</bio>
        <homepage_url>https://www.microsoft.com/en-us/research/people/adg/</homepage_url>
        <picture_url>https://popl19.sigplan.org/getProfileImage/andrewdgordon/6a7c06a4-cf70-4529-ad02-55b979e93f82/small.jpg</picture_url>
      </person>
      <person>
        <role>Publicity Chair in Organizing Committee</role>
        <sort_key>9</sort_key>
        <first_name>Michael</first_name>
        <last_name>Greenberg</last_name>
        <affiliation>Pomona College</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.pomona.edu/~michael/</homepage_url>
        <picture_url>https://popl19.sigplan.org/getProfileImage/michaelgreenberg/3c177ea6-ac3c-4ddb-9f4e-ac5d7b568e07/small.jpg</picture_url>
      </person>
      <person>
        <role>Artifact Evaluation Co-Chair in Organizing Committee</role>
        <sort_key>10</sort_key>
        <first_name>Cătălin</first_name>
        <last_name>Hriţcu</last_name>
        <affiliation>Inria Paris</affiliation>
        <bio>Catalin is a tenured Research Scientist at Inria Paris where he develops rigorous formal techniques for solving security problems. He is particularly interested in formal methods for security (memory safety, compartmentalization, dynamic monitoring, integrity, security protocols, information flow), programming languages (type systems, verification, proof assistants, property-based testing, semantics, formal metatheory, certified tools), and the design and verification of security-critical systems (reference monitors, secure compilers, microkernels, secure hardware). He is actively involved in the design of the F* verification system and was recently awarded an ERC Starting Grant on secure compilation. Catalin was a PhD student at Saarland University and a Research Associate at University of Pennsylvania before joining Inria Paris in 2013.</bio>
        <homepage_url>http://prosecco.gforge.inria.fr/personal/hritcu/</homepage_url>
        <picture_url>https://popl19.sigplan.org/getProfileImage/catalinhritcu/e262cec6-3e6b-47cc-ad61-b5c5b07953a1/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>11</sort_key>
        <first_name>Ranjit</first_name>
        <last_name>Jhala</last_name>
        <affiliation>University of California, San Diego</affiliation>
        <bio>Nom nom. Chomp. Burp.</bio>
        <homepage_url>http://ranjitjhala.github.io</homepage_url>
        <picture_url>https://popl19.sigplan.org/getProfileImage/ranjitjhala/afbdab69-ed23-4022-b7a4-2c57128f20ec/small.jpg</picture_url>
      </person>
      <person>
        <role>Workshops Co-Chair in Organizing Committee</role>
        <sort_key>12</sort_key>
        <first_name>Zachary</first_name>
        <last_name>Kincaid</last_name>
        <affiliation>Princeton University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.princeton.edu/~zkincaid</homepage_url>
        <picture_url>https://popl19.sigplan.org/getProfileImage/zacharykincaid/a26b486e-94a5-45f1-a8b3-9a2221495ff7/small.jpg</picture_url>
      </person>
      <person>
        <role>Website Chair in Organizing Committee</role>
        <sort_key>13</sort_key>
        <first_name>Hsiang-Shang ‘Josh’</first_name>
        <last_name>Ko</last_name>
        <affiliation>National Institute of Informatics, Japan</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://josh-hs-ko.github.io</homepage_url>
        <picture_url>https://popl19.sigplan.org/getProfileImage/hsiangshangko/9c5db602-95a9-413b-a2d8-a4121be09c2c/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>14</sort_key>
        <first_name>Rupak</first_name>
        <last_name>Majumdar</last_name>
        <affiliation>MPI-SWS, Germany</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.mpi-sws.org/~rupak</homepage_url>
        <picture_url>https://popl19.sigplan.org/getProfileImage/rupakmajumdar/3289b197-9f9a-4880-94c5-d9cf6d764bb1/small.jpg</picture_url>
      </person>
      <person>
        <role>Registration in Organizing Committee</role>
        <sort_key>15</sort_key>
        <first_name>Carole</first_name>
        <last_name>Mann</last_name>
        <affiliation>R.S.L</affiliation>
        <bio>undefined</bio>
        <picture_url>https://popl19.sigplan.org/getProfileImage/carolemann/3ed7bc7a-bb13-4ef4-b9b8-9b5079757292/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>16</sort_key>
        <first_name>Andrew</first_name>
        <last_name>Myers</last_name>
        <affiliation>Cornell University</affiliation>
        <bio>Andrew Myers is a Professor in the Department of Computer Science at Cornell University in Ithaca, NY. His research interests include programming languages, computer security, and distributed and persistent programming systems. Myers is an ACM Fellow. He has received awards for papers appearing in POPL’99, SOSP’01, SOSP’07, CIDR’13, PLDI’13, and PLDI’15. Myers is currently the Editor-in-Chief for ACM Transactions on Programming Languages and Systems (TOPLAS). He has also served as program chair or co-chair for a few conferences: ACM POPL 2018, ACM CCS 2016, POST 2014, IEEE CSF 2010, and IEEE S&amp;amp;P 2009.</bio>
        <homepage_url>http://www.cs.cornell.edu/andru</homepage_url>
        <picture_url>https://popl19.sigplan.org/getProfileImage/andrewmyers/88baadd2-5ed8-4687-b205-3cbbe8b1a848/small.jpg</picture_url>
      </person>
      <person>
        <role>Student Volunteer Co-Captain in Organizing Committee</role>
        <sort_key>17</sort_key>
        <first_name>Carlos</first_name>
        <last_name>Mão de Ferro</last_name>
        <affiliation>LASIGE, Faculty of Sciences, University of Lisbon</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.lasige.di.fc.ul.pt/user/36</homepage_url>
        <picture_url>https://popl19.sigplan.org/getProfileImage/carlosmaodeferro/9e89ef60-4e85-415b-88de-1fb9f28ef170/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>18</sort_key>
        <first_name>Brigitte</first_name>
        <last_name>Pientka</last_name>
        <affiliation>McGill University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.mcgill.ca/~bpientka/</homepage_url>
        <picture_url>https://popl19.sigplan.org/getProfileImage/brigittepientka/de1fcba2-a8fd-4b6e-a4f2-b7d397fef2cf/small.jpg</picture_url>
      </person>
      <person>
        <role>Student Volunteer Co-Captain in Organizing Committee</role>
        <sort_key>19</sort_key>
        <first_name>Alex</first_name>
        <last_name>Sanchez-Stern</last_name>
        <affiliation>University of California, San Diego</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://cseweb.ucsd.edu/~alexss/</homepage_url>
        <picture_url>https://popl19.sigplan.org/getProfileImage/alexsanchezstern/8f8df577-1227-40b6-86e8-2b553ee0c66d/small.jpg</picture_url>
      </person>
      <person>
        <role>Conference Coordinator in Organizing Committee, Treasurer in Organizing Committee</role>
        <sort_key>20</sort_key>
        <first_name>Annabel</first_name>
        <last_name>Satin</last_name>
        <affiliation>P.C.K.</affiliation>
        <bio>undefined</bio>
        <picture_url>https://popl19.sigplan.org/getProfileImage/annabelsatin/5e2fc743-bd68-4432-86af-99b4a6b6bf60/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Steering Committee</role>
        <sort_key>21</sort_key>
        <first_name>Peter</first_name>
        <last_name>Thiemann</last_name>
        <affiliation>University of Freiburg, Germany</affiliation>
        <bio>undefined</bio>
        <picture_url>https://popl19.sigplan.org/getProfileImage/peterthiemann/43fc0175-1745-4b3a-b626-86e10da76b86/small.jpg</picture_url>
      </person>
      <person>
        <role>Local Arrangements Chair in Organizing Committee</role>
        <sort_key>22</sort_key>
        <first_name>Vasco</first_name>
        <last_name>Vasconcelos</last_name>
        <affiliation>LASIGE, Faculty of Sciences, University of Lisbon</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.di.fc.ul.pt/~vv/</homepage_url>
        <picture_url>https://popl19.sigplan.org/getProfileImage/vascovasconcelos/b1bd0216-3fdb-4835-a89a-1e03a5fd6714/small.jpg</picture_url>
      </person>
      <person>
        <role>Student Research Competition Chair in Organizing Committee</role>
        <sort_key>23</sort_key>
        <first_name>Niki</first_name>
        <last_name>Vazou</last_name>
        <affiliation>IMDEA Software Institute</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://nikivazou.github.io/</homepage_url>
        <picture_url>https://popl19.sigplan.org/getProfileImage/nikivazou/8cc6ddec-154b-47e9-b40d-c66e78476391/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Steering Committee, Industrial Relations Chair in Organizing Committee</role>
        <sort_key>24</sort_key>
        <first_name>David</first_name>
        <last_name>Walker</last_name>
        <affiliation>Princeton University</affiliation>
        <bio>undefined</bio>
        <homepage_url>http://www.cs.princeton.edu/~dpw/</homepage_url>
        <picture_url>https://popl19.sigplan.org/getProfileImage/davidwalker/8763137a-03a5-4963-8639-e9f2a3cc8ac9/small.jpg</picture_url>
      </person>
      <person>
        <role>Committee Member in Steering Committee, Program Chair in Organizing Committee</role>
        <sort_key>25</sort_key>
        <first_name>Stephanie</first_name>
        <last_name>Weirich</last_name>
        <affiliation>University of Pennsylvania, USA</affiliation>
        <bio>undefined</bio>
        <homepage_url>https://www.cis.upenn.edu/~sweirich/</homepage_url>
        <picture_url>https://popl19.sigplan.org/getProfileImage/stephanieweirich/1f63ace9-e52a-4efc-b20b-ee75b5d7d091/small.jpg</picture_url>
      </person>
      <person>
        <role>Video Chair in Organizing Committee</role>
        <sort_key>26</sort_key>
        <first_name>Jakub</first_name>
        <last_name>Zalewski</last_name>
        <affiliation>undefined</affiliation>
        <bio>undefined</bio>
        <picture_url>https://popl19.sigplan.org/getProfileImage/jakubzalewski/33493c56-89a9-4187-9eff-4517d11c9818/small.jpg</picture_url>
      </person>
    </persons>
  </event_details>
  <subevent>
    <subevent_id>b446a052-3e47-410e-8386-1dfe779069f7</subevent_id>
    <title>POPL Student Research Competition: SRC Reception</title>
    <timeslot>
      <slot_id>1d8634ef-86b2-40fd-9004-94136b0dd3a0</slot_id>
      <title>Session: POPL Student Research Competition - SRC Reception</title>
      <room>Hotel Cascais Miragem | Galeria</room>
      <date>2019/01/16</date>
      <start_time>18:30</start_time>
      <end_time>19:30</end_time>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Galeria</room>
    <date>2019/01/16</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Student-Research-Competition</url>
    <url_link_display>Student Research Competition</url_link_display>
    <tracks>
      <track>Student Research Competition</track>
    </tracks>
    <timeslot>
      <slot_id>0052ec68-15fe-48db-be4c-d718b4121cab</slot_id>
      <title>SRC Reception</title>
      <room>Hotel Cascais Miragem | Galeria</room>
      <date>2019/01/16</date>
      <start_time>18:30</start_time>
      <end_time>19:30</end_time>
      <description>undefined</description>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>548f7db3-08a1-4d4f-ab78-47790016e35c</subevent_id>
    <title>BEAT: Session 2</title>
    <timeslot>
      <slot_id>55e66baf-b4b1-45a1-a49d-bf79bf5835ee</slot_id>
      <title>Session: BEAT - Session 2</title>
      <room>Hotel Cascais Miragem | Sala VII</room>
      <date>2019/01/13</date>
      <start_time>11:00</start_time>
      <end_time>12:30</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Dominic</first_name>
          <last_name>Orchard</last_name>
          <affiliation>University of Kent, UK</affiliation>
          <bio>Dr Dominic Orchard is a Lecturer in the School of Computing at the University of Kent, UK and he is a fellow of the SSI. His research interests are programming language design and semantics, mathematically structured programming, effect and coeffect systems, embedded domain-specific languages (esp. for parallelisation), and applying programming language research to computational science.</bio>
          <homepage_url>http://dorchard.co.uk</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/dominicorchard/f448aa26-a342-457c-91a6-3f9525a759a3/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>BEAT 2019: Fourth Workshop on Behavioral Types</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VII</room>
    <date>2019/01/13</date>
    <url>https://popl19.sigplan.org/track/beat-2019-papers</url>
    <url_link_display>BEAT 2019: Fourth Workshop on Behavioral Types</url_link_display>
    <tracks>
      <track>BEAT 2019: Fourth Workshop on Behavioral Types</track>
    </tracks>
    <timeslot>
      <slot_id>1d3224e1-9792-4990-85f8-61f76dca7cc7</slot_id>
      <title>Global Types with Internal Delegation</title>
      <room>Hotel Cascais Miragem | Sala VII</room>
      <date>2019/01/13</date>
      <start_time>11:50</start_time>
      <end_time>12:10</end_time>
      <description>In this talk we report on recent work in which we investigate a new form of delegation for multiparty session calculi. A paper describing this proposal has been submitted for publication to a journal. In the following after a very brief introduction we present our proposal through an example. Usually, delegation allows a session participant to appoint a participant in another session to act on her behalf. This means that delegation is inherently an inter-session mechanism, which requires session interleaving. Hence delegation falls outside the descriptive power of global types, which specify single sessions. As a consequence, properties such as deadlock-freedom or lock-freedom are difficult to ensure in the presence of delegation. We adopt a different view of delegation, by allowing participants to delegate tasks to each other within the same multiparty session. This way, delegation occurs within a single session (internal delegation) and may be captured by its global type. To increase flexibility in the use of delegation, our calculus uses connecting communications, which allow optional participants in the branches of choices. By these means, we are able to express conditional delegation. We present a session type system based on global types with internal delegation, and show that it ensures the usual safety properties of multiparty sessions, together with a progress property</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ilaria</first_name>
          <last_name>Castellani</last_name>
          <affiliation>INRIA Sophia Antipolis, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www-sop.inria.fr/members/Ilaria.Castellani/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/ilariacastellani/47b6f877-6713-449c-8974-610a9bfd2cf1/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mariangiola</first_name>
          <last_name>Dezani</last_name>
          <affiliation>Università di Torino</affiliation>
          <bio>Master in Physics at the University of Torino cum laude (1970). Full professor of ‘‘Teoria e Applicazioni delle Macchine Calcolatrici’’ at the University of Torino since 31/10/81. Dean of the Computer Science Department of Torino University since 05. 
Member of Program Committees of International Conferences and Workshops (Lambda-Calculus and Computer Science Theory, Roma March 75, V CAAP, Lille February 80, VII CAAP, Lille March 82, V ISP, Torino April 82, IX CAAP, Bordeaux March 84, VI ISP, Toulose April 84, XI CAAP, Nice March 86, STACS 87, Passau February 87, III LICS, Edinburgh July 88, XVI ICALP, Stresa July 89 (Co-chairman), XVI CAAP, Rennes March 92, TLCA’93, Utrecht March 93, CSL’94, Kazimierz September 94, TLCA’95, Edinburgh April 95 (Chairman), TLCA’97, Nancy April 97, TACS’97, Sendai September 97, LICS’99, Trento July 99, FCT’99, Iasi August 99, FOSSACS’00, Berlin March 00, CATS’01, Brisbane January 01, FOSSACS’01, Genova April 01, RTA’01, Utrecht May 01, TOSCA’01, Udine November 01, PPDP’02, Pittsburgh October 02, ESOP’03, Warsaw April 03, MFCS ’03, Bratislava August 03, ICTCS’03, Bertinoro October 03, ESOP’04, Barcelona April 04, WoLLIC ’04, Paris July 04, EXPRESS’04, London September 04, RTA’05, Nara April 05, DCM’05, Lisbon July 05, ICFP’05, Tallin September 05, EXPRESS’05, San Francisco August 05, WIT’05, Toulouse October 05, MFPS’06, Genova May 06, ICALP’06, Venice July 06, DCM’06, Venice July 06, SecReT’06, Venice July 06, DCM’07, Wroclaw July 07 (Co-Chair), TCS’08, Milano September 08, MeCBIC’08, Iasi September 08, ESOP’09, York March 09, FMOODS/FORTE’10, Amsterdam June 10, PPDP’10, Castle Hagenberg July 10, ITRS’10, Edinburgh July 10, DCM’10, Edinburgh July 10, HOR’10, Edinburgh July 10, AMCA-POP’10, Jena August 10, TCS’10, Brisbane September 10, ISCIS’10, London September 10, ISCIS’11, London September 11, DCM’12, Cambridge June 12, CSL’12, Fontainebleau September 12, ICFP’12, Copenhagen September 12, BEAT’13, Rome January 13, LATA’13, Bilbao April 13, LICS’13, New Orleans June 13, FORTE/FMOODS’13, Florence June 13, ECOOP’13, Montpellier July 13, ICTS’13, Palermo September 13, ISCIS’13, Paris October 13, LATA’14, Madrid March 14, ENASE’14, Lisbon April 14, TGC’14, Roma September 14, ICTCS’14, Perugia September 14, ISCIS’14, Krakow October 14, ENASE’15, Barcelona April 15, LICS’15, Kyoto July 15, ENASE’16, Rome April 16, FSCD’16, Porto June 16, ICTCS’16, Lecce September 16, ISCIS’16, Krakow October 16, ENASE’17, Porto April 17, FORTE’17, Neuchatel June 17, PPDP’17, Namur October 17, OOPSLA’17, Vancouver October 17, ENASE’18, Madeira March 18, FoSSaCS’18, Thessaloniki April 18, DCM’18, Oxford July 18, FTfJP’18, Amsterdam July 18), teacher of Postdoctoral Schools (Lambda-calcul et semantique formelle, La Chatre May 78, Reduction Machines, Ustica September 85, Logic and Computation, Edinburgh Aprile ’99, Deduction and Theorem Proving, Edinburgh Aprile ’00, Understanding COMPLEXITY and CONCURRENCY through TOPOLOGY of DATA, Camerino, July 15) invited speaker to International Conferences and Workshops (Logic Colloquium 82, Firenze August 82, VIII CAAP, L’Aquila March 83, IX Latin American Symposium on Mathematical Logic, Bahia Blanca August 92, Logic Colloquium 96, San Sebastian July 96, Theory of Types and Proofs, Tokyo August 97, ICTCS’98, Prato November 98, TLCA’99, L’Aquila April 99, CATS’00, Canberra January 00, ITRS’00, Ginevra July 00, BT’01, Creta July 01, RPC’01, Sendai October 01, AAL’02, Canberra November 02, HOR’04, Aachen May 04, MFCS’04, Prague August 04, Modern Uses of Lambda Calculus, Bern October 04, Marisa Zilli Day, Rome February 05, Security and Privacy Day, Hoboken November 05, Processes, Terms and Cycles: Steps on the Road to Infinity, Amsterdam December 05, Type Theory, Tokyo January 06, INFINITY’06, Amsterdam March 06, Logic, Models and Computer Science, Camerino April 06, IFIP W.G. 2.2, Udine September 06, DisCoTec 07, Cyprus June 07, From Type Theory to Morphologic Complexity: A Colloquium in Honour of Giuseppe Longo, Paris June 07, Reflections on Type Theory, Lambda Calculus, and the Mind: Symposium in honour of Henk Barendregt, Nijmegen December 07, Workshop on Web Services, Business Processes and Infrastructure, London February 08, Colloquium in Honour of Pierre Lescanne, Nancy May 08, Logic Colloquium, Berne July 08, WS-FM, Bologna September 09, WFLP, Madrid January 10, TGC’11, Aachen September 11, Workshop in Honour of Antonino Salibra, Paris July 13, MatthewFest, Lucca October 14, FbB60, Eindhoven June 16). 
Promotor or Co-promotor of the Ph.D. thesis of Felice Cardone, Fabio Alessi, Steffen van Bakel, Franco Barbanera, Adriana Compagnoni, Luigi Liquori, Viviana Bono, Stefania Lusin, Yoko Motohama, Pablo Garralda, Elena Giachino, Livio Bioglio, Svetlana Jaksic. 
EATCS Fellow in 15. 
Member of IFIP W.G.2.2 on ‘‘Formal Description of Programming Concepts’’ since 1/6/84. 
Member of the Editorial Board of ‘‘Information and Computation’’ since 1991. 
Member of the Editorial Board of ‘‘The Computer Journal’’ since 11. 
Book Review Editor of “The Computer Journal” from 00 to 10. 
Member of the ‘‘Academia Europaea’’ since 1994. 
Member of the ASL Executive Committee from 05 to 08. 
Member of LICS Advisory Board from 1997 to 03. 
Member of the EATCS Council from 1998 to 05 (member of EATCS since 1972). 
Co-ordinator of the IP since 1999. 
Chair of the Steering Committee of TLCA from 05 to 11 (member since 1993, honorary advisor from 14). 
Member of the Steering Committee of ITRS since 1999. 
Member of the Steering Committee of DCM since 07. 
President of the Italian Chapter of EATCS from 1998 to 03 (member since 1988). 
Member of the Editorial Board of Scientific Annals of Computer Science since 07. 
The 60th Birthday has been celebrated at ICTCS’07 
The 70th Birthday has been celebrated at TLT17.</bio>
          <homepage_url>http://www.di.unito.it/~dezani/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/mariangioladezani/6fcca6b5-5df3-485c-b90d-15d2397e241f/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Paola</first_name>
          <last_name>Giannini</last_name>
          <affiliation>Universita' del Piemonte Orientale</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.unipmn.it/giannini/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/paolagiannini/dbc88479-8b56-4e8d-87dd-a6007c5d9065/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ross</first_name>
          <last_name>Horne</last_name>
          <affiliation>Computer Science and Communications Research Unit, University of Luxembourg</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>BEAT 2019: Fourth Workshop on Behavioral Types</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>26db5361-c028-4b2b-bb2c-82b5aeec94d2</slot_id>
      <title>Two Declarative Approaches for Session-Based Concurrency</title>
      <room>Hotel Cascais Miragem | Sala VII</room>
      <date>2019/01/13</date>
      <start_time>12:10</start_time>
      <end_time>12:30</end_time>
      <description>There are two approaches often used for the specification of communication-intensive systems: an operational approach, that describes how interactions are structured and a declarative one, in which only the governing conditions for correct interactions are defined. Although these two paradigms have evolved independently, we believe that they should not be disjoint. In fact, the correctness of communication-intensive systems depends on the complex interplay of declarative and operational features. Hence, it is desirable to devise a framework in which properties and reasoning techniques can be transferred between paradigms. Herein, we describe our efforts, part of my PhD studies, to develop such framework. We focus on session-based concurrency and its associated specification language: the pi-calculus. Via encodings, treated as formal compilers, we have shown how to abstract the main communication structures from session pi-calculi and integrate them into declarative languages.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mauricio</first_name>
          <last_name>Cano</last_name>
          <affiliation>University of Groningen, The Netherlands</affiliation>
          <bio>PhD student in the University of Groningen under Prof. Gerard R. de Lavalette and Dr. Jorge A. Pérez. My main research topic is on models for session-based concurrency and I am currently working on Synchronous Reactive Programming and its relation with session types.</bio>
          <homepage_url>http://www.mcanog.info</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/mauriciocano/9dfbf742-e3eb-49bf-b1fb-9bda9448c5ac/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>BEAT 2019: Fourth Workshop on Behavioral Types</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a48a311d-52b4-4dd5-8b68-53b346fb213d</slot_id>
      <title>Invited Talk: On Type-Based Complexity Analysis of Programs and Processes</title>
      <room>Hotel Cascais Miragem | Sala VII</room>
      <date>2019/01/13</date>
      <start_time>11:00</start_time>
      <end_time>11:50</end_time>
      <description>We give a survey of some recent work about type-based complexity analysis methodologies for functional programs and processes. We will focus, in particular, on techniques drawn from linear logic. The latter indeed enables, through exponential modalities, a fine control of the copying phenomenon, itself responsible for the high complexity of cut-elimination. Our journey starts from simple but intentionally very poor fragments, like light and soft linear logic, and progressively moves towards more expressive type-systems, ending up in linear dependent types, which are well-known to be relatively complete. If time permits, we will report on our ongoing work about applying linear dependent types to pi-calculus processes</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ugo</first_name>
          <last_name>Dal Lago</last_name>
          <affiliation>University of Bologna, Italy / Inria, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.unibo.it/~dallago/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/ugodallago/446eb4fe-dc38-4ed0-85ba-5f746abe1550/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>BEAT 2019: Fourth Workshop on Behavioral Types</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>70b41f69-66e3-4602-a1b6-850da35911e0</subevent_id>
    <title>LAFI: Dirichlet</title>
    <timeslot>
      <slot_id>977d7df9-7ec8-4e30-b8a6-7863aa660cd3</slot_id>
      <title>Session: LAFI - Dirichlet</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/15</date>
      <start_time>16:00</start_time>
      <end_time>17:30</end_time>
      <tracks>
        <track>LAFI 2019: Languages for Inference (formerly PPS)</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VI   </room>
    <date>2019/01/15</date>
    <url>https://popl19.sigplan.org/track/lafi-2019</url>
    <url_link_display>LAFI 2019: Languages for Inference (formerly PPS)</url_link_display>
    <tracks>
      <track>LAFI 2019: Languages for Inference (formerly PPS)</track>
    </tracks>
    <timeslot>
      <slot_id>08534e5a-a2f3-4573-a175-3546c97f7468</slot_id>
      <title>Factorized Exact Inference for Discrete Probabilistic Programs</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/15</date>
      <start_time>16:30</start_time>
      <end_time>17:00</end_time>
      <description>In this work, we seek to close the performance gap between exact inference in discrete graphical models and discrete-valued finite-domain probabilistic programs. The key idea behind existing state-of-the-art inference procedures in discrete graphical models is to compile the graphical model into a representation known as a weighted Boolean formula (WBF), which is a symbolic representation of the joint probability distribution over the graphical model’s random variables. This symbolic representation exposes key structural elements of the distribution, such as independences between random variables. Then, inference is performed via a weighted sum of the models of the WBF, a process known as weighted model counting (WMC). This WMC process exploits the independences present in the WBF, and is thus efficient. Inference via WMC is currently the state-of-the-art exact inference strategy for discrete graphical models, probabilistic logic programming languages, and probabilistic databases.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Steven</first_name>
          <last_name>Holtzen</last_name>
          <affiliation>University of California, Los Angeles</affiliation>
          <bio>I am a PhD. student at U.C.L.A., co-advised by Guy Van den Broeck and Todd Millstein.</bio>
          <homepage_url>http://web.cs.ucla.edu/~sholtzen</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Joe</first_name>
          <last_name>Qian</last_name>
          <affiliation>University of California, Los Angeles</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Todd</first_name>
          <last_name>Millstein</last_name>
          <affiliation>University of California, Los Angeles</affiliation>
          <bio>I am a Professor in the Computer Science Department at the University of California, Los Angeles (UCLA). 
I was the Program Chair for OOPSLA 2014.</bio>
          <homepage_url>http://www.cs.ucla.edu/~todd/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/toddmillstein/03692d64-e4ad-4fb1-a2b0-9271ce27715c/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Guy</first_name>
          <last_name>Van den Broeck</last_name>
          <affiliation>University of California, Los Angeles</affiliation>
          <bio>I am an Assistant Professor and Samueli Fellow at UCLA, in the Computer Science Department. My research interests are in Machine Learning (Statistical Relational Learning), Knowledge Representation and Reasoning (Graphical Models, Lifted Probabilistic Inference), Applications of Probabilistic Reasoning and Learning (Probabilistic Programming, Probabilistic Databases), and Artificial Intelligence in general. I previously was a postdoctoral researcher at UCLA’s Automated Reasoning lab and KU Leuven’s Declarative Languages and Artificial Intelligence lab.</bio>
          <homepage_url>http://web.cs.ucla.edu/~guyvdb/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/guyvandenbroeck/4c8a474f-a124-4434-a370-43b4892bbe2c/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>LAFI 2019: Languages for Inference (formerly PPS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6ee06ea3-5287-4d22-8a18-738a8a2d7d63</slot_id>
      <title>Verified equational reasoning on a little language of measures</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/15</date>
      <start_time>17:00</start_time>
      <end_time>17:30</end_time>
      <description>We reason about measure equality by asserting axioms in Coq. The axioms constitute a small embedded monadic DSL, with standard primitives for random choice and scoring, and with intuitive equalities such as distributing random choices and multiplying scores. The axioms are only sound under the assumption that all functions are measurable and all measures are s-finite. Combined with inductive types and proofs, the axioms allow us to prove the correctness of probabilistic program transformations (including simplification and disintegration) and sampling techniques (including importance sampling and sequential Monte Carlo).</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Heimerdinger</last_name>
          <affiliation>Indiana University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Chung-chieh</first_name>
          <last_name>Shan</last_name>
          <affiliation>Indiana University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homes.soic.indiana.edu/ccshan/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/chungchiehshan/5f1d6cc2-6e76-484a-bafe-85460ba4c6e5/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>LAFI 2019: Languages for Inference (formerly PPS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a3aeb633-7ea7-49a5-90a0-9b1906ebdd30</slot_id>
      <title>Probabilistic Programming Inference via Intensional Semantics</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/15</date>
      <start_time>16:00</start_time>
      <end_time>16:30</end_time>
      <description>We define a new denotational semantics for a first-order probabilistic programming language in terms of probabilistic event structures. The semantics adequately models the language, in the sense that the usual measure-theoretic semantics of a program can be recovered from its event structure representation. 
Moreover it is intensional: occurrences of sampling and conditioning are recorded as explicit events, partially ordered according to the dependencies between the corresponding variables. This information can be leveraged for MCMC inference: we prove correct a version of single-site Metropolis-Hastings with ‘incremental recomputation’: the proposal kernel takes into account those dependencies in order to avoid performing some of the redundant sampling.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Simon</first_name>
          <last_name>Castellan</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Hugo</first_name>
          <last_name>Paquet</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>LAFI 2019: Languages for Inference (formerly PPS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>561d406f-dcb2-4f2b-a90a-f9e0403f395d</subevent_id>
    <title>Off the Beaten Track: Informal + Business meeting</title>
    <timeslot>
      <slot_id>e9b2cdec-6700-4532-ac52-9d24e53d1b28</slot_id>
      <title>Session: Off the Beaten Track - Informal + Business meeting</title>
      <room>Hotel Cascais Miragem | Sala VII</room>
      <date>2019/01/19</date>
      <start_time>16:00</start_time>
      <end_time>17:30</end_time>
      <tracks>
        <track>Off the Beaten Track 2019</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VII</room>
    <date>2019/01/19</date>
    <url>https://popl19.sigplan.org/track/OBT-2019-papers</url>
    <url_link_display>Off the Beaten Track 2019</url_link_display>
    <tracks>
      <track>Off the Beaten Track 2019</track>
    </tracks>
  </subevent>
  <subevent>
    <subevent_id>bdbb53da-f53e-41a2-a96f-3f0349786fe3</subevent_id>
    <title>PriSC: Session 3</title>
    <timeslot>
      <slot_id>fd3f9ddd-f2a1-48c1-a425-2105876290cf</slot_id>
      <title>Session: PriSC - Session 3</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/13</date>
      <start_time>14:00</start_time>
      <end_time>15:30</end_time>
      <tracks>
        <track>Principles of Secure Compilation</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VI   </room>
    <date>2019/01/13</date>
    <url>https://popl19.sigplan.org/track/prisc-2019</url>
    <url_link_display>Principles of Secure Compilation</url_link_display>
    <tracks>
      <track>Principles of Secure Compilation</track>
    </tracks>
    <timeslot>
      <slot_id>3217ac76-d74d-4e72-89c3-1e962c98ef84</slot_id>
      <title>A Data Layout Description Language for Cogent</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/13</date>
      <start_time>15:00</start_time>
      <end_time>15:30</end_time>
      <description>Cogent is a high-level functional language that reduces the cost of writing and formally verifying efficient systems code. We introduce the design of Dargent, a data layout description language that enables customising memory layouts of Cogent algebraic datatypes. Dargent allows programmers to write more code in Cogent and to integrate Cogent code with existing C programs (e.g. the Linux kernel) more seamlessly.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Zilin</first_name>
          <last_name>Chen</last_name>
          <affiliation>Data61, CSIRO and UNSW</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ts.data61.csiro.au/people/?cn=Zilin+Chen</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/zilinchen/8f1a9633-3d85-4782-a684-797692288c3d/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Di Meglio</last_name>
          <affiliation>UNSW</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Liam</first_name>
          <last_name>O'Connor</last_name>
          <affiliation>UNSW</affiliation>
          <bio>Liam is a PhD student at UNSW Australia working on Trustworthy Systems projects with Data61 at CSIRO (formerly known as NICTA). His PhD work focuses on the use of linear typed languages to provide easy-to-reason-about semantics for formal verification of operating system components. More broadly, his research interests include automated proof and reasoning, particularly in the context of dependently typed programming languages, type inference, static analysis, and concurrency.</bio>
          <homepage_url>http://liamoc.net</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/liamoconnor/62bc9dba-ffaf-41b7-94db-85d112d608ea/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Partha</first_name>
          <last_name>Susarla</last_name>
          <affiliation>Data61, CSIRO</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Christine</first_name>
          <last_name>Rizkallah</last_name>
          <affiliation>UNSW</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.unsw.edu.au/~crizkallah/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/christinerizkallah/e181f947-fb32-4d02-a0e9-085ff6318d78/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Gabriele</first_name>
          <last_name>Keller</last_name>
          <affiliation>Utrecht University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.unsw.edu.au/~keller</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/gabrielekeller/101c0ceb-fc81-4bbd-becf-b99b62ef7303/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Principles of Secure Compilation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>86511710-7fe9-499a-8e4d-12ef3def6948</slot_id>
      <title>Security Witnesses for Compiler Transformations</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/13</date>
      <start_time>14:30</start_time>
      <end_time>15:00</end_time>
      <description>Compiler optimizations can be correct and yet be insecure. Program changes made during optimization may weaken security guarantees; for instance, by introducing new ways to leak secret data. This work presents a methodology for ensuring that security properties are preserved, at compile time. Properties are expressed as automata operating over a bundle of related program traces. A notion of automaton-based program refinement guarantees that the associated security property is preserved. In practice, such refinement relations can be generated by a compiler as it optimizes a source program, and validated with an independent refinement checker. This process formally establishes the security of every source-to-target transformation without, however, requiring a proof of correctness of the compiler implementation itself.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kedar</first_name>
          <last_name>Namjoshi</last_name>
          <affiliation>Bell Labs, Nokia</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Lucas M.</first_name>
          <last_name>Tabajara</last_name>
          <affiliation>Rice University</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Principles of Secure Compilation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9875a60f-3e91-4b98-8642-dda51d1953ae</slot_id>
      <title>Translation Validation for Security Properties</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/13</date>
      <start_time>14:00</start_time>
      <end_time>14:30</end_time>
      <description>Secure compilation aims to build compilation chains that preserve security properties when translating programs from a source to a target language. Recent research led to the definition of secure compilation principles that, if met, guarantee that the compilation chain in hand never violates specific families of security properties. Still, to the best of our knowledge, no effective procedure is available to check if a compilation chain meets such requirements. Here, we outline our ongoing research inspired by translation validation, to effectively check one of those principles.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matteo</first_name>
          <last_name>Busi</last_name>
          <affiliation>Università di Pisa - Dipartimento di Informatica</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Pierpaolo</first_name>
          <last_name>Degano</last_name>
          <affiliation>Università di Pisa - Dipartimento di Informatica</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Letterio</first_name>
          <last_name>Galletta</last_name>
          <affiliation>IMT School for Advanced Studies</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Principles of Secure Compilation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>63b6789c-b57d-4f6e-8fcb-0717b9731d10</subevent_id>
    <title>CoqPL: Contributed talks 3 &amp; Coq developers</title>
    <timeslot>
      <slot_id>66799446-89a4-4dc2-b8d8-e0bf3b2e153b</slot_id>
      <title>Session: CoqPL - Contributed talks 3 &amp; Coq developers</title>
      <room>Hotel Cascais Miragem | Sala VI</room>
      <date>2019/01/19</date>
      <start_time>14:00</start_time>
      <end_time>15:30</end_time>
      <tracks>
        <track>The Fifth International Workshop on Coq for Programming Languages</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VI</room>
    <date>2019/01/19</date>
    <url>https://popl19.sigplan.org/track/CoqPL-2019</url>
    <url_link_display>The Fifth International Workshop on Coq for Programming Languages</url_link_display>
    <tracks>
      <track>The Fifth International Workshop on Coq for Programming Languages</track>
    </tracks>
    <timeslot>
      <slot_id>3c065112-fdc6-4ae9-b683-547b4eb8daea</slot_id>
      <title>Reifying and translating a monadic fragment of Gallina</title>
      <room>Hotel Cascais Miragem | Sala VI</room>
      <date>2019/01/19</date>
      <start_time>14:25</start_time>
      <end_time>14:50</end_time>
      <description>We present ongoing work on verified compilation of imperative functional code in Coq, relying on the CompCert C compiler and using a reflective approach. Here we focus on the reflection of a monadic fragment of Gallina, corresponding to a first-order imperative language with primitive recursion, in a deeply embedded extensible language that we call DEC2 and which can be translated to the CompCert C front-end. DEC2 has an operational interpreter based on small-step semantics, and a denotational interpreter based on its reflective translation into Gallina. In particular, here we will focus on the technique used in proving the adequacy of reflection, by constructing the two interpreters together with a proof of their extensional equality.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Paolo</first_name>
          <last_name>Torrini</last_name>
          <affiliation>Swansea University</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>The Fifth International Workshop on Coq for Programming Languages</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a35159cf-5f72-403f-9e2f-5c9ba77111d7</slot_id>
      <title>Reification of shallow-embedded DSLs in Coq with automated verification</title>
      <room>Hotel Cascais Miragem | Sala VI</room>
      <date>2019/01/19</date>
      <start_time>14:00</start_time>
      <end_time>14:25</end_time>
      <description>Shallow and deep embeddings of DSLs have their pros and cons. For example, shallow embedding is excellent for quick prototyping, as it allows quick extension or modification of the embedded language. Meanwhile, deep embedding is better suited for code transformation and compilation. Thus, it might be useful to be able to switch from shallow to deep embedding while making sure the semantics of the embedded language are preserved. We will demonstrate a working approach for implementing and proving such conversion using TemplateCoq.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Vadim</first_name>
          <last_name>Zaliva</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.crocodile.org/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/vadimzaliva/4040c6ca-a563-443f-81d3-19b2828e7dea/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Matthieu</first_name>
          <last_name>Sozeau</last_name>
          <affiliation>Inria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.pps.univ-paris-diderot.fr/~sozeau/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/matthieusozeau/d1a3ad89-73f4-44cc-8f0b-830f395d9953/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>The Fifth International Workshop on Coq for Programming Languages</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a7f79ef8-f006-471e-8405-0eda72015bf7</slot_id>
      <title>Session with the Coq Development Team</title>
      <room>Hotel Cascais Miragem | Sala VI</room>
      <date>2019/01/19</date>
      <start_time>14:50</start_time>
      <end_time>15:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Maxime</first_name>
          <last_name>Dénès</last_name>
          <affiliation>INRIA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.maximedenes.fr/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Matthieu</first_name>
          <last_name>Sozeau</last_name>
          <affiliation>Inria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.pps.univ-paris-diderot.fr/~sozeau/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/matthieusozeau/d1a3ad89-73f4-44cc-8f0b-830f395d9953/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>The Fifth International Workshop on Coq for Programming Languages</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ce701c5f-82d9-413b-ab27-827ef511954a</subevent_id>
    <title>BEAT: Session 1</title>
    <timeslot>
      <slot_id>b0fca7c7-8e02-4f84-8c7d-5275365367c8</slot_id>
      <title>Session: BEAT - Session 1</title>
      <room>Hotel Cascais Miragem | Sala VII</room>
      <date>2019/01/13</date>
      <start_time>08:30</start_time>
      <end_time>10:30</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Philip</first_name>
          <last_name>Wadler</last_name>
          <affiliation>University of Edinburgh, UK</affiliation>
          <bio>Philip Wadler is Professor of Theoretical Computer Science at the University of Edinburgh. He is an ACM Fellow and a Fellow of the Royal Society of Edinburgh, past chair of ACM SIGPLAN, past holder of a Royal Society-Wolfson Research Merit Fellowship, winner of the SIGPLAN Distinguished Service Award, and a winner of the POPL Most Influential Paper Award. Previously, he worked or studied at Stanford, Xerox Parc, CMU, Oxford, Chalmers, Glasgow, Bell Labs, and Avaya Labs, and visited as a guest professor in Copenhagen, Sydney, and Paris. He has an h-index of 60, with more than 20,000 citations to his work according to Google Scholar. He contributed to the designs of Haskell, Java, and XQuery, and is a co-author of Introduction to Functional Programming (Prentice Hall, 1988), XQuery from the Experts (Addison Wesley, 2004) and Generics and Collections in Java (O’Reilly, 2006). He has delivered invited talks in locations ranging from Aizu to Zurich.</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/wadler/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/philipwadler/55a9683e-908b-4052-9d49-20fb795c74cf/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>BEAT 2019: Fourth Workshop on Behavioral Types</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VII</room>
    <date>2019/01/13</date>
    <url>https://popl19.sigplan.org/track/beat-2019-papers</url>
    <url_link_display>BEAT 2019: Fourth Workshop on Behavioral Types</url_link_display>
    <tracks>
      <track>BEAT 2019: Fourth Workshop on Behavioral Types</track>
    </tracks>
    <timeslot>
      <slot_id>1cdd7660-142d-48d2-a572-fdf1373a629a</slot_id>
      <title>Invited Talk: Gradual Session Types — an Ongoing Journey</title>
      <room>Hotel Cascais Miragem | Sala VII</room>
      <date>2019/01/13</date>
      <start_time>08:40</start_time>
      <end_time>09:30</end_time>
      <description>Gradual Session Types enable the connection of typed and untyped clients of a protocol. The type checker guarantees that the typed client follows the protocol, whereas dynamic checks, generated by gradual session type inference, guarantee that the untyped client follows the protocol, too. The journey begins with a coercion calculus that extends Gay and Vasconcelos functional session type language and considers a surface language and gradual type inference. It continues with the observation that the untyped language is not sufficiently untyped and offers a more economic calculus as a basis for a surface language that supports untyped programming in a satisfactory style. 
Parts of this work are based on collaboration with Atsushi Igarashi, Vasco Vasconcelos, and Phil Wadler.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Peter</first_name>
          <last_name>Thiemann</last_name>
          <affiliation>University of Freiburg, Germany</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/peterthiemann/43fc0175-1745-4b3a-b626-86e10da76b86/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>BEAT 2019: Fourth Workshop on Behavioral Types</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7dc3124f-0448-4b93-ba5f-93639ac68b6d</slot_id>
      <title>Opening</title>
      <room>Hotel Cascais Miragem | Sala VII</room>
      <date>2019/01/13</date>
      <start_time>08:30</start_time>
      <end_time>08:40</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Antonio</first_name>
          <last_name>Ravara</last_name>
          <affiliation>Department of Informatics, Faculty of Sciences and Technology, NOVA University of Lisbon and NOVA LINCS</affiliation>
          <bio>Associate Professor at the Department of Informatics, Faculty of Sciences and Technology, NOVA University of Lisbon, Portugal (since October 2018). Founding member and Integrated researcher at the NOVA Laboratory for Computer Science and Informatics (NOVA LINCS), Portugal (since 2013). Assistant Professor at the Department of Informatics, Faculty of Sciences and Technology, NOVA University of Lisbon, Portugal ()2009 to 2018). Assistant Professor at the Section of Logic and Computation of the Department of Mathematics of IST. Technical University of Lisbon, Portugal (2000 to 2009). 
PhD in Mathematics at IST, of the Technical University of Lisbon, Portugal (December 2000). MSc in Applied Mathematics at IST of the Technical University of Lisbon, Portugal (May 1996). BSc in Geographical Engineering at the Faculty of Sciences of the University of Lisbon, Portugal (September 1991). 
Main research problem is how to ensure that inherently concurrent, highly distributed, software systems behave correctly. The focus is on the development of techniques, program constructions, and tools that help creating safe and well-behaved systems, provably providing correctness guarantees. The toolbox used includes static analysis of source code, capturing defects before deployment, with decidable, low complexity, property-driven, proof systems, using behavioural descriptions of programs.</bio>
          <homepage_url>http://nova-lincs.di.fct.unl.pt/person/47</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/antonioravara/dbb3f737-58d8-45cf-9c93-a54da5788412/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jorge A.</first_name>
          <last_name>Pérez</last_name>
          <affiliation>University of Groningen, The Netherlands</affiliation>
          <bio> 
 Assistant Professor, University of Groningen, The Netherlands (Since 2014) 
 Postdoctoral Researcher, NOVA University of Lisbon, Portugal (2010 - 2014) 
 PhD student, University of Bologna, Italy (2007 - 2010) 
</bio>
          <homepage_url>http://www.jperez.nl</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/jorgeaperez/4e196e9f-a731-4e6d-9291-594dde28347f/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>BEAT 2019: Fourth Workshop on Behavioral Types</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>87c8a713-6b4b-4e60-9a77-f1d704681548</slot_id>
      <title>Checking the equivalence of context-free session types</title>
      <room>Hotel Cascais Miragem | Sala VII</room>
      <date>2019/01/13</date>
      <start_time>09:50</start_time>
      <end_time>10:10</end_time>
      <description>Context-free session types were proposed as an extension of session types able to capture the type-safe serialization of recursive datatypes. For the sake of a practical usage, namely in the definition of new programming languages, there is an urgent need for an algorithm to decide type equivalence. In this work, we propose an algorithm to decide type equivalence on context-free session types. Based on the construction we followed and on the tests we ran to validate the algorithm, we expect the algorithm to be sound and complete.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Andreia</first_name>
          <last_name>Mordido</last_name>
          <affiliation>Lasige / Faculty of Sciences, Universidade de Lisboa</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Vasco</first_name>
          <last_name>Vasconcelos</last_name>
          <affiliation>LASIGE, Faculty of Sciences, University of Lisbon</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.di.fc.ul.pt/~vv/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/vascovasconcelos/b1bd0216-3fdb-4835-a89a-1e03a5fd6714/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>BEAT 2019: Fourth Workshop on Behavioral Types</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a85143b7-dd78-4c7e-a7fc-d673715d7a37</slot_id>
      <title>Effpi: concurrent programming with dependent behavioural types</title>
      <room>Hotel Cascais Miragem | Sala VII</room>
      <date>2019/01/13</date>
      <start_time>10:10</start_time>
      <end_time>10:30</end_time>
      <description>This is a report of ongoing work 
Concurrent and distributed programming is notoriously hard. Many languages and software toolkits address the challenge by offering high-level abstractions, such as message-passing processes and actors; they allow for intuitive reasoning, but do not formally ensure that a program implements a given specification. 
We address this challenge with Effpi: a toolkit for strongly-typed concurrent programming in Dotty (a.k.a. the future Scala 3 programming language). Effpi allows to specify the intended behaviour of a message-passing application using types: i.e., if a program type-checks and compiles, then it will run and communicate as prescribed by its types. 
The foundation of Effpi is a concurrent functional language with a novel blend of behavioural types and a form of dependent types, extending to higher-order interaction (i.e., sending/receiving mobile code). This design has three main advantages. First, it allows to statically verify programs through a combination of type checking and model checking techniques. Second, it is directly implemented (via deep embedding) in Dotty, including a simplified API for strongly-typed actor-based programming. And third, its functional nature allows for an efficient runtime system, supporting highly concurrent programs with millions of interacting processes / actors.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alceste</first_name>
          <last_name>Scalas</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~ascalas/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/alcestescalas/a32ab3bc-89ad-4ae7-9121-b8407bb836bf/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Elias</first_name>
          <last_name>Benussi</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>BEAT 2019: Fourth Workshop on Behavioral Types</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>aa98aadf-cf24-4e7c-8286-0f47ee17174d</slot_id>
      <title>Gradual Session Types in Imperative Style</title>
      <room>Hotel Cascais Miragem | Sala VII</room>
      <date>2019/01/13</date>
      <start_time>09:30</start_time>
      <end_time>09:50</end_time>
      <description>Gradual typing, proposed by Siek and Taha, is one of the attempts to integrate static and dynamic typing in a single language. Igarashi et al. proposed gradual session types, which extend gradual typing to binary session types. The language they studied is an extension of functional session types in which channels must be handled linearly. In this work, we propose a gradually typed extension of imperative session types, in which a single channel name is used more than once for communication. In this talk proposal, we describe an overview of our calculus, focusing on the delta over the previous work.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kaede</first_name>
          <last_name>Kobayashi</last_name>
          <affiliation>Kyoto University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Atsushi</first_name>
          <last_name>Igarashi</last_name>
          <affiliation>Kyoto University, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fos.kuis.kyoto-u.ac.jp/~igarashi/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/atsushiigarashi/bbac1695-343a-4091-b33c-b7f01dea73da/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>BEAT 2019: Fourth Workshop on Behavioral Types</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>64a67941-b47a-491b-8411-ac22b0c55cec</subevent_id>
    <title>CoqPL: Contributed talks 4</title>
    <timeslot>
      <slot_id>17c28538-e3f4-48e9-8a3f-c65f0169dda4</slot_id>
      <title>Session: CoqPL - Contributed talks 4</title>
      <room>Hotel Cascais Miragem | Sala VI</room>
      <date>2019/01/19</date>
      <start_time>16:00</start_time>
      <end_time>17:40</end_time>
      <tracks>
        <track>The Fifth International Workshop on Coq for Programming Languages</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VI</room>
    <date>2019/01/19</date>
    <url>https://popl19.sigplan.org/track/CoqPL-2019</url>
    <url_link_display>The Fifth International Workshop on Coq for Programming Languages</url_link_display>
    <tracks>
      <track>The Fifth International Workshop on Coq for Programming Languages</track>
    </tracks>
    <timeslot>
      <slot_id>05ee22bf-e0ec-4b34-afd6-5852def7815c</slot_id>
      <title>Deep Embedded Hoare Logic for Building Machine-Checkable Foundational Program Correctness Proofs</title>
      <room>Hotel Cascais Miragem | Sala VI</room>
      <date>2019/01/19</date>
      <start_time>16:00</start_time>
      <end_time>16:25</end_time>
      <description>Many interactive program verification tools are Hoare logic based. Hoare logics and their assertion languages can be formalized by either shallow embedding or deep embedding. The pros and cons of shallowly/deeply embedded formalization for assertion languages have been discussed for long time. But when it comes to the formalization for proof theories, tools like early versions of Verified Software Toolchain (VST), Iris-rust, Charge! etc. all choose shallow embedding to formalize their Hoare logics. 
Some useful Hoare logic proof rules are nonderivable from primary rules. At the same time, their soundness proofs can be long and tedious. This talk introduces deeply embedded Hoare logics which solves this problem, avoid long, complex semantic reasoning and proves those rules as meta-properties. We have used this technique in the latest version of VST.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Qinxiang</first_name>
          <last_name>Cao</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>The Fifth International Workshop on Coq for Programming Languages</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2c2f2e01-f2d5-4144-855d-439e7fe4ff24</slot_id>
      <title>Towards a Coq Formalisation of Build Systems</title>
      <room>Hotel Cascais Miragem | Sala VI</room>
      <date>2019/01/19</date>
      <start_time>17:15</start_time>
      <end_time>17:40</end_time>
      <description>The gene pool of software build systems and various incremental computation frameworks is becoming richer every day. These complex build systems and frameworks use subtle algorithms and are mission-critical, yet to the best of our knowledge they come with no formal proofs of correctness. 
A recent ICFP paper “Build Systems à la Carte” presented a definition of correctness for build systems, and modelled several major build systems in Haskell, without exhibiting any proof of their correctness. We build on this work by translating the Haskell abstractions to Coq and making the necessary adjustments to capture the notion of build task acyclicity, which is essential for proving termination. 
This is an experience report on on-going work which is very far from being complete. We present our motivation and key abstractions developed so far, and seek feedback and collaboration from the Coq community.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Georgy</first_name>
          <last_name>Lukyanov</last_name>
          <affiliation>Newcastle University, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://geo2a.github.io</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/georgylukyanov1/07832b0f-b979-4dba-ae6c-10a093ba1e99/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andrey</first_name>
          <last_name>Mokhov</last_name>
          <affiliation>Newcastle University, UK</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>The Fifth International Workshop on Coq for Programming Languages</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2e8df53d-b0cd-49ca-98db-6fc3234573a0</slot_id>
      <title>Teaching Discrete Mathematics to Early Undergraduates with Software Foundations</title>
      <room>Hotel Cascais Miragem | Sala VI</room>
      <date>2019/01/19</date>
      <start_time>16:25</start_time>
      <end_time>16:50</end_time>
      <description>We will present our early experiences teaching first- and second-year computer science students in Coq, adapting Logical Foundations (the first volume of Software Foundations). Our presentation’s goals are: to offer evidence that such a course is pedagogically sound; to highlight the pedagogical approach taken to teaching Coq and informal proof simultaneously; to document successes and failures, both pedagogically and in Coq’s technical ecosystem; and to seek feedback on pedagogy and course design. 
The first author will give the talk.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Greenberg</last_name>
          <affiliation>Pomona College</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.pomona.edu/~michael/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/michaelgreenberg/3c177ea6-ac3c-4ddb-9f4e-ac5d7b568e07/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Joseph C.</first_name>
          <last_name>Osborn</last_name>
          <affiliation>Pomona College</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>The Fifth International Workshop on Coq for Programming Languages</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6c235ca5-4877-459e-b5a3-12e0e6a54865</slot_id>
      <title>Ltac2: Tactical Warfare</title>
      <room>Hotel Cascais Miragem | Sala VI</room>
      <date>2019/01/19</date>
      <start_time>16:50</start_time>
      <end_time>17:15</end_time>
      <description>We present Ltac2, a proposal for the replacement of the Ltac tactic language that is shipped with Coq as the default interface to build up proofs interactively. Ltac2 is primarily motivated by two antagonistic desires, namely extending the expressivity and regularity of the historical tactic language of Coq while maintaining a strong backward compatibility. We thereafter give a bird’s eye view of the features and semantics of the current state of Ltac2.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Pierre-Marie</first_name>
          <last_name>Pédrot</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>The Fifth International Workshop on Coq for Programming Languages</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c757adf3-e94a-4562-8b34-ab5df12713a2</subevent_id>
    <title>PriSC: Session 2</title>
    <timeslot>
      <slot_id>67ab1b97-a101-48ce-a876-c8f7d412e338</slot_id>
      <title>Session: PriSC - Session 2</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/13</date>
      <start_time>11:00</start_time>
      <end_time>12:30</end_time>
      <tracks>
        <track>Principles of Secure Compilation</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VI   </room>
    <date>2019/01/13</date>
    <url>https://popl19.sigplan.org/track/prisc-2019</url>
    <url_link_display>Principles of Secure Compilation</url_link_display>
    <tracks>
      <track>Principles of Secure Compilation</track>
    </tracks>
    <timeslot>
      <slot_id>164e61ba-853e-4767-81e8-8c4b1e2e222a</slot_id>
      <title>Trestle: Bridging the Performance and Safety Divide in WebAssembly</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/13</date>
      <start_time>11:00</start_time>
      <end_time>11:30</end_time>
      <description>There are significant contrasts in the security offered by different portable byte code architectures. There are those with abstracted, object based memory models, like the JVM and CLR, that provide strong memory safety, but support only higher-level, garbage-collected languages. WebAssembly (Wasm) is at the other extreme. Its linear memory model offers efficiency and compatibility with languages like C/C++, but sacrifices memory safety. Given the growing importance of \wasm, we believe that we must address this lack of safety, or risk a web that inherits the legacy of memory based vulnerabilities that have plagued native platforms for decades. Towards this end we propose Trestle, a protection model for \wasm that seeks to offer stronger memory safety for low level code targetting linear memory, with minimal impact on performance and compatibility. 
Our goal with Trestle is to encode safety policies that are precise, but still leave it up to different architectures that Wasm targets to implement these as efficiently and securely as possible. 
Our approach starts by adding a new memory handle type to Wasm that expresses memory safety policies for a range of memory, and a new set of load and store instructions that understand handles. Using this abstraction, the compiler can express fine grain policies in Wasm, which it can then efficiently enforce in a platform specific manner. We present our proposal for Trestle and discuss some design and implementation considerations that inform it.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Craig</first_name>
          <last_name>Disselkoen</last_name>
          <affiliation>University of California San Diego</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tal</first_name>
          <last_name>Garfinkel</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Deian</first_name>
          <last_name>Stefan</last_name>
          <affiliation>University of California San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cseweb.ucsd.edu/~dstefan/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/deianstefan/55e73d29-9671-4740-9ef2-3b45f485fc24/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Conrad</first_name>
          <last_name>Watt</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/conradwatt/d6df970c-7c11-418a-adb0-789ef78042eb/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Principles of Secure Compilation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bf76f2b9-0c79-4264-b218-90f6657be8bd</slot_id>
      <title>Protecting C++ applications using CHERI</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/13</date>
      <start_time>11:30</start_time>
      <end_time>12:00</end_time>
      <description>C++ remains the language of choice for writing large performant server and client applications but lacks memory- and type-safety and is thus vulnerable to spatial and temporal-related security attacks. The CHERI architecture provides fine-grained memory protection in hardware. We have developed the CHERI Clang/LLVM compiler that can compile existing C and C++ programs to CHERI, thus enabling strong memory protection with minimal changes to code.&amp;nbsp;More recently, we have been looking at using CHERI to protect C++ applications: there are many interesting design-space questions as to how the CHERI protection model could be used to protect the C++ run-time (e.g. vtables) and C++ programs in general. We have been investigating some of these through the rendering engine WebKit, commonly used in popular web browsers. This talk will present some of the ways CHERI can be used in the context of C++ with the hope of inviting further discussion.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Khilan</first_name>
          <last_name>Gudka</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alexander</first_name>
          <last_name>Richardson</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Robert N. M.</first_name>
          <last_name>Watson</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Principles of Secure Compilation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c3360cc8-75be-49cd-80fc-9e09a36ca14d</slot_id>
      <title>Secure Linking in the CheriBSD Operating System</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/13</date>
      <start_time>12:00</start_time>
      <end_time>12:30</end_time>
      <description>Pointers are a foundational abstraction in C-language program structure and also a critical battleground for vulnerability exploit and mitigation techniques. Whereas conventional compilers and architectures implement pointers as integer virtual addresses, the CHERI architecture allows pointers to be implemented as capabilities in a way that is compatible with the semantics of the C language. In addition to the spatial protections offered by conventional fat pointers, CHERI capabilities offer strong integrity, enforced provenance validity, and access monotonicity. This talk will focus on the challenges and opportunities that CHERI brings to dynamic linking for C (and C++) programs running on a POSIX operating system (CheriBSD). I will also present possible design trade-offs and opportunities for strong memory protection and compartmentalization. Unlike commonly-used process-based compartmentalization my implementation does not require any changes to the library source code (beyond those required in order to compile as a pure-capability program). Moreover, the extent of privilege reduction can be adjusted both at run time and during compilation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alexander</first_name>
          <last_name>Richardson</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Robert N. M.</first_name>
          <last_name>Watson</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Principles of Secure Compilation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ab30ddfc-1a6f-4a6e-b3f3-e2bf6f59048a</subevent_id>
    <title>PLMW: PLMW Session 2</title>
    <timeslot>
      <slot_id>ee81713e-4f72-49e7-a03e-4f666e338030</slot_id>
      <title>Session: PLMW - PLMW Session 2</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/15</date>
      <start_time>11:00</start_time>
      <end_time>12:30</end_time>
      <tracks>
        <track>Programming Languages Mentoring Workshop 2019</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala II</room>
    <date>2019/01/15</date>
    <url>https://popl19.sigplan.org/track/PLMW-2019-papers</url>
    <url_link_display>Programming Languages Mentoring Workshop 2019</url_link_display>
    <tracks>
      <track>Programming Languages Mentoring Workshop 2019</track>
    </tracks>
    <timeslot>
      <slot_id>43e2b3bc-e0fa-4472-aff8-a2fa6b36adcd</slot_id>
      <title>Panel: Grad School and Beyond</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/15</date>
      <start_time>11:30</start_time>
      <end_time>12:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Panelist</role>
          <sort_key>1</sort_key>
          <first_name>Stephanie</first_name>
          <last_name>Balzer</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~balzers/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/stephaniebalzer/f9d2b097-d049-4f71-b0d4-d7870c219338/small.jpg</picture_url>
        </person>
        <person>
          <role>Panelist</role>
          <sort_key>2</sort_key>
          <first_name>Max</first_name>
          <last_name>New</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://maxsnew.github.io</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/maxnew/1032d55a-9db1-4f7d-bf53-3dd3e80cea6d/small.jpg</picture_url>
        </person>
        <person>
          <role>Panelist</role>
          <sort_key>3</sort_key>
          <first_name>Dominic</first_name>
          <last_name>Orchard</last_name>
          <affiliation>University of Kent, UK</affiliation>
          <bio>Dr Dominic Orchard is a Lecturer in the School of Computing at the University of Kent, UK and he is a fellow of the SSI. His research interests are programming language design and semantics, mathematically structured programming, effect and coeffect systems, embedded domain-specific languages (esp. for parallelisation), and applying programming language research to computational science.</bio>
          <homepage_url>http://dorchard.co.uk</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/dominicorchard/f448aa26-a342-457c-91a6-3f9525a759a3/small.jpg</picture_url>
        </person>
        <person>
          <role>Panelist</role>
          <sort_key>4</sort_key>
          <first_name>Jorge A.</first_name>
          <last_name>Pérez</last_name>
          <affiliation>University of Groningen, The Netherlands</affiliation>
          <bio> 
 Assistant Professor, University of Groningen, The Netherlands (Since 2014) 
 Postdoctoral Researcher, NOVA University of Lisbon, Portugal (2010 - 2014) 
 PhD student, University of Bologna, Italy (2007 - 2010) 
</bio>
          <homepage_url>http://www.jperez.nl</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/jorgeaperez/4e196e9f-a731-4e6d-9291-594dde28347f/small.jpg</picture_url>
        </person>
        <person>
          <role>Panelist</role>
          <sort_key>5</sort_key>
          <first_name>Azalea</first_name>
          <last_name>Raad</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.SoundAndComplete.org</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/azalearaad/180ee602-475f-483f-a01b-ea187c9e8ac1/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Programming Languages Mentoring Workshop 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e3b413fa-3559-488c-94e8-15a5b2023ae5</slot_id>
      <title>Research Skills: How to Choose Research Areas</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/15</date>
      <start_time>11:00</start_time>
      <end_time>11:30</end_time>
      <description>Some of my colleagues stay in the same research area all their life. Others, like me, have changed area many times. In this talk I will explain the motivations that determined my choices, and I will discuss advantages and disadvantages, risks and joys of discovering new research topics and communities.</description>
      <persons>
        <person>
          <role>Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Catuscia</first_name>
          <last_name>Palamidessi</last_name>
          <affiliation>INRIA and LIX</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.lix.polytechnique.fr/~catuscia/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/catusciapalamidessi/8fb1366e-3699-4209-834e-38ce776be5d5/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Programming Languages Mentoring Workshop 2019</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6d880da9-3e15-41d1-9a82-6753312dc3e6</subevent_id>
    <title>Off the Beaten Track: Keynote</title>
    <timeslot>
      <slot_id>7a94d797-0da2-4a9d-b22b-4ec215b33014</slot_id>
      <title>Session: Off the Beaten Track - Keynote</title>
      <room>Hotel Cascais Miragem | Sala VII</room>
      <date>2019/01/19</date>
      <start_time>09:00</start_time>
      <end_time>10:30</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Luke</first_name>
          <last_name>Church</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/lukechurch/3ab26f57-3738-4a38-a8be-8f6d1b69cd8f/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Off the Beaten Track 2019</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VII</room>
    <date>2019/01/19</date>
    <url>https://popl19.sigplan.org/track/OBT-2019-papers</url>
    <url_link_display>Off the Beaten Track 2019</url_link_display>
    <tracks>
      <track>Off the Beaten Track 2019</track>
    </tracks>
    <timeslot>
      <slot_id>ce3104a2-c62b-49cf-ac62-499709087c84</slot_id>
      <title>De-escalating software (Keynote by Stephen Kell)</title>
      <room>Hotel Cascais Miragem | Sala VII</room>
      <date>2019/01/19</date>
      <start_time>09:30</start_time>
      <end_time>10:30</end_time>
      <description>What are the principles of programming languages? The world-view of mainstream programming language-related research has changed little since the 1970s. Programs should be correct and efficient; languages should engender those qualities, Latent among this is another 1970s idea: that growth in infrastructural complexity is the expected trajectory of development, and that the power of mechanisation will render that complexity tractable. In many domains of human activity, such as farming, transportation, corporate management and education, that thinking is showing its limitations. What about software? In this talk, which will offer far more questions than answers, I’ll consider what research goals and avenues might emerge from certain alternative principles inspired by an analogous reaction against convention. Among the alternative principles I’ll discuss are ones I’ll call authorial capability (influencing e.g. approaches to modularity and refactoring), complexity budgeting (influencing e.g. approaches to build tooling, dependency management and testing), and scaling via federation (influencing approaches to distribution and interface specification).</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Kell</last_name>
          <affiliation>University of Kent</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.kent.ac.uk/people/staff/srk21</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/stephenkell/53088184-3e8c-4a2c-b34f-b2a290cff411/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Off the Beaten Track 2019</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7e64cf1a-caf4-4531-8329-f6e562c82208</subevent_id>
    <title>PriSC: Session 1</title>
    <timeslot>
      <slot_id>23da0f35-293d-49b7-9a90-b92d6b7a97d9</slot_id>
      <title>Session: PriSC - Session 1</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/13</date>
      <start_time>09:00</start_time>
      <end_time>10:30</end_time>
      <tracks>
        <track>Principles of Secure Compilation</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VI   </room>
    <date>2019/01/13</date>
    <url>https://popl19.sigplan.org/track/prisc-2019</url>
    <url_link_display>Principles of Secure Compilation</url_link_display>
    <tracks>
      <track>Principles of Secure Compilation</track>
    </tracks>
    <timeslot>
      <slot_id>457d1b12-26ea-4d64-a15d-7146bca0a7ac</slot_id>
      <title>PriSC Keynote - Jasmin: A Compiler and Framework for High-Assurance and High-Speed Cryptography</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/13</date>
      <start_time>09:00</start_time>
      <end_time>10:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Benjamin</first_name>
          <last_name>Gregoire</last_name>
          <affiliation>INRIA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www-sop.inria.fr/members/Benjamin.Gregoire/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Principles of Secure Compilation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6566d70f-2282-41b7-a49b-ec75b296ee92</slot_id>
      <title>Towards Secure Compilation of Power Side-Channel Countermeasures</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/13</date>
      <start_time>10:00</start_time>
      <end_time>10:30</end_time>
      <description>Software countermeasures against power side-channel attacks are an active research area in cryptography and cryptanalysis. To date, no compiler provides dependable compilation from high-level languages since respective security properties are systematically broken at compile time. There is a strong demand for secure compilation as it is a difficult and error prone task to implement, adopt and verify handwritten assembly for each targeted platform. We provide a characterization of the probing security policy for power side-channel countermeasures, related preservation problems and sketch an approach for future work to close the gap between abstract algorithms and their secure implementation or compilation to relevant architectures.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Marc</first_name>
          <last_name>Gourjon</last_name>
          <affiliation>Hamburg University of Technology and NXP Semiconductors Germany GmbH</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Principles of Secure Compilation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>3f4c23c8-864a-47fc-8d9f-732870474f35</subevent_id>
    <title>PLMW: PLMW Session 3</title>
    <timeslot>
      <slot_id>4d87515f-7f1f-40ee-8e79-1080db283184</slot_id>
      <title>Session: PLMW - PLMW Session 3</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/15</date>
      <start_time>14:00</start_time>
      <end_time>15:30</end_time>
      <tracks>
        <track>Programming Languages Mentoring Workshop 2019</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala II</room>
    <date>2019/01/15</date>
    <url>https://popl19.sigplan.org/track/PLMW-2019-papers</url>
    <url_link_display>Programming Languages Mentoring Workshop 2019</url_link_display>
    <tracks>
      <track>Programming Languages Mentoring Workshop 2019</track>
    </tracks>
    <timeslot>
      <slot_id>2ccd5eee-c68b-446c-b870-8ecf670fcab3</slot_id>
      <title>Technical Talk: How to Think about Types</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/15</date>
      <start_time>14:00</start_time>
      <end_time>14:45</end_time>
      <description>Types are a central concern in programming language research, with a multitude of different purposes, design principles, and criteria to judge them. Everyone will tell you a different story, and so will I, as I take you through a personal tour through the landscape of types. I will focus on what I believe are the major themes and what I have learned about how to approach research on programming languages when you look at them from the perspective of type systems.</description>
      <persons>
        <person>
          <role>Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Frank</first_name>
          <last_name>Pfenning</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.cmu.edu/~fp/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Programming Languages Mentoring Workshop 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d0fdd9f7-8dcc-4b10-a175-ba3da682da8d</slot_id>
      <title>Technical Talk: What Is Programming Languages Research?</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/15</date>
      <start_time>14:45</start_time>
      <end_time>15:30</end_time>
      <description>What do PL researchers do? Yes, they work on, well, programming languages, but PL research is broader than designing and implementing new languages. To me, a PL researcher is someone who views the programming language as having a central place in solving computing problems. From this vantage point, PL researchers tend to focus on developing general abstractions, or building blocks, for solving problems, or classes of problems. PL research also considers software behavior in a rigorous and general way, e.g., to prove that (classes of) programs enjoy properties we want, and/or eschew properties we don’t. This approach has proven to be very valuable for solving a wide ranging set of problems. In this talk I will flesh out this perspective and draw examples from several different problem areas (including security, quantum computation, and machine learning, along with others) to illustrate how PL is making a contribution.</description>
      <persons>
        <person>
          <role>Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Hicks</last_name>
          <affiliation>University of Maryland, College Park</affiliation>
          <bio>Michael Hicks is a Professor in the Computer Science department and UMIACS at the University of Maryland, where he co-directs the laboratory for Programming Languages research (PLUM); he is the former Director of the Maryland Cybersecurity Center (MC2). 
His research focuses on using programming languages and analyses to improve the security, reliability, and availability of software. He is perhaps best known for his work exploring dynamic software updating, which is a technique by which software can be updated without shutting it down. He has explored the design of new programming languages and analysis tools for helping programmers find bugs and software vulnerabilities, and for identifying suspicious or incorrect program executions. 
His recent work has combined ideas from PL and cryptography, e.g., to ensure privacy preserving computations. He also leads the development of a new security-oriented programming contest, “build-it, break-it, fix-it,” which has been offered to the public and to students in his Coursera class on software security. He is the co-editor of the Programming Languages Enthusiast blog and Tweets at @michael_w_hicks.</bio>
          <homepage_url>http://www.cs.umd.edu/~mwh/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/michaelhicks/aa64e3c6-3516-4e13-affe-77bc32c40565/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Programming Languages Mentoring Workshop 2019</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ccb12e4c-a9d0-41b9-ba42-3cd240920901</subevent_id>
    <title>PriSC: Session 4</title>
    <timeslot>
      <slot_id>62564206-e196-4228-aca2-c874cfba40fd</slot_id>
      <title>Session: PriSC - Session 4</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/13</date>
      <start_time>16:00</start_time>
      <end_time>18:00</end_time>
      <tracks>
        <track>Principles of Secure Compilation</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VI   </room>
    <date>2019/01/13</date>
    <url>https://popl19.sigplan.org/track/prisc-2019</url>
    <url_link_display>Principles of Secure Compilation</url_link_display>
    <tracks>
      <track>Principles of Secure Compilation</track>
    </tracks>
    <timeslot>
      <slot_id>19475fcd-e790-4bc7-acb3-3cc8318a288a</slot_id>
      <title>(Un)Encrypted Computing and Indistinguishability Obfuscation</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/13</date>
      <start_time>17:30</start_time>
      <end_time>18:00</end_time>
      <description>This presentation first describes an `obfuscating’ compiler technology developed for encrypted computing, then examines if the trivial case without encryption produces much-sought indistinguishability obfuscation.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Peter</first_name>
          <last_name>Breuer</last_name>
          <affiliation>Hecusys LLC</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jonathan</first_name>
          <last_name>Bowen</last_name>
          <affiliation>London South Bank University</affiliation>
          <bio>Jonathan Bowen, FBCS FRSA, is Chairman of Museophile Limited (founded in 2002), an Emeritus Professor at London South Bank University, where he established and headed the Centre for Applied Formal Methods in 2000, and since 2017 an Adjunct Professor at Southwest University, Chongqing, China. Between 2013-15, he was Professor of Computer Science at Birmingham City University. During 2006–07, he was a visiting academic at University College London. Between 2007–09, he was a Visiting Professor at King’s College, London, and during 2008–09, he was an Associate at Praxis High Integrity Systems (now Altran). From 2010, he was a Visiting Professor at the University of Westminster. During 2010 he was a Visiting Professor at Waikato University in New Zealand and in 2012 he was a Visiting Professor at the Pratt Institute in New York.</bio>
          <homepage_url>http://www.jpbowen.com</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/jonathanbowen/1d65cbaa-18bf-4e6b-8309-ff7e55122309/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Principles of Secure Compilation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>298cfca5-ca0c-42e6-b358-ebbcc132f788</slot_id>
      <title>Short Talks Session</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/13</date>
      <start_time>16:00</start_time>
      <end_time>16:30</end_time>
      <description>undefined</description>
      <tracks>
        <track>Principles of Secure Compilation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>81b2decd-6a8b-411a-be4f-3ef3712ee7b7</slot_id>
      <title>Modular Security Guarantees for Low-Level Languages with Stack Traversal</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/13</date>
      <start_time>16:30</start_time>
      <end_time>17:00</end_time>
      <description>Previous work on timing attacks mounted by garbage collectors by Pedersen and Askarov demonstrates that garbage collectors form a shared resource that can reliably be exploited to leak secrets of arbitrary sizes. In this work, we show how to modify existing garbage collection algorithms such that no information is leaked through timing channels. We do this by designing an information-flow aware programming language with sufficient expressivity to implement common low-level paradigms useful for garbage collection, and prove that well-typed programs in this language satisfies a version of noninterference.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Mathias Vorreiter</first_name>
          <last_name>Pedersen</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aslan</first_name>
          <last_name>Askarov</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://askarov.net/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Principles of Secure Compilation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e40b398a-e180-4d37-ac2e-8c3d2e748ef5</slot_id>
      <title>Confidentiality-Preserving Refinement</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/13</date>
      <start_time>17:00</start_time>
      <end_time>17:30</end_time>
      <description>Secure compilation preserves security properties of programs when they are transformed from an abstract specification (e.g. source language) to a refined model (e.g. assembly). For confidentiality, compilation must prevent unintended leakage of secret data thus preserving the information flow of the abstract model. This is challenging for several reasons. Current accounts of refinement (e.g., trace inclusion) do not support confidentiality properties well. Refinement may be used to eliminate underspecification and nondeterminism, it can change data representation, and it may expose new state information of the execution environment (such as caches, multiples cores, pipelines, buses, speculative execution, and so on). These features may introduce side channels, since they can provide an observer with information it did not have access to at an abstract model level, and in this way cause confidentiality properties to be violated. In practice, for some systems an implementation step may even have to consider storage channels: the introduction of completely new behaviours caused by hardware bugs, architectural flaws, or violation of assumptions such as memory coherence that are implicit at more abstract levels.1 We introduce techniques to show that also in such cases, with proper countermeasures in place that suitably isolate effects of the newly introduced features, it can be possible to identify a notion of refinement that preserves confidentiality in a meaningful sense. The key idea is to use the abstract model as a specification of the permitted information flow, and then to ensure that this flow induces an upper bound on the corresponding flow in the refined model. We formalize this notion in term knowledge: if the progression of observer knowledge on all refined computations is the same or weaker than the one on corresponding abstract ones then the refined model does not leak more information than the abstract model, hence we say it is a Confidentiality-Preserving Refinement (CPR). This allows us to transfer arbitrary information flow properties of the abstract model to the refined model, even if the abstract model allows communications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Roberto</first_name>
          <last_name>Guanciale</last_name>
          <affiliation>KTH</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Christoph</first_name>
          <last_name>Baumann</last_name>
          <affiliation>KTH</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Mads</first_name>
          <last_name>Dam</last_name>
          <affiliation>KTH</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Hamed</first_name>
          <last_name>Nemati</last_name>
          <affiliation>CISPA</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Principles of Secure Compilation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ecc2c3fe-91f5-4167-8aeb-e8d59ff45aff</subevent_id>
    <title>PLMW: PLMW Session 4</title>
    <timeslot>
      <slot_id>ac7ef957-9e6d-49cd-b55a-1374eabb1b63</slot_id>
      <title>Session: PLMW - PLMW Session 4</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/15</date>
      <start_time>16:00</start_time>
      <end_time>17:30</end_time>
      <tracks>
        <track>Programming Languages Mentoring Workshop 2019</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala II</room>
    <date>2019/01/15</date>
    <url>https://popl19.sigplan.org/track/PLMW-2019-papers</url>
    <url_link_display>Programming Languages Mentoring Workshop 2019</url_link_display>
    <tracks>
      <track>Programming Languages Mentoring Workshop 2019</track>
    </tracks>
    <timeslot>
      <slot_id>acb1f2b3-d8e9-4a8d-a64a-b4cc553c4222</slot_id>
      <title>Research Skills: How to Bootstrap a Research Project</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/15</date>
      <start_time>16:00</start_time>
      <end_time>16:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Ilya</first_name>
          <last_name>Sergey</last_name>
          <affiliation>Yale-NUS College</affiliation>
          <bio>I am a tenure-track Associate Professor at Yale-NUS College and NUS School of Computing (Singapore). 
Prior to joining Yale-NUS, I was a faculty at University College London. Before then, I was a postdoctoral researcher at IMDEA Software Institute (Madrid, Spain). I defended my PhD in 2012 in the DistriNet research group at the Department of Computer Sciences of KU Leuven (Belgium). Before that I received my MSc degree in Mathematics and Computer Science from Saint Petersburg State University (Russia) in 2008. 
My research interests dwell in the area of the design and implementation of programming languages, including but not limited to program semantics, certified programming, concurrency and abstract interpretation. I am particularly interested in developing verification techniques and static analyses for higher-order and concurrent programs.</bio>
          <homepage_url>http://ilyasergey.net</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/ilyasergey/b2941c89-4843-4194-852a-81c8a30814fa/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Programming Languages Mentoring Workshop 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c595a4f3-69f3-4b5b-b4dd-719e95055e7f</slot_id>
      <title>Panel: How to Do Great PL Research</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/15</date>
      <start_time>16:30</start_time>
      <end_time>17:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Panelist</role>
          <sort_key>1</sort_key>
          <first_name>Philippa</first_name>
          <last_name>Gardner</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~pg/</homepage_url>
        </person>
        <person>
          <role>Panelist</role>
          <sort_key>2</sort_key>
          <first_name>Deepak</first_name>
          <last_name>Garg</last_name>
          <affiliation>Max Planck Institute for Software Systems</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-sws.org/~dg</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/deepakgarg/2a70fd29-76c7-4771-98ce-7d8c591f4e69/small.jpg</picture_url>
        </person>
        <person>
          <role>Panelist</role>
          <sort_key>3</sort_key>
          <first_name>Atsushi</first_name>
          <last_name>Igarashi</last_name>
          <affiliation>Kyoto University, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fos.kuis.kyoto-u.ac.jp/~igarashi/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/atsushiigarashi/bbac1695-343a-4091-b33c-b7f01dea73da/small.jpg</picture_url>
        </person>
        <person>
          <role>Panelist</role>
          <sort_key>4</sort_key>
          <first_name>Neelakantan R.</first_name>
          <last_name>Krishnaswami</last_name>
          <affiliation>Computer Laboratory, University of Cambridge</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cl.cam.ac.uk/~nk480</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/neelakantankrishnaswami/45f309fe-1177-4f2f-b017-0f7a9333bda4/small.jpg</picture_url>
        </person>
        <person>
          <role>Panelist</role>
          <sort_key>5</sort_key>
          <first_name>Vasco</first_name>
          <last_name>Vasconcelos</last_name>
          <affiliation>LASIGE, Faculty of Sciences, University of Lisbon</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.di.fc.ul.pt/~vv/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/vascovasconcelos/b1bd0216-3fdb-4835-a89a-1e03a5fd6714/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Programming Languages Mentoring Workshop 2019</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0879f8d6-a2eb-4963-904b-d6cf0fdbbd24</subevent_id>
    <title>LAFI: Archimedes</title>
    <timeslot>
      <slot_id>f23a73eb-b991-4435-b97e-9f94dc5f745e</slot_id>
      <title>Session: LAFI - Archimedes</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/15</date>
      <start_time>09:00</start_time>
      <end_time>10:30</end_time>
      <tracks>
        <track>LAFI 2019: Languages for Inference (formerly PPS)</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VI   </room>
    <date>2019/01/15</date>
    <url>https://popl19.sigplan.org/track/lafi-2019</url>
    <url_link_display>LAFI 2019: Languages for Inference (formerly PPS)</url_link_display>
    <tracks>
      <track>LAFI 2019: Languages for Inference (formerly PPS)</track>
    </tracks>
    <timeslot>
      <slot_id>ad1a6b77-f4ad-407a-b4a0-7b11600fae69</slot_id>
      <title>Probabilistic Lambda Calculus: Beyond Deterministic Evaluation</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/15</date>
      <start_time>09:00</start_time>
      <end_time>09:10</end_time>
      <description>Functional programs are inherently parallel, because sub-expressions can be evaluated in parallel; still, we can reason on a program using a deterministic sequential model, because the result of the calculus is independent from the evaluation order. This property ultimately relies on confluence of the lambda calculus. 
It is well known that probabilistic lambda calculus is non confluent. The typical way out is to fix a deterministic reduction strategy. While we know that full reduction behave wildly, is there more structure to uncover between it and the extreme of a fixed deterministic strategy? 
We present on-going work which is motivated –on one hand– by such a question, and the desire of better understand the issue behind non-confluence in the probabilistic setting, and –on the other hand– by a general observation: very little is known about the operational semantics of the probabilistic lambda calculus.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Claudia</first_name>
          <last_name>Faggian</last_name>
          <affiliation>IRIF</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.irif.fr/~faggian/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Simona</first_name>
          <last_name>Ronchi Della Rocca</last_name>
          <affiliation>University of Torino</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.di.unito.it/~ronchi/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/simonaronchidellarocca/97f3159a-c8c5-4d12-9ed6-847092763b4c/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>LAFI 2019: Languages for Inference (formerly PPS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>dab3b1e4-3ca1-4490-81f7-c35252cf98cb</slot_id>
      <title>Invited talk: Connecting probabilistic programming theory to applications in Stan</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/15</date>
      <start_time>09:30</start_time>
      <end_time>10:30</end_time>
      <description>Stan is a widely used probabilistic programming language, whose development has been driven, primarily, by applications in statistics. Despite its established role in computational statistics, it has been studied little in the programming languages (PL) community. In this talk, I will highlight some of the interesting PL features of Stan as well as some of the challenges and opportunities for research it raises for our discipline.</description>
      <persons>
        <person>
          <role>invited speaker</role>
          <sort_key>1</sort_key>
          <first_name>Matthijs</first_name>
          <last_name>Vákár</last_name>
          <affiliation>University of Oxford</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/matthijsvakar/41a8f9d6-0c06-4001-99a9-fb316abcf3ac/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>LAFI 2019: Languages for Inference (formerly PPS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e5a9ab01-ff45-433b-a9c8-8aafd19cfced</slot_id>
      <title>The Geometry of Bayesian Programming</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/15</date>
      <start_time>09:10</start_time>
      <end_time>09:30</end_time>
      <description>We give a geometry of interaction model for a typed lambda-calculus with operators for sampling and soft conditioning. The calculus can as such be seen as a paradigmatic calculus for higher-order bayesian programming languages, like ANGLICAN or CHURCH. We present the model in two flavors, the former corresponding to an idealized, thus not executable, learning algorithm, the latter allowing to see the learning algorithm as part of the of the environment.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ugo</first_name>
          <last_name>Dal Lago</last_name>
          <affiliation>University of Bologna, Italy / Inria, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.unibo.it/~dallago/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/ugodallago/446eb4fe-dc38-4ed0-85ba-5f746abe1550/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Naohiko</first_name>
          <last_name>Hoshino</last_name>
          <affiliation>Kyoto University</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>LAFI 2019: Languages for Inference (formerly PPS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>757b528d-7925-4c82-b185-45db7b975f79</subevent_id>
    <title>LAFI: Borel</title>
    <timeslot>
      <slot_id>33e13b2a-ee9b-4758-a135-f83d005847f0</slot_id>
      <title>Session: LAFI - Borel</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/15</date>
      <start_time>11:00</start_time>
      <end_time>12:30</end_time>
      <tracks>
        <track>LAFI 2019: Languages for Inference (formerly PPS)</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VI   </room>
    <date>2019/01/15</date>
    <url>https://popl19.sigplan.org/track/lafi-2019</url>
    <url_link_display>LAFI 2019: Languages for Inference (formerly PPS)</url_link_display>
    <tracks>
      <track>LAFI 2019: Languages for Inference (formerly PPS)</track>
    </tracks>
    <timeslot>
      <slot_id>4255a1a7-d725-4a7c-a1a3-eb8df56132ec</slot_id>
      <title>Model and Inference Combinators for Deep Probabilistic Programming</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/15</date>
      <start_time>11:30</start_time>
      <end_time>12:00</end_time>
      <description>Probabilistic programs with dynamic computation graphs can define measures over sample spaces with unbounded dimensionality. Owing to the generality of this model class, inference often relies on “black-box” Monte Carlo methods that are generally not able to exploit optimizations based on conditional independence and exchangeability, which have historically been the cornerstones of efficient inference. We here seek to develop a “middle ground” between probabilistic models with fully dynamic and fully static computation graphs. To this end, we introduce a combinator library for the Probabilistic Torch framework. 
Combinators are functions that accept probabilistic programs and return probabilistic programs. We define combinators for both model and inference composition. Model combinators alter the measure that a program denotes. Inference combinators leave the measure invariant, but alter the evaluation strategy. Because combinators can be applied before a program is evaluated on data, they allow us to define a static computation graph at a coarsened level of representation. In this graph, individual nodes correspond to primitive model components, which may themselves have dynamic computation graphs, and are treated as black boxes for purposes of performing inference.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Eli</first_name>
          <last_name>Sennesh</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Adam</first_name>
          <last_name>Ścibior</last_name>
          <affiliation>University of Cambridge and MPI Tuebingen</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://mlg.eng.cam.ac.uk/adam/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Hao</first_name>
          <last_name>Wu</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jan-Willem</first_name>
          <last_name>van de Meent</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ccs.neu.edu/home/jwvdm/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>LAFI 2019: Languages for Inference (formerly PPS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>dc011e58-db24-42cc-ae6a-87cbb29ec157</slot_id>
      <title>Server-side Probabilistic Programming</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/15</date>
      <start_time>12:00</start_time>
      <end_time>12:30</end_time>
      <description>We share our experiences from integrating probabilistic programming into a server-side software system and present our ongoing work on probabilistic programming facility for Go, a modern programming language of choice for server-side software development. We demonstrate how a lightweight efficient probabilistic programming facility can be added to an existing programming language. Server-side application of probabilistic programming poses challenges for a probabilistic programming system. We discuss the challenges and our experience in overcoming them, and suggest guidelines which can help in a wider adoption of probabilistic programming in server-side software systems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>Tolpin</last_name>
          <affiliation>PUB+</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.offtopia.net/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/davidtolpin/51bf4dba-cd0d-47bd-ae9d-e400152743fa/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>LAFI 2019: Languages for Inference (formerly PPS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>faaac943-15d2-4482-a7c2-d86d1edf94b1</slot_id>
      <title>Strongly typed tracing of probabilistic programs</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/15</date>
      <start_time>11:00</start_time>
      <end_time>11:30</end_time>
      <description>A commonly encountered concept in probabilistic programming literature is that of a trace, which is a record of all the random variables sampled during the program execution. Traces serve two roles, namely providing observed values for some of the variables on which to perform conditioning and facilitating implementations of certain inference algorithms. Typical examples of such inference algorithms are importance sampling, where a guide program with a trace matching the original program is provided as a proposal distribution, and MCMC where a part of the trace is updated at each iteration. 
In this work we propose a method for constructing traces in PPLs in a statically typed fashion using lenses. Our approach statically ensures absence of certain bugs, such as misspelling a name of a random variable, and can be used to statically enforce certain properties of the program, such as the restriction of having a fixed number of random variables of fixed types, used in Stan programs. We focus on a situation where the user provides explicit names for the random variables. This is in contrast to the situation where the random variables are not explicitly given unique names and these have to be assigned automatically using a heuristic, such as in the work of Wingate et al. (2011).</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Adam</first_name>
          <last_name>Ścibior</last_name>
          <affiliation>University of Cambridge and MPI Tuebingen</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://mlg.eng.cam.ac.uk/adam/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Michael</first_name>
          <last_name>Thomas</last_name>
          <affiliation>Independent Researcher</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>LAFI 2019: Languages for Inference (formerly PPS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a855ef73-4a02-4d9d-a518-cf96fd0709c9</subevent_id>
    <title>CoqPL: Keynote &amp; Contributed talks 1</title>
    <timeslot>
      <slot_id>90bfcc9d-534e-44b2-9a64-42726c49f128</slot_id>
      <title>Session: CoqPL - Keynote &amp; Contributed talks 1</title>
      <room>Hotel Cascais Miragem | Sala VI</room>
      <date>2019/01/19</date>
      <start_time>09:00</start_time>
      <end_time>10:30</end_time>
      <tracks>
        <track>The Fifth International Workshop on Coq for Programming Languages</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VI</room>
    <date>2019/01/19</date>
    <url>https://popl19.sigplan.org/track/CoqPL-2019</url>
    <url_link_display>The Fifth International Workshop on Coq for Programming Languages</url_link_display>
    <tracks>
      <track>The Fifth International Workshop on Coq for Programming Languages</track>
    </tracks>
    <timeslot>
      <slot_id>2410f24d-9c20-4d8d-afb0-2a65d34090b9</slot_id>
      <title>Opening</title>
      <room>Hotel Cascais Miragem | Sala VI</room>
      <date>2019/01/19</date>
      <start_time>09:00</start_time>
      <end_time>09:05</end_time>
      <description>undefined</description>
      <tracks>
        <track>The Fifth International Workshop on Coq for Programming Languages</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c5f02e61-0738-485b-ad4d-c8f82bb02d5e</slot_id>
      <title>Coq User Interfaces: Past, Present, and Future (Keynote)</title>
      <room>Hotel Cascais Miragem | Sala VI</room>
      <date>2019/01/19</date>
      <start_time>09:05</start_time>
      <end_time>10:05</end_time>
      <description>As Coq approaches 35 years of history, the development of interactive proofs is more relevant than ever; crucial correctness properties can only be established mechanically with the help of humans, and the challenges that users and tooling face in the context of large-scale proofs are still considerable. 
In this talk, I will try to explore Coq user interfaces from 3 different perspectives: first, we will survey past work. Many great ideas have been proposed over the years, however, implementation and maintenance have not always been a path of roses. 
Understanding areas in need of improvement will lead us to the second part of the talk, where I will present SerAPI. 
SerAPI aims to be a state-of-the-art language server for the Coq ecosystem. Special care has been put into its design to prevent maintenance and robustness problems. SerAPI provides an API for building and querying Coq documents, and has been successfully used by several projects. 
While SerAPI works reasonably well today, is far from being a mature language server. In the final part of the talk, we will examine ongoing and future tooling work in the SerAPI/Coq roadmap. Some key issues are project management, incremental compilation, feature extraction, a enhanced display model, and support of standards such as the Language Server Protocol.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Emilio Jesús</first_name>
          <last_name>Gallego Arias</last_name>
          <affiliation>MINES ParisTech</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cri.ensmp.fr/people/gallego/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/emiliojesusgallegoarias/8c1a8221-1ea0-4d26-9b96-50639dac74b1/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>The Fifth International Workshop on Coq for Programming Languages</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cb494de0-d016-4427-8bf1-a41afa679563</slot_id>
      <title>Counterexamples for Coq Conjectures</title>
      <room>Hotel Cascais Miragem | Sala VI</room>
      <date>2019/01/19</date>
      <start_time>10:05</start_time>
      <end_time>10:30</end_time>
      <description>The goals of this presentation are to motivate the need for automatic counterexample search in Coq, to evaluate existing tools which are currently available for Coq users, but also tools from other ecosystems performing better than those available for Coq, to conclude that the current state of the art for counterexample search in Coq is unsatisfactory and should be improved, hopefully initiating a discussion in the Coq community on how this problem should be tackled.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sam</first_name>
          <last_name>Gruetter</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/samgruetter/6a0b8f86-7d75-4dee-8238-fc3f483b8edd/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>The Fifth International Workshop on Coq for Programming Languages</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2e806ef3-8012-4681-ab50-c73e59bd22aa</subevent_id>
    <title>PLMW: PLMW Session 1</title>
    <timeslot>
      <slot_id>4f1df9b7-e270-4b40-96e8-a9d138b51aa1</slot_id>
      <title>Session: PLMW - PLMW Session 1</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/15</date>
      <start_time>09:00</start_time>
      <end_time>10:30</end_time>
      <tracks>
        <track>Programming Languages Mentoring Workshop 2019</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala II</room>
    <date>2019/01/15</date>
    <url>https://popl19.sigplan.org/track/PLMW-2019-papers</url>
    <url_link_display>Programming Languages Mentoring Workshop 2019</url_link_display>
    <tracks>
      <track>Programming Languages Mentoring Workshop 2019</track>
    </tracks>
    <timeslot>
      <slot_id>cb441ae4-0136-453d-b0e6-d0cdd538a216</slot_id>
      <title>Research Skills: How to Give a Talk</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/15</date>
      <start_time>10:00</start_time>
      <end_time>10:30</end_time>
      <description>To give a talk (or more generally, to do a thing), loop through these four steps: establish your intent, develop a plan, practice, and learn. For a research talk, your intent might be to convey a single idea you need to choose, so your plan would be a tree whose node hierarchy and edge traversal you need to optimize and declare. Whereas your practice might follow a script, the memory and feedback you get would help you engage your audience and execute your intent in the present. Above all, a talk is an episode of cooperation with other people! So be honest, stand up straight, and breathe.</description>
      <persons>
        <person>
          <role>Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Chung-chieh</first_name>
          <last_name>Shan</last_name>
          <affiliation>Indiana University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homes.soic.indiana.edu/ccshan/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/chungchiehshan/5f1d6cc2-6e76-484a-bafe-85460ba4c6e5/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Programming Languages Mentoring Workshop 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d553d1f8-0266-4694-8bd0-f3652619533c</slot_id>
      <title>Technical Talk: Verification of Distributed Protocols Using Decidable Logic</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/15</date>
      <start_time>09:15</start_time>
      <end_time>10:00</end_time>
      <description>Distributed protocols underlie more and more applications, making their correctness paramount. However, due to the infinite state space (e.g., unbounded number of nodes and messages) and the complexity of the protocols used, verification of such protocols is both undecidable and hard in practice. 
A common practice is to model a program and its invariants using logical formulas. A major hurdle for verification of distributed protocols is the fact that they often require quantified inductive invariants, making the check of the verification conditions, let alone the inference of inductive invariants, difficult. This talk will discuss recent approaches for verifying distributed protocols by utilizing decidable fragments of first-order logic that are supported by leading satisfiability solvers and first-order theorem provers. Our experience shows that for verification conditions expressed in these fragments, solvers not only converge fast, but also behave quite predictably. We discuss approaches ranging from deductive verification, where the candidate inductive invariant is provided, to automatic inference of quantified invariants, through interactive inference.</description>
      <persons>
        <person>
          <role>Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Sharon</first_name>
          <last_name>Shoham</last_name>
          <affiliation>Tel Aviv university</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.tau.ac.il/~sharonshoham/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/sharonshoham/52ca243a-805e-43b9-9f5a-bd1bae25fccb/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Programming Languages Mentoring Workshop 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d8755689-a85c-4189-9675-7c999aa9bb16</slot_id>
      <title>PLMW Welcome</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/15</date>
      <start_time>09:00</start_time>
      <end_time>09:15</end_time>
      <description>undefined</description>
      <tracks>
        <track>Programming Languages Mentoring Workshop 2019</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>4589cfb1-5100-43ca-96de-dbf88da5f3fc</subevent_id>
    <title>CoqPL: Contributed talks 2</title>
    <timeslot>
      <slot_id>e603bff3-aebe-49f4-87c4-7d4cb8e9631e</slot_id>
      <title>Session: CoqPL - Contributed talks 2</title>
      <room>Hotel Cascais Miragem | Sala VI</room>
      <date>2019/01/19</date>
      <start_time>11:15</start_time>
      <end_time>12:30</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Robbert</first_name>
          <last_name>Krebbers</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://robbertkrebbers.nl</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/robbertkrebbers/c7fa7d6a-4f5e-4a65-893c-055c924fab02/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>The Fifth International Workshop on Coq for Programming Languages</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VI</room>
    <date>2019/01/19</date>
    <url>https://popl19.sigplan.org/track/CoqPL-2019</url>
    <url_link_display>The Fifth International Workshop on Coq for Programming Languages</url_link_display>
    <tracks>
      <track>The Fifth International Workshop on Coq for Programming Languages</track>
    </tracks>
    <timeslot>
      <slot_id>3608efb9-19a1-4c50-b251-1c37c098043a</slot_id>
      <title>Towards Mechanising Probabilistic Properties of a Blockchain</title>
      <room>Hotel Cascais Miragem | Sala VI</room>
      <date>2019/01/19</date>
      <start_time>11:15</start_time>
      <end_time>11:40</end_time>
      <description>We present our progress on the formalisation and mechanisation of a probabilistic model of a blockchain consensus protocol in Coq, taking steps towards the formal verification of its security properties, stated in terms of probabilities, in an adversarial environment.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kiran</first_name>
          <last_name>Gopinathan</last_name>
          <affiliation>University College London</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ilya</first_name>
          <last_name>Sergey</last_name>
          <affiliation>Yale-NUS College</affiliation>
          <bio>I am a tenure-track Associate Professor at Yale-NUS College and NUS School of Computing (Singapore). 
Prior to joining Yale-NUS, I was a faculty at University College London. Before then, I was a postdoctoral researcher at IMDEA Software Institute (Madrid, Spain). I defended my PhD in 2012 in the DistriNet research group at the Department of Computer Sciences of KU Leuven (Belgium). Before that I received my MSc degree in Mathematics and Computer Science from Saint Petersburg State University (Russia) in 2008. 
My research interests dwell in the area of the design and implementation of programming languages, including but not limited to program semantics, certified programming, concurrency and abstract interpretation. I am particularly interested in developing verification techniques and static analyses for higher-order and concurrent programs.</bio>
          <homepage_url>http://ilyasergey.net</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/ilyasergey/b2941c89-4843-4194-852a-81c8a30814fa/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>The Fifth International Workshop on Coq for Programming Languages</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c325b1e2-bcda-41c4-a314-82bdb1e896bf</slot_id>
      <title>WIP: Formalizing the Concordium consensus protocol in Coq</title>
      <room>Hotel Cascais Miragem | Sala VI</room>
      <date>2019/01/19</date>
      <start_time>12:05</start_time>
      <end_time>12:30</end_time>
      <description>We report an industrial application of Coq: our work towards formalizing the Concordium blockchain consensus protocol.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Dinsdale-Young</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bas</first_name>
          <last_name>Spitters</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.au.dk/~spitters/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/basspitters/de86c9f3-6ef4-4ae9-b0e1-8ea2ceaf4763/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Søren</first_name>
          <last_name>Eller Thomsen</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Tschudi</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>The Fifth International Workshop on Coq for Programming Languages</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>db481dc0-0836-4565-838d-9ebf99634c02</slot_id>
      <title>Verifying Finality for Blockchain Systems</title>
      <room>Hotel Cascais Miragem | Sala VI</room>
      <date>2019/01/19</date>
      <start_time>11:40</start_time>
      <end_time>12:05</end_time>
      <description>Blockchain systems such as Ethereum are increasingly used as financial transaction mechanisms (cryptocurrencies). However, in a blockchain system, there may be several competing chains of blocks (forks) that only agree on the transaction history up to some point, potentially leading to some transactions being dropped. To address the problem of blockchain revisions, Buterin and Griffith proposed a blockchain finality system overlay called Casper. When enough participants are honest, Casper defends both against active attacks and catastrophic crashes. In ongoing work, we are formally verifying Casper in Coq, both at the abstract protocol level and at the level of a distributed blockchain system. We build directly on two previous modeling and verification efforts: verified abstract models of Casper in Isabelle/HOL, and a model in Coq of a general distributed blockchain system called Toychain. Our verification approach bridges these two efforts by translating Isabelle/HOL definitions and proofs to Coq and specializing Toychain definitions for Casper. We give an overview of our ongoing verification effort and outline how we encode and prove key Casper properties, such as accountable safety, which rules out agreement on conflicting blocks when less than one third of participants behave adversarially.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Karl</first_name>
          <last_name>Palmskog</last_name>
          <affiliation>University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://setoid.com</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/karlpalmskog/a44bef85-fec3-4638-8de5-617362f7f2ba/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Milos</first_name>
          <last_name>Gligoric</last_name>
          <affiliation>University of Texas at Austin</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/milosgligoric/4d0671ae-937e-4f08-b499-092379ff7ad3/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Lucas</first_name>
          <last_name>Peña</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Grigore</first_name>
          <last_name>Rosu</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fsl.cs.illinois.edu/index.php/Grigore_Rosu</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/grigorerosu/5d2acd04-bb45-46a0-a743-4826f3d8086c/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>The Fifth International Workshop on Coq for Programming Languages</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>278fd069-7151-4706-8784-1e463ba65c06</subevent_id>
    <title>Off the Beaten Track: Afternoon talks</title>
    <timeslot>
      <slot_id>29dd379a-9b1f-4f7b-befd-4df1453f72c8</slot_id>
      <title>Session: Off the Beaten Track - Afternoon talks</title>
      <room>Hotel Cascais Miragem | Sala VII</room>
      <date>2019/01/19</date>
      <start_time>14:00</start_time>
      <end_time>15:30</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Luke</first_name>
          <last_name>Church</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/lukechurch/3ab26f57-3738-4a38-a8be-8f6d1b69cd8f/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Off the Beaten Track 2019</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VII</room>
    <date>2019/01/19</date>
    <url>https://popl19.sigplan.org/track/OBT-2019-papers</url>
    <url_link_display>Off the Beaten Track 2019</url_link_display>
    <tracks>
      <track>Off the Beaten Track 2019</track>
    </tracks>
    <timeslot>
      <slot_id>000b876b-8c96-4b15-b8e0-7cbfe0ec5bb1</slot_id>
      <title>Design Critique and discussion</title>
      <room>Hotel Cascais Miragem | Sala VII</room>
      <date>2019/01/19</date>
      <start_time>14:00</start_time>
      <end_time>14:45</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Chair</role>
          <sort_key>1</sort_key>
          <first_name>Luke</first_name>
          <last_name>Church</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/lukechurch/3ab26f57-3738-4a38-a8be-8f6d1b69cd8f/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Off the Beaten Track 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>22411843-0afe-4596-b715-624e44bb5927</slot_id>
      <title>F a Language for Music Composition</title>
      <room>Hotel Cascais Miragem | Sala VII</room>
      <date>2019/01/19</date>
      <start_time>14:45</start_time>
      <end_time>15:30</end_time>
      <description>In this paper we introduce the declarative language F for music composition. F supports music composition at a higher level of abstraction than traditional sheet music. Composers are able to express themselves at a high level of abstraction throughout the entire process of composing a piece, and we sketch some of the available transformation of the various component of a composition. F is currently still at a prototype stage (version 0.8), but we hope to evolve the language to be useful in many areas of computer aided music composition and analysis.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Joachim</first_name>
          <last_name>Kristensen</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ken Friis</first_name>
          <last_name>Larsen</last_name>
          <affiliation>DIKU, University of Copenhagen</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.diku.dk/~kflarsen</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/kenfriislarsen/c3bd441d-cbd0-4363-8229-cc220e96a887/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Off the Beaten Track 2019</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>23a658db-384b-441f-9a7b-31808d9d80b9</subevent_id>
    <title>Off the Beaten Track: Morning Papers</title>
    <timeslot>
      <slot_id>e5bf72bc-a622-4e93-a94c-533e4df86eda</slot_id>
      <title>Session: Off the Beaten Track - Morning Papers</title>
      <room>Hotel Cascais Miragem | Sala VII</room>
      <date>2019/01/19</date>
      <start_time>11:00</start_time>
      <end_time>12:30</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Greenberg</last_name>
          <affiliation>Pomona College</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.pomona.edu/~michael/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/michaelgreenberg/3c177ea6-ac3c-4ddb-9f4e-ac5d7b568e07/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Off the Beaten Track 2019</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VII</room>
    <date>2019/01/19</date>
    <url>https://popl19.sigplan.org/track/OBT-2019-papers</url>
    <url_link_display>Off the Beaten Track 2019</url_link_display>
    <tracks>
      <track>Off the Beaten Track 2019</track>
    </tracks>
    <timeslot>
      <slot_id>4de42d54-19c1-4153-a0a8-b4aa32a3506c</slot_id>
      <title>From Tactics to Structure Editors for Proofs</title>
      <room>Hotel Cascais Miragem | Sala VII</room>
      <date>2019/01/19</date>
      <start_time>11:45</start_time>
      <end_time>12:30</end_time>
      <description>For many users of theorem provers, tactics are merely an inelegant solution to a difficult problem. However, we believe that tactics deserve more attention and appraisal, and well-designed tactics are actually a well-structured way to construct programs. In this work, we will explore the connection between tactics and structure editors, as well as emphasize the importance of designing tactics with well-defined semantics with respect to proof terms and proof states.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xuanrui (Ray)</first_name>
          <last_name>Qi</last_name>
          <affiliation>Tufts University</affiliation>
          <bio>I am a master’s student in computer science at Tufts University, where I am advised by Sam Guyer. Previously, I was a research visitor at Nagoya University, Japan, working with Jacques Garrigue, and before that an undergraduate student at Tufts University, from where I graduated with a B.S. in 2018.</bio>
          <homepage_url>https://www.xuanruiqi.com</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Off the Beaten Track 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a238d80f-e5ed-46a6-bef9-b0c34db4d91c</slot_id>
      <title>Facile : A Domain Specific Language and Compiler for Program Analysis and Optimization </title>
      <room>Hotel Cascais Miragem | Sala VII</room>
      <date>2019/01/19</date>
      <start_time>11:00</start_time>
      <end_time>11:45</end_time>
      <description>Research on program analyses and optimizations has advanced a lot and is able to provide insightful diagnostics and generate high performant code for various targets over past few years. However, it is still a cumbersome task to implement compiler algorithms which analyze or perform optimizations as it requires the knowledge of compiler infrastructure and related tools; a researcher, who is well versed in compilers needs to know the internals of the compiler infrastructure (like LLVM or GCC) in order to implement even a simple analysis pass. This poses hindrance in rapid prototyping and experimentation of new compiler algorithms. We propose a domain specific language called Facile which aims to reduce this burden off the compiler developers by allowing them to express data-flow and control-flow algorithms at higher lever of abstraction. The Facile compiler lowers the code written in Facile language to a compiler infrastructure specific pass(es) and generates final executable. We demonstrate the effectiveness of our language with a real-world use case and explain the tool chain required to implement the language.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Madhur</first_name>
          <last_name>Amilkanthwar</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Off the Beaten Track 2019</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a349c411-9dfd-45e2-8e0c-2b89e078882a</subevent_id>
    <title>BEAT: Session 3</title>
    <timeslot>
      <slot_id>233052fa-f8cd-4324-bb10-7f34e10e9bee</slot_id>
      <title>Session: BEAT - Session 3</title>
      <room>Hotel Cascais Miragem | Sala VII</room>
      <date>2019/01/13</date>
      <start_time>13:30</start_time>
      <end_time>15:30</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Paola</first_name>
          <last_name>Giannini</last_name>
          <affiliation>Universita' del Piemonte Orientale</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.unipmn.it/giannini/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/paolagiannini/dbc88479-8b56-4e8d-87dd-a6007c5d9065/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>BEAT 2019: Fourth Workshop on Behavioral Types</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VII</room>
    <date>2019/01/13</date>
    <url>https://popl19.sigplan.org/track/beat-2019-papers</url>
    <url_link_display>BEAT 2019: Fourth Workshop on Behavioral Types</url_link_display>
    <tracks>
      <track>BEAT 2019: Fourth Workshop on Behavioral Types</track>
    </tracks>
    <timeslot>
      <slot_id>17baf50c-f8c9-4bc3-bbfc-945f1ec37e8b</slot_id>
      <title>Invited Talk: A Session Type Provider: Compile-time Generation of Session Types with Interaction Refinements</title>
      <room>Hotel Cascais Miragem | Sala VII</room>
      <date>2019/01/13</date>
      <start_time>14:20</start_time>
      <end_time>15:10</end_time>
      <description>Session types is a typing discipline for concurrent and distributed processes that allows errors such as communication mismatches and deadlocks to be detected statically. Refinement types are types elaborated by logical constraints that allow richer and finer-grained specification of application properties, combining types with logical formulae that may refer to program values and can constrain types using arbitrary predicates. Type providers, developed in F#, are compile-time components for on-demand code generation. Their architecture relies on an open-compiler, where provider-authors implement a small interface that allows them to inject new names/types into the programming context as the program is written. 
In this talk, I will present a library that integrates aspects from the above fields to realise practical applications of multiparty refinement session types (MPST) for any .Net language. Our library supports the specification and validation of distributed message passing protocols based on a formulation of asynchronous MPST enriched with interaction refinements: a collection of features related to the refinement of protocols, such as message-type refinements (value constraints) and value dependent control flow. The combination of these aspects—session types for structured interactions, constraint solving from refinement types, and protocol-specific code generation—enables the specification and implementation of enriched protocols in native F# (and any .Net-compiled language) without requiring language extensions or external pre-processing of user programs. A well-typed endpoint program using our library is guaranteed to perform only compliant session I/O actions w.r.t. to the refined protocol, up to premature termination. The safety guarantees are achieved by a combination of static type checking of the generated types for messages and I/O operations, correctness by construction from code generation, and automated inlining of assertions.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Rumyana</first_name>
          <last_name>Neykova</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>Rumyana Neykova is an RA at Imperial College London, previously completed a PhD degree under the supervision of Prof. Nobuko Yoshida. Her research interests are in the area of distributed systems and networks, as well as type systems and language design. Her PhD focuses on development and applications of a type theory (called session types) for runtime verification of concurrent and distributed systems.</bio>
          <homepage_url>http://mrg.doc.ic.ac.uk/people/rumyana-neykova/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/rumyananeykova/66457b0a-8e8b-471e-b278-37d7f4242bcb/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>BEAT 2019: Fourth Workshop on Behavioral Types</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b8a1f1db-6b0f-44af-a76d-479c5eb9e43e</slot_id>
      <title>Invited Talk: Resource-Aware Session Types</title>
      <room>Hotel Cascais Miragem | Sala VII</room>
      <date>2019/01/13</date>
      <start_time>13:30</start_time>
      <end_time>14:20</end_time>
      <description>This talk presents recent work on extending session types to describe and enforce resource constraints. 
First, I briefly review the use of session types for prescribing bidirectional communication protocols for message-passing processes. Then, I show how session types can be combined with the potential method of amortized analysis to account for the (sequential) work performed by a process. Next, I discuss temporal session types, which uniformly express properties such as the message rate of a stream or the latency of a pipeline and can be used to reason about parallel complexity. Finally, I discuss the application of these resource-aware session types in Nomos, a programming language for digital contracts.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jan</first_name>
          <last_name>Hoffmann</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>I am a Tenure-Track Assistant Professor at Carnegie Mellon’s Computer Science Department, and a member of the Principles of Programming (PoP) group. 
My research areas are programming languages and formal methods. I am specifically interested in quantitative verification, type systems, static resource analysis of programs, proof assistants, and system verification. 
Before joining Carnegie Mellon, I was an Associate Research Scientist in the Department of Computer Science at Yale. Before that, I was a PhD student at LMU Munich.</bio>
          <homepage_url>http://www.cs.cmu.edu/~janh/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/janhoffmann/9adae976-6941-4521-9b57-733202e412fd/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>BEAT 2019: Fourth Workshop on Behavioral Types</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ec9116a7-b5de-46de-919d-e39df3359099</slot_id>
      <title>Getting rid of null-dereferences – Behavioural types to the rescue</title>
      <room>Hotel Cascais Miragem | Sala VII</room>
      <date>2019/01/13</date>
      <start_time>15:10</start_time>
      <end_time>15:30</end_time>
      <description>Mungo and StMungo are two type-based analysis tools for a Java-like language that have been developed at Glasgow University. 
This paper extends the results of Mungo by presenting a type-based analysis that is able to analyze both method usage and null pointer dereferencing and related errors. The language that we consider is a Java-like language with linear access to fields. Every field can be written to and subsequently readatmost once. Every method of an object must adhere to a usage behaviour that describes the admissible sequences of method calls. 
Our type system prevents four kinds of errors related to method and field access. They are 
 
 Method not available 
 Field not available 
 Method not understood 
 Field not understood 
</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hans</first_name>
          <last_name>Hüttel</last_name>
          <affiliation>Department of Computer Science, Aalborg University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.aau.dk/~hans</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Antonio</first_name>
          <last_name>Ravara</last_name>
          <affiliation>Department of Informatics, Faculty of Sciences and Technology, NOVA University of Lisbon and NOVA LINCS</affiliation>
          <bio>Associate Professor at the Department of Informatics, Faculty of Sciences and Technology, NOVA University of Lisbon, Portugal (since October 2018). Founding member and Integrated researcher at the NOVA Laboratory for Computer Science and Informatics (NOVA LINCS), Portugal (since 2013). Assistant Professor at the Department of Informatics, Faculty of Sciences and Technology, NOVA University of Lisbon, Portugal ()2009 to 2018). Assistant Professor at the Section of Logic and Computation of the Department of Mathematics of IST. Technical University of Lisbon, Portugal (2000 to 2009). 
PhD in Mathematics at IST, of the Technical University of Lisbon, Portugal (December 2000). MSc in Applied Mathematics at IST of the Technical University of Lisbon, Portugal (May 1996). BSc in Geographical Engineering at the Faculty of Sciences of the University of Lisbon, Portugal (September 1991). 
Main research problem is how to ensure that inherently concurrent, highly distributed, software systems behave correctly. The focus is on the development of techniques, program constructions, and tools that help creating safe and well-behaved systems, provably providing correctness guarantees. The toolbox used includes static analysis of source code, capturing defects before deployment, with decidable, low complexity, property-driven, proof systems, using behavioural descriptions of programs.</bio>
          <homepage_url>http://nova-lincs.di.fct.unl.pt/person/47</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/antonioravara/dbb3f737-58d8-45cf-9c93-a54da5788412/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Adrian</first_name>
          <last_name>Francalanza</last_name>
          <affiliation>University of Malta</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://staff.um.edu.mt/afra1/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/adrianfrancalanza/6e6d0dd9-c580-4596-abde-30e3716ea961/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Mario</first_name>
          <last_name>Bravetti</last_name>
          <affiliation>Università di Bologna</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.unibo.it/~bravetti/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/mariobravetti/6f29dadf-65f2-4dcf-b4cf-7e9959d9ff64/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>BEAT 2019: Fourth Workshop on Behavioral Types</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>39e424cc-ecf0-49ca-8da1-e9a573f47b49</subevent_id>
    <title>BEAT: Session 4</title>
    <timeslot>
      <slot_id>fb7399e0-d5ef-4efd-bf59-0e8271839f35</slot_id>
      <title>Session: BEAT - Session 4</title>
      <room>Hotel Cascais Miragem | Sala VII</room>
      <date>2019/01/13</date>
      <start_time>16:00</start_time>
      <end_time>18:25</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Adrian</first_name>
          <last_name>Francalanza</last_name>
          <affiliation>University of Malta</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://staff.um.edu.mt/afra1/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/adrianfrancalanza/6e6d0dd9-c580-4596-abde-30e3716ea961/small.jpg</picture_url>
        </person>
        <person>
          <role>Session Chair</role>
          <sort_key>2</sort_key>
          <first_name>Jorge A.</first_name>
          <last_name>Pérez</last_name>
          <affiliation>University of Groningen, The Netherlands</affiliation>
          <bio> 
 Assistant Professor, University of Groningen, The Netherlands (Since 2014) 
 Postdoctoral Researcher, NOVA University of Lisbon, Portugal (2010 - 2014) 
 PhD student, University of Bologna, Italy (2007 - 2010) 
</bio>
          <homepage_url>http://www.jperez.nl</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/jorgeaperez/4e196e9f-a731-4e6d-9291-594dde28347f/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>BEAT 2019: Fourth Workshop on Behavioral Types</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VII</room>
    <date>2019/01/13</date>
    <url>https://popl19.sigplan.org/track/beat-2019-papers</url>
    <url_link_display>BEAT 2019: Fourth Workshop on Behavioral Types</url_link_display>
    <tracks>
      <track>BEAT 2019: Fourth Workshop on Behavioral Types</track>
    </tracks>
    <timeslot>
      <slot_id>1caa1d1d-56a5-40b4-9fea-8d2786d2af63</slot_id>
      <title>Short break </title>
      <room>Hotel Cascais Miragem | Sala VII</room>
      <date>2019/01/13</date>
      <start_time>17:30</start_time>
      <end_time>17:40</end_time>
      <description>undefined</description>
      <tracks>
        <track>BEAT 2019: Fourth Workshop on Behavioral Types</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>28089c99-0775-4679-824f-136c6ac92b8c</slot_id>
      <title>Relating Process Languages for Security and Communication Correctness</title>
      <room>Hotel Cascais Miragem | Sala VII</room>
      <date>2019/01/13</date>
      <start_time>17:10</start_time>
      <end_time>17:30</end_time>
      <description>Process calculi are expressive specification languages for concurrency. They have been very successful in two research strands: (a) the analysis of security protocols and (b)the enforcement of correct message-passing programs. Despite their shared foundations, languages and reasoning techniques for (a) and (b) have been separately developed. Here we connect two representative calculi from (a) and (b): we encode a (high-level) pi-calculus for multiparty sessions into a (low-level) applied pi-calculus for security protocols. We establish the correctness of our encoding, and we show how it enables the integrated analysis of security properties and communication correctness by re-using existing tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Daniele</first_name>
          <last_name>Nantes-Sobrinho</last_name>
          <affiliation>University of Brasília, Brazil</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jorge A.</first_name>
          <last_name>Pérez</last_name>
          <affiliation>University of Groningen, The Netherlands</affiliation>
          <bio> 
 Assistant Professor, University of Groningen, The Netherlands (Since 2014) 
 Postdoctoral Researcher, NOVA University of Lisbon, Portugal (2010 - 2014) 
 PhD student, University of Bologna, Italy (2007 - 2010) 
</bio>
          <homepage_url>http://www.jperez.nl</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/jorgeaperez/4e196e9f-a731-4e6d-9291-594dde28347f/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>BEAT 2019: Fourth Workshop on Behavioral Types</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4d41af4e-39d3-47d3-8041-61849daf9131</slot_id>
      <title>Behavioral Types as a Semantic Foundation for the GDPR notion of Purpose</title>
      <room>Hotel Cascais Miragem | Sala VII</room>
      <date>2019/01/13</date>
      <start_time>16:50</start_time>
      <end_time>17:10</end_time>
      <description>In recent decades, various countries have enacted laws for protecting the privacy of individuals, one such example being the European General Data Protection Regulation (GDPR). The notion of purpose plays a crucial role in these regulations. However, in most situations purposes are expressed as vague textual descriptions, which often prevents (i) the user from fully understanding how their data is going to be processed, and (ii) a precise analysis that a system satisfies a given (GDPR-based) privacy policy. To address this shortcoming, various works have been concerned with providing semantic foundations to the notion of purpose. In this work, we pursue the same goal and we advocate the use of behavioral types as a means of capturing the notion of a purpose and, consequently, the use of type checking to formally verify that a system conforms to its privacy policy. We instantiate this proposal in the context of our previous work on the Privacy calculus.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Evangelia</first_name>
          <last_name>Vanezi</last_name>
          <affiliation>University of Cyprus</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dimitrios</first_name>
          <last_name>Kouzapas</last_name>
          <affiliation>University of Cyprus</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Anna</first_name>
          <last_name>Philippou</last_name>
          <affiliation>University of Cyprus</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>BEAT 2019: Fourth Workshop on Behavioral Types</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>768542af-d168-4dac-bbc4-e9765cc207ad</slot_id>
      <title>Towards Legally Compliant Governmental Case Work with Dynamic Condition Response Graphs</title>
      <room>Hotel Cascais Miragem | Sala VII</room>
      <date>2019/01/13</date>
      <start_time>17:40</start_time>
      <end_time>18:00</end_time>
      <description>Governmental case management processes are carried out in collaboration between at least two actors (the Government and the citizen) and are tightly governed by law. This makes it relevant to consider if behavioural types can be used to guarantee process compliance. The formalisation of governmental case management processes requires capturing processes from at least two different kinds of sources: Legal texts and descriptions of local practice, which ought to be compliant with the law. Using a case study of a few paragraphs in the Danish Consolidation Act on Social Services and studies of local practice in a municipality, we describe how to formalise legal constraints and practice as declarative Dynamic Condition Response (DCR) graphs. The formalisation is supported by a new text highlighter extension for the DCRGraphs.net tool. The highligher allows lawyers and other domain experts to build DCR graphs by annotating textual descriptions of processes and regulations, in particular legal texts, which can subsequently be validated by simulations and used directly in a compliant-by-design case management system interacting with the DCR process engine.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Søren</first_name>
          <last_name>Debois</last_name>
          <affiliation>IT University of Copenhagen</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Thomas</first_name>
          <last_name>H. Hildebrandt</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Hugo</first_name>
          <last_name>López</last_name>
          <affiliation>IT University of Copenhagen, Denmark &amp; DCR Solutions A/S</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://hugo.lopezacosta.net</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/hugoalopez/b4fa3e8e-949f-4873-ae06-f856d47a36a5/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>BEAT 2019: Fourth Workshop on Behavioral Types</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7b407cd3-22de-49c4-96d4-e295d1aaac2f</slot_id>
      <title>Closing </title>
      <room>Hotel Cascais Miragem | Sala VII</room>
      <date>2019/01/13</date>
      <start_time>18:20</start_time>
      <end_time>18:25</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Antonio</first_name>
          <last_name>Ravara</last_name>
          <affiliation>Department of Informatics, Faculty of Sciences and Technology, NOVA University of Lisbon and NOVA LINCS</affiliation>
          <bio>Associate Professor at the Department of Informatics, Faculty of Sciences and Technology, NOVA University of Lisbon, Portugal (since October 2018). Founding member and Integrated researcher at the NOVA Laboratory for Computer Science and Informatics (NOVA LINCS), Portugal (since 2013). Assistant Professor at the Department of Informatics, Faculty of Sciences and Technology, NOVA University of Lisbon, Portugal ()2009 to 2018). Assistant Professor at the Section of Logic and Computation of the Department of Mathematics of IST. Technical University of Lisbon, Portugal (2000 to 2009). 
PhD in Mathematics at IST, of the Technical University of Lisbon, Portugal (December 2000). MSc in Applied Mathematics at IST of the Technical University of Lisbon, Portugal (May 1996). BSc in Geographical Engineering at the Faculty of Sciences of the University of Lisbon, Portugal (September 1991). 
Main research problem is how to ensure that inherently concurrent, highly distributed, software systems behave correctly. The focus is on the development of techniques, program constructions, and tools that help creating safe and well-behaved systems, provably providing correctness guarantees. The toolbox used includes static analysis of source code, capturing defects before deployment, with decidable, low complexity, property-driven, proof systems, using behavioural descriptions of programs.</bio>
          <homepage_url>http://nova-lincs.di.fct.unl.pt/person/47</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/antonioravara/dbb3f737-58d8-45cf-9c93-a54da5788412/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jorge A.</first_name>
          <last_name>Pérez</last_name>
          <affiliation>University of Groningen, The Netherlands</affiliation>
          <bio> 
 Assistant Professor, University of Groningen, The Netherlands (Since 2014) 
 Postdoctoral Researcher, NOVA University of Lisbon, Portugal (2010 - 2014) 
 PhD student, University of Bologna, Italy (2007 - 2010) 
</bio>
          <homepage_url>http://www.jperez.nl</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/jorgeaperez/4e196e9f-a731-4e6d-9291-594dde28347f/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>BEAT 2019: Fourth Workshop on Behavioral Types</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8f38726d-fd2f-4f76-8e70-4c93948dd356</slot_id>
      <title>Invited Talk: Session Types for Fault-Tolerant Distributed Algorithms</title>
      <room>Hotel Cascais Miragem | Sala VII</room>
      <date>2019/01/13</date>
      <start_time>16:00</start_time>
      <end_time>16:50</end_time>
      <description>Session types are designed to abstractly capture the structure of (even multi-party) communication protocols. The goal of session types is the analysis and verification of the protocols’ behavioural properties. One important such property is progress, i.e., the absence of (unintended) deadlock. Distributed algorithms often resemble (compositions of) multi-party communication protocols. In contrast to protocols that are typically studied with session types, they are often designed to cope with faults, like system failures. An essential behavioural property is (successful) fault-tolerant termination, but it is often elaborate to prove for distributed algorithms. 
The talk is about an extension of multi-party session types to capture faults due to message loss and process crashes. It combines reliable and unreliable communication mechanisms in types and augment the semantics of processes by failure patterns that can be used to represent system requirements (as, e.g., failure detectors).</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kirstin</first_name>
          <last_name>Peters</last_name>
          <affiliation>TU Berlin</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>BEAT 2019: Fourth Workshop on Behavioral Types</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>91d56044-5d0e-4745-87ab-a029adf730d0</slot_id>
      <title>Hardware interactions as behavioural types</title>
      <room>Hotel Cascais Miragem | Sala VII</room>
      <date>2019/01/13</date>
      <start_time>18:00</start_time>
      <end_time>18:20</end_time>
      <description>A typical IoT sensor device is built from several independent components that cooperate together to sense and actuate on the physical world. Programming these devices can easily cause hardware failures that are not usually considered in general programming languages. For instance, programs can easily run out of memory causing the device simply to reboot; a mistake in a loop can render the device unusable, as it can drain its battery. As the program runs on the bare metal (there is no operating system nor device drivers), the program can improperly use the hardware, which, in most of the cases, leads to the action to be silently ignored. For example, by loosing a message that was sent when the device was not ready to send, or by manipulating a non-existent or misconﬁgured LED (Light-Emitting Diode). 
We use behavioural types to describe the hardware as a set of well-deﬁned components with valid interdependencies, in the spirit of the multiparty session types [1]. Our type describes each component per se in terms of its interface and its behaviour. The former deﬁnes the actions that the device makes available and the events the device triggers; the latter speciﬁes the order in which actions and events can occur. As usual, in behavioural type works, our goal is to verify that the components are assembled correctly as a valid component (well typed), and that the programs use the device according to the prescribed type. Additionally, we want to express temporal-logic propositions on traces, so that we can prove, for instance, that a modem is always disconnected before the device enters the sleep state. To the best of our knowledge no IoT framework incorporates such analysis. 
In this talk we present a simple hardware device and use our types to describe several increasingly complex behaviours of this device, thus assessing the informal expressiveness of our types. We discuss on how to verify that the behaviour of a component is a valid composition of simpler components. Finally, we hint on how to check that programs comply with a component type.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Carlos</first_name>
          <last_name>Mão de Ferro</last_name>
          <affiliation>LASIGE, Faculty of Sciences, University of Lisbon</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.lasige.di.fc.ul.pt/user/36</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/carlosmaodeferro/9e89ef60-4e85-415b-88de-1fb9f28ef170/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Francisco</first_name>
          <last_name>Martins</last_name>
          <affiliation>LaSIGE, University of Lisbon</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/franciscomartins/7a471208-b10b-4355-a37a-2f6911457987/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tiago</first_name>
          <last_name>Cogumbreiro</last_name>
          <affiliation>University of Massachusetts Boston</affiliation>
          <bio>Tiago is an assistant professor at UMass Boston. Tiago is excited by concurrency theory and parallel programming. In his Ph.D., Tiago proposed two techniques to handle barrier deadlocks: a deadlock-free programming interface, and a runtime verification tool, called Armus. Recently, he has been interested in using Coq and Why3 to produce certified algorithms. 
Past experience, includes being a research assistant at Imperial College London, where he was supervised by Nobuko Yoshida, and a visiting scholar at Rice University, where he was supervised by Vivek Sarkar. Tiago received his Ph.D., March ’15, at ULisboa, where he was advised by Francisco Martins, and his B.Sc. at Universidade dos Açores.</bio>
          <homepage_url>http://cogumbreiro.github.io/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/tiagocogumbreiro/a7c3b45d-00a3-459d-b629-92a61132e6b3/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>BEAT 2019: Fourth Workshop on Behavioral Types</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>21636e00-a1bb-48e9-aa1c-f3baf73a9265</subevent_id>
    <title>LAFI: Cauchy</title>
    <timeslot>
      <slot_id>bc648c91-4b68-4b7a-b423-2dbe8c39d8b9</slot_id>
      <title>Session: LAFI - Cauchy</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/15</date>
      <start_time>14:00</start_time>
      <end_time>15:30</end_time>
      <tracks>
        <track>LAFI 2019: Languages for Inference (formerly PPS)</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VI   </room>
    <date>2019/01/15</date>
    <url>https://popl19.sigplan.org/track/lafi-2019</url>
    <url_link_display>LAFI 2019: Languages for Inference (formerly PPS)</url_link_display>
    <tracks>
      <track>LAFI 2019: Languages for Inference (formerly PPS)</track>
    </tracks>
    <timeslot>
      <slot_id>31568763-c8fa-40c1-bc8e-e8384a53fb3e</slot_id>
      <title>Kotlin∇: Differentiable functional programming with algebraic data types</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/15</date>
      <start_time>14:30</start_time>
      <end_time>15:00</end_time>
      <description>Kotlin is a multi-platform programming language with compiler support for JVM, JS and native targets. The language emphasizes static typing, null-safety and interoperability with Java and JavaScript. In this work, we present an algebraically grounded implementation of forward and reverse mode automatic differentiation written in pure Kotlin and a property-based test suite for soundness checking. Our approach enables users to target multiple platforms through a single codebase and receive compile-time static analysis. A working prototype is provided at: https://github.com/breandan/kotlingrad</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Breandan</first_name>
          <last_name>Considine</last_name>
          <affiliation>Université de Montréal</affiliation>
          <bio>I am a Master’s student at the University of Montreal under the supervision of Liam Paull and Michalis Famelis. My research interests include reinforcement learning, differentiable programming and software engineering. I have an applied background in machine learning, with experience in programming languages and developer tools. I am enthusiastic about AI as a tool for improving human potential.</bio>
          <homepage_url>http://brea.ndan.co</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/breandanconsidine/11189031-b14d-4081-8aea-3d8de42b2c0d/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>LAFI 2019: Languages for Inference (formerly PPS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>39190c80-30d3-4cd1-b04e-d17e2580cee0</slot_id>
      <title>A Nuts-and-Bolts Differential Geometric Perspective on Automatic Differentiation</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/15</date>
      <start_time>14:00</start_time>
      <end_time>14:30</end_time>
      <description>Carefully reifying the differential-geometric pushforward and pullback operators as forward and reverse AD clarifies the relationship between forward and reverse AD, and allows the formalization of AD of higher-order functions. We discuss the relationship between the differential-geometric constructs and the usual practice of just lifting all reals to duals, focusing on how they differ in the case of higher-order functions.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Barak A.</first_name>
          <last_name>Pearlmutter</last_name>
          <affiliation>Maynooth University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://barak.pearlmutter.net</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/barakapearlmutter/912f01f7-f3e3-4f4b-a76f-f424f4e74355/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>LAFI 2019: Languages for Inference (formerly PPS)</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f099ccad-fd52-410f-9f9c-bde193bb6bf7</slot_id>
      <title>Probabilistic Programming with CuPPL</title>
      <room>Hotel Cascais Miragem | Sala VI   </room>
      <date>2019/01/15</date>
      <start_time>15:00</start_time>
      <end_time>15:30</end_time>
      <description>Probabilistic Programming Languages (PPLs) are a powerful tool in machine learning, allowing highly expressive generative models to be expressed succinctly. They couple complex inference algorithms, implemented by the language, with an expressive modelling language that allows a user to implement any computable function as the generative model. 
Such languages are usually implemented on top of existing high level programming languages and do not make use of hardware accelerators. PPLs that do make use of accelerators exist, but restrict the expressivity of the language in order to do so. 
In this extended abstract, we present a language and toolchain that generates highly efficient code for both CPUs and GPUs. The language is functional in style, and the toolchain is built on top of LLVM. Our implementation uses delimited continuations on CPU to perform inference, and custom CUDA codes on GPU. 
We obtain significant speed ups across a suite of PPL workloads, compared to other state of the art approaches on CPU. Furthermore, our compiler can also generate efficient code that runs on CUDA GPUs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alexander</first_name>
          <last_name>Collins</last_name>
          <affiliation>NVIDIA</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Vinod</first_name>
          <last_name>Grover</last_name>
          <affiliation>NVIDIA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/vinodgrover/e381ff4b-bfad-48c7-ade4-bc19a5f6a598/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>LAFI 2019: Languages for Inference (formerly PPS)</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2649ce83-5617-4f6d-b2c7-c4de64e227f5</subevent_id>
    <title>OPCT: EQUATIONAL CHARACTERISATIONS, TRANSACTIONS</title>
    <timeslot>
      <slot_id>b500905c-67e3-4cd0-b381-ed38ccc80418</slot_id>
      <title>Session: OPCT - EQUATIONAL CHARACTERISATIONS, TRANSACTIONS</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/15</date>
      <start_time>09:00</start_time>
      <end_time>10:30</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Mohammad</first_name>
          <last_name>Mousavi</last_name>
          <affiliation>University of Leicester, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www2.le.ac.uk/departments/informatics/people/mohammad-mousavi</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/mohammadmousavi/f3d49346-8276-4207-a5e5-038fa1534a8a/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VII   </room>
    <date>2019/01/15</date>
    <url>https://popl19.sigplan.org/track/opct-2019-papers</url>
    <url_link_display>OPCT 2019</url_link_display>
    <tracks>
      <track>OPCT 2019</track>
    </tracks>
    <timeslot>
      <slot_id>1e370d93-1f21-4347-b255-4d7043760795</slot_id>
      <title>ULTraS at Work: Compositionality and Equational Characterization of Behavioral Metaequivalences</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/15</date>
      <start_time>09:40</start_time>
      <end_time>10:05</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Marco</first_name>
          <last_name>Bernardo</last_name>
          <affiliation>University of Urbino</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.sti.uniurb.it/bernardo/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5a4b50a7-4f59-47d6-8051-dffb0fcf7700</slot_id>
      <title>A uniform framework of transactional consistency models for protocol verification and program analysis</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/15</date>
      <start_time>10:05</start_time>
      <end_time>10:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Andrea</first_name>
          <last_name>Cerone</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.doc.ic.ac.uk/~acerone/contacts.html</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6c071f54-51c5-4e12-baed-ae8e740bd62e</slot_id>
      <title>Revised semantics for sequential composition in the presence of successful termination (tentative)</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/15</date>
      <start_time>09:15</start_time>
      <end_time>09:40</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Bas</first_name>
          <last_name>Luttik</last_name>
          <affiliation>Eindhoven University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.win.tue.nl/~luttik/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>94624521-1ef9-4dfe-b736-0a2fe74f1de7</subevent_id>
    <title>CPP: Research Papers: Proof Theory, Theory of Programming Languages</title>
    <timeslot>
      <slot_id>ef6ae897-2f41-4784-b6a2-8d194ad9bc50</slot_id>
      <title>Session: CPP - Research Papers: Proof Theory, Theory of Programming Languages</title>
      <room>Hotel Cascais Miragem | Sala XII</room>
      <date>2019/01/14</date>
      <start_time>11:00</start_time>
      <end_time>12:30</end_time>
      <tracks>
        <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala XII</room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/CPP-2019</url>
    <url_link_display>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</url_link_display>
    <tracks>
      <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
    </tracks>
    <timeslot>
      <slot_id>0be3ccf3-b32b-40b8-9f94-424b85918bfe</slot_id>
      <title>A proof-theoretic approach to certifying skolemization</title>
      <room>Hotel Cascais Miragem | Sala XII</room>
      <date>2019/01/14</date>
      <start_time>11:00</start_time>
      <end_time>11:30</end_time>
      <description>When presented with a formula to prove, most theorem provers for classical first-order logic process that formula following several steps, one of which is commonly called skolemization. That process eliminates quantifier alternation within formulas by extending the language of the underlying logic with new Skolem functions and by instantiating certain quantifiers with terms built using Skolem functions. In this paper, we address the problem of checking (i.e., certifying) proof evidence that involves Skolem terms. Our goal is to do such certification without using the mathematical concepts of model-theoretic semantics (i.e., preservation of satisfiability) and choice principles (i.e., epsilon terms). Instead, our proof checking kernel is an implementation of Gentzen’s sequent calculus, which directly supports quantifier alternation by using eigenvariables. We shall describe deskolemization as a mapping from client-side terms, used in proofs generated by theorem provers, into kernel-side terms, used within our proof checking kernel. This mapping which associates skolemized terms to eigenvariables relies on using outer skolemization. We also point out that the removal of Skolem terms from a proof is also influenced by the polarities given to propositional connectives. Yannick Forster and Dominique Larchey-Wendling. Certified Undecidability of Intuitionistic Linear Logic via Binary Stack Machines and Minsky Machines</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kaustuv</first_name>
          <last_name>Chaudhuri</last_name>
          <affiliation>Inria, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://chaudhuri.info</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Matteo</first_name>
          <last_name>Manighetti</last_name>
          <affiliation>Inria &amp; École Polytechnique</affiliation>
          <bio>PhD Student at LIX, École Polytechnique funded by Inria Saclay under the supervision of Dale Miller.</bio>
          <homepage_url>http://www.lix.polytechnique.fr/Labo/Matteo.Manighetti/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Dale</first_name>
          <last_name>Miler</last_name>
          <affiliation>INRIA Saclay and LIX</affiliation>
          <bio>Dale Miller received his PhD in Mathematics in 1983 from Carnegie Mellon University. He has been a professor at the University of Pennsylvania and Ecole Polytechnique (France) and Department Head in Computer Science and Engineering at Pennsylvania State University. He has held visiting positions at the universities of Aix-Marseille, Sienna, Genoa, Pisa, and Edinburgh. He is currently Director of Research (classe exceptionnelle) at Inria Saclay where he is the Scientific Leader of the Parsifal team. 
Miller was a two-term editor-in-chief of the ACM Transactions on Computational Logic. He is a member of editorial board of the Journal of Automated Reasoning. He is the General Chair for LICS until 2022. In 2014 he was a PC chair for CSL and LICS. He was awarded an ERC Advanced Grant in 2011 and the LICS Test-of-Time awards in 2011 and 2014 for papers written in 1991 and 1994.</bio>
          <homepage_url>http://www.lix.polytechnique.fr/Labo/Dale.Miller/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/dalemiler/feea0ac3-4b48-4ddb-a086-40503abc9417/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>48b5d959-cea1-49b0-83bb-54d22f06fb4a</slot_id>
      <title>Call-By-Push-Value in Coq: Operational, Equational, and Denotational Theory</title>
      <room>Hotel Cascais Miragem | Sala XII</room>
      <date>2019/01/14</date>
      <start_time>11:30</start_time>
      <end_time>12:00</end_time>
      <description>Call-by-push-value (CBPV) is an idealised calculus for functional and imperative programming, introduced as a subsuming paradigm for both call-by-value (CBV) and call-by-name (CBN). We formalise weak and strong operational semantics for (effect-free) CBPV, define a simple equational theory, and verify adequacy for the standard set/algebra denotational semantics. Furthermore, we prove normalisation of the standard reduction, confluence of strong reduction, strong normalisation using Kripke logical relations, and soundness of the equational theory using logical equivalence. We adapt and verify the known translations from CBV and CBN into CBPV for strong reduction. This yields, for instance, proofs of strong normalisation and confluence for the full lambda-calculus with sums and products. Thanks to the automation provided by Coq and the Autosubst 2 framework, there is little formalisation overhead compared to detailed paper proofs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yannick</first_name>
          <last_name>Forster</last_name>
          <affiliation>Saarland University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.ps.uni-saarland.de/~forster/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/yannickforster/6dd381ff-83b3-4144-8470-8bc786421ca4/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Steven</first_name>
          <last_name>Schäfer</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/stevenschafer/ca198129-c83e-48bb-a5e0-07c1cea127f9/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Simon</first_name>
          <last_name>Spies</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Kathrin</first_name>
          <last_name>Stark</last_name>
          <affiliation>Saarland University, Germany</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4cbfb1e9-bee7-4e14-b7e0-7a18a1e7dcad</slot_id>
      <title>Eliminating Reflection from Type Theory</title>
      <room>Hotel Cascais Miragem | Sala XII</room>
      <date>2019/01/14</date>
      <start_time>12:00</start_time>
      <end_time>12:30</end_time>
      <description>Type theories with equality reflection, such as extensional type theory (ETT), are convenient theories in which to formalise mathematics, as they make it possible to consider provably equal terms as convertible. Although type-checking is undecidable in this context, variants of ETT have been implemented, for example in NuPRL and more recently in Andromeda. The actual objects that can be checked are not proof-terms, but derivations of proof-terms. This suggests that any derivation of ETT can be translated into a typecheckable proof term of intensional type theory (ITT). However, this result, investigated categorically by Hofmann in 1995, and 10 years later more syntactically by Oury, has never given rise to an effective translation. In this paper, we provide the first syntactical translation from ETT to ITT with uniqueness of identity proofs and functional extensionality. This translation has been defined and proven correct in Coq and yields an executable plugin that translates a derivation in ETT into an actual Coq typing judgment. Additionally, we show how this result is extended in the context of homotopy to a two-level type theory.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Theo</first_name>
          <last_name>Winterhalter</last_name>
          <affiliation>Gallinette / Inria / LS2N</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nicolas</first_name>
          <last_name>Tabareau</last_name>
          <affiliation>Inria</affiliation>
          <bio>Nicolas Tabareau is a junior researcher at Inria, head of the Gallinette team (http://gallinette.inria.fr/). He conducts research on programming languages and proof assistants in order to provide better tools for proofs formalization both to computer scientists and mathematicians.</bio>
          <homepage_url>http://tabareau.fr</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/nicolastabareau/9008d3aa-ff81-41b4-92b9-6c24266ef793/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Matthieu</first_name>
          <last_name>Sozeau</last_name>
          <affiliation>Inria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.pps.univ-paris-diderot.fr/~sozeau/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/matthieusozeau/d1a3ad89-73f4-44cc-8f0b-830f395d9953/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e3872eb2-a897-49c1-973d-b5dedb2da14b</subevent_id>
    <title>OPCT: SESSION TYPES,  GRAPH-REWRITING</title>
    <timeslot>
      <slot_id>2944498b-2baf-4c54-b6bd-caf5cb3cc84c</slot_id>
      <title>Session: OPCT - SESSION TYPES,  GRAPH-REWRITING</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/14</date>
      <start_time>13:50</start_time>
      <end_time>15:30</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Antonio</first_name>
          <last_name>Ravara</last_name>
          <affiliation>Department of Informatics, Faculty of Sciences and Technology, NOVA University of Lisbon and NOVA LINCS</affiliation>
          <bio>Associate Professor at the Department of Informatics, Faculty of Sciences and Technology, NOVA University of Lisbon, Portugal (since October 2018). Founding member and Integrated researcher at the NOVA Laboratory for Computer Science and Informatics (NOVA LINCS), Portugal (since 2013). Assistant Professor at the Department of Informatics, Faculty of Sciences and Technology, NOVA University of Lisbon, Portugal ()2009 to 2018). Assistant Professor at the Section of Logic and Computation of the Department of Mathematics of IST. Technical University of Lisbon, Portugal (2000 to 2009). 
PhD in Mathematics at IST, of the Technical University of Lisbon, Portugal (December 2000). MSc in Applied Mathematics at IST of the Technical University of Lisbon, Portugal (May 1996). BSc in Geographical Engineering at the Faculty of Sciences of the University of Lisbon, Portugal (September 1991). 
Main research problem is how to ensure that inherently concurrent, highly distributed, software systems behave correctly. The focus is on the development of techniques, program constructions, and tools that help creating safe and well-behaved systems, provably providing correctness guarantees. The toolbox used includes static analysis of source code, capturing defects before deployment, with decidable, low complexity, property-driven, proof systems, using behavioural descriptions of programs.</bio>
          <homepage_url>http://nova-lincs.di.fct.unl.pt/person/47</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/antonioravara/dbb3f737-58d8-45cf-9c93-a54da5788412/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VII   </room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/opct-2019-papers</url>
    <url_link_display>OPCT 2019</url_link_display>
    <tracks>
      <track>OPCT 2019</track>
    </tracks>
    <timeslot>
      <slot_id>2f94a730-f080-4eca-a136-c9ac1b6b2436</slot_id>
      <title>Independence, Concurrency and Abstraction in Graph-Rewriting Processes</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/14</date>
      <start_time>15:05</start_time>
      <end_time>15:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Malte</first_name>
          <last_name>Lochau</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/maltelochau/8d3a8f9c-19e1-4e74-9891-58a38ab0f5de/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cb851209-d5de-4fcf-ae9c-ca811ca47b3e</slot_id>
      <title>Multiparty reactive sessions</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/14</date>
      <start_time>14:40</start_time>
      <end_time>15:05</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Cinzia</first_name>
          <last_name>Di Giusto</last_name>
          <affiliation>Laboratoire I3S</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.i3s.unice.fr/digiusto/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>dc869a60-4e99-4c1b-8a24-1cfd340f1954</slot_id>
      <title>From testing preorders to flaky tests</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/14</date>
      <start_time>14:15</start_time>
      <end_time>14:40</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Giovanni</first_name>
          <last_name>Bernardi</last_name>
          <affiliation>Université Paris Diderot</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.irif.fr/~gio/index.xhtml</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e3d14b3d-ff14-4aa5-a000-6d3d163a47bc</slot_id>
      <title>Taming Concurrency for Verification using Multiparty Session Types</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/14</date>
      <start_time>13:50</start_time>
      <end_time>14:15</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kirstin</first_name>
          <last_name>Peters</last_name>
          <affiliation>TU Berlin</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>544ddf44-dd90-4da9-b3fc-b4fc4c100b58</subevent_id>
    <title>CPP: Research Papers: Formalization of Mathematics and Computer Algebra</title>
    <timeslot>
      <slot_id>406db336-954c-486c-95db-640cd2dcc26b</slot_id>
      <title>Session: CPP - Research Papers: Formalization of Mathematics and Computer Algebra</title>
      <room>Hotel Cascais Miragem | Sala XII</room>
      <date>2019/01/15</date>
      <start_time>16:00</start_time>
      <end_time>17:30</end_time>
      <tracks>
        <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala XII</room>
    <date>2019/01/15</date>
    <url>https://popl19.sigplan.org/track/CPP-2019</url>
    <url_link_display>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</url_link_display>
    <tracks>
      <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
    </tracks>
    <timeslot>
      <slot_id>15f66d0c-8f0d-4284-a962-615b86297c29</slot_id>
      <title>Business Meeting</title>
      <room>Hotel Cascais Miragem | Sala XII</room>
      <date>2019/01/15</date>
      <start_time>17:00</start_time>
      <end_time>17:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Assia</first_name>
          <last_name>Mahboubi</last_name>
          <affiliation>INRIA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://specfun.inria.fr/mahboubi</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Magnus O.</first_name>
          <last_name>Myreen</last_name>
          <affiliation>Chalmers University of Technology, Sweden</affiliation>
          <bio>I did a B.A. in Computer Science at the University of Oxford, tutored by Dr Jeff Sanders. 
I completed my Ph.D. on program verification in 2009 at the University of Cambridge, supervised by Prof. Mike Gordon. My PhD dissertation was selected as the winner of the BCS Distinguished Dissertation Competition 2010. 
In 2012, I became a Royal Society Research Fellow, UK. 
In 2014, I moved to Chalmers where I became a tenured Associate Professor in 2015.</bio>
          <homepage_url>http://www.cse.chalmers.se/~myreen/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/magnusomyreen/ccd5e9cd-2811-4ef2-a9f0-3dd7802233ca/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>95ff1395-4fe1-42a4-86f2-5b53209ba6c2</slot_id>
      <title>Verified Solving and Asymptotics of Linear Recurrences</title>
      <room>Hotel Cascais Miragem | Sala XII</room>
      <date>2019/01/15</date>
      <start_time>16:30</start_time>
      <end_time>17:00</end_time>
      <description>Linear recurrences with constant coefficients are an interesting class of recurrence equations that can be solved explicitly. The most famous example are certainly the Fibonacci numbers with the equation f(n) = f(n-1) + f(n-2) and the quite non-obvious closed form (φ^n - (-φ)^(-n)) / sqrt(5) where φ is the golden ratio. The work presented here builds on existing tools in Isabelle/HOL – such as formal power series and polynomial factorisation algorithms – to develop a theory of these recurrences and derive a fully executable solver for them that can be exported to programming languages like Haskell. Based on this development, I also provide an efficient method to prove ‘Big-O’ asymptotics of a solution automatically without explicitly finding the closed-form solution first.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Eberl</last_name>
          <affiliation>Technische Universität München</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www21.in.tum.de/~eberlm</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/manueleberl/c99db53c-1989-4e25-9fba-ef232c625e24/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c3f2dea1-0934-4bb5-931e-df762fc54e4a</slot_id>
      <title>On Synthetic Undecidability in Coq, with an Application to the Entscheidungsproblem</title>
      <room>Hotel Cascais Miragem | Sala XII</room>
      <date>2019/01/15</date>
      <start_time>16:00</start_time>
      <end_time>16:30</end_time>
      <description>We formalise the algorithmic undecidability of validity, satisfiability, and provability of first-order formulas following a synthetic approach based on the computation native to Coq’s constructive type theory. Concretely, we consider Tarski and Kripke semantics as well as classical and intuitionistic natural deduction systems and provide compact many-one reductions from the Post correspondence problem (PCP). Moreover, developing a basic framework for synthetic computability theory in Coq, we formalise standard results concerning decidability, enumerability, and reducibility without reference to a concrete model of computation. For instance, we prove the equivalence of (an instance of) Post’s theorem with Markov’s principle and provide a convenient technique for establishing the enumerability of inductive predicates such as the considered proof systems and PCP.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yannick</first_name>
          <last_name>Forster</last_name>
          <affiliation>Saarland University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.ps.uni-saarland.de/~forster/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/yannickforster/6dd381ff-83b3-4144-8470-8bc786421ca4/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dominik</first_name>
          <last_name>Kirst</last_name>
          <affiliation>Saarland University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ps.uni-saarland.de/~kirst/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/dominikkirst/4abb14d5-8001-4d88-a1b2-07b6d1ad2cd2/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Gert</first_name>
          <last_name>Smolka</last_name>
          <affiliation>Saarland University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ps.uni-saarland.de/~smolka/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/gertsmolka/2ab7c8ce-c02d-4786-85b3-245d878ea78a/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>fe430ca5-185d-4c4e-94af-0a6f40cc409e</subevent_id>
    <title>PADL: PADL Session 3</title>
    <timeslot>
      <slot_id>f18dfa62-c978-4cb2-b236-601e4168e341</slot_id>
      <title>Session: PADL - PADL Session 3</title>
      <room>Hotel Cascais Miragem | Sala IV</room>
      <date>2019/01/15</date>
      <start_time>09:00</start_time>
      <end_time>10:30</end_time>
      <tracks>
        <track>PADL 2019 - 21st International Symposium on Practical Aspects of Declarative Languages</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala IV</room>
    <date>2019/01/15</date>
    <url>https://popl19.sigplan.org/track/PADL-2019</url>
    <url_link_display>PADL 2019 - 21st International Symposium on Practical Aspects of Declarative Languages</url_link_display>
    <tracks>
      <track>PADL 2019 - 21st International Symposium on Practical Aspects of Declarative Languages</track>
    </tracks>
    <timeslot>
      <slot_id>9f2c63a2-7ceb-4fd2-9791-ba1aad662cbf</slot_id>
      <title>Personalized Course Schedule Planning using Answer Set Programming</title>
      <room>Hotel Cascais Miragem | Sala IV</room>
      <date>2019/01/15</date>
      <start_time>09:30</start_time>
      <end_time>10:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Esra</first_name>
          <last_name>Erdem</last_name>
          <affiliation>Sabanci University, Turkey</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Muhammed</first_name>
          <last_name>Kerem Kahraman</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>PADL 2019 - 21st International Symposium on Practical Aspects of Declarative Languages</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e174b91f-5098-4f07-909d-ff90ea5f0d62</slot_id>
      <title>Static Partitioning of Spreadsheets for Parallel Execution</title>
      <room>Hotel Cascais Miragem | Sala IV</room>
      <date>2019/01/15</date>
      <start_time>10:00</start_time>
      <end_time>10:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alexander</first_name>
          <last_name>Asp Bock</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>PADL 2019 - 21st International Symposium on Practical Aspects of Declarative Languages</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>510ef282-731a-46cf-8b14-fc4ff00045df</subevent_id>
    <title>OPCT: CONCURRENT PROGRAMMING, MEMORY MODELS</title>
    <timeslot>
      <slot_id>f1500f89-cd43-431e-87ab-5fa7dc2e8d81</slot_id>
      <title>Session: OPCT - CONCURRENT PROGRAMMING, MEMORY MODELS</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/14</date>
      <start_time>16:00</start_time>
      <end_time>17:15</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Gustavo</first_name>
          <last_name>Petri</last_name>
          <affiliation>IRIF, Université Paris Diderot</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://gpetri.github.io/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/gustavopetri/08af6041-7317-4929-9a80-b63b5f03a5b6/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VII   </room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/opct-2019-papers</url>
    <url_link_display>OPCT 2019</url_link_display>
    <tracks>
      <track>OPCT 2019</track>
    </tracks>
    <timeslot>
      <slot_id>06ab8c32-6a99-4069-a7b7-3ad84683e9bb</slot_id>
      <title>Compositional Reasoning for Termination of Fine-grained Concurrent Programs</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/14</date>
      <start_time>16:50</start_time>
      <end_time>17:15</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Emanuele</first_name>
          <last_name>D'Osualdo</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>I am a Marie-Curie Fellow at Imperial College London, working on verification of concurrent software with Prof. P. Gardner. 
From 2017 to 2018 was a Research Associate in Philippa Gardner’s group at Imperial College London. From 2015 to 2017 I was a PostDoc in the Concurrency Theory Group at the University of Kaiserslautern, working with Prof. Roland Meyer. 
In 2015 I received a PhD (DPhil) in Computer Science from the University of Oxford. My supervisor was Prof. C.-H. Luke Ong. My dissertation won the 2016 CPHC/BCS Distinguished Dissertation award.</bio>
          <homepage_url>http://www.emanueledosualdo.com/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/emanueledosualdo/894cc572-3cb2-4925-a25d-91ee35a650d6/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>0dc4e53a-d756-4481-bf93-ef5111ee79f1</slot_id>
      <title>IPA: Invariant-preserving Applications for Weakly Consistent Replicated Databases</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/14</date>
      <start_time>16:25</start_time>
      <end_time>16:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Carla</first_name>
          <last_name>Ferreira</last_name>
          <affiliation>Universidade Nova Lisboa</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/carlaferreira/84cdc5a2-f01b-44cd-b28f-73ae8baed899/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5ef91018-3e71-43cf-9f55-f0586ca2b132</slot_id>
      <title>Linearizability in the context of weak memory models</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/14</date>
      <start_time>16:00</start_time>
      <end_time>16:25</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kirsten</first_name>
          <last_name>Winter</last_name>
          <affiliation>The University of Queensland</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8efb0fc9-4418-4cd9-9bc0-b0fec9143262</subevent_id>
    <title>PEPM: Session 1</title>
    <timeslot>
      <slot_id>3253a8bc-f631-45ad-a76c-fc0d3eb61996</slot_id>
      <title>Session: PEPM - Session 1</title>
      <room>Hotel Cascais Miragem | Sala X</room>
      <date>2019/01/14</date>
      <start_time>11:00</start_time>
      <end_time>12:30</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Hermenegildo</last_name>
          <affiliation>IMDEA Software Institute and T.U. of Madrid (UPM)</affiliation>
          <bio>Manuel Hermenegildo is a Full Professor and (Founding) Scientific Director of the IMDEA Software Institute. He is also a full Prof. of Computer Science at the Tech. U. of Madrid, UPM. Previously he held an Endowed Chair in Information Science and Technology at the U. of New Mexico. He was also project leader at the MCC research center and Adjunct Assoc. Prof. at the CS Department of the U. of Texas, both in Austin, Texas. See his home page for more information. 
Research interests: Energy-Aware Computing, Resource / non-functional property analysis, verification, and control; Global Program Analysis, Optimization, Verification, Debugging; Abstract Interpretation; Partial Evaluation; Parallelism and Parallelizing Compilers; Constraint/Logic/Functional Programming Theory and Implementation, Abstract Machines; Automatic Documentation Tools, Execution Visualization; Sequential and Parallel Computer Architecture.</bio>
          <homepage_url>http://cliplab.org/herme</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/manuelhermengildo/8eef27e4-befd-4c22-b6c8-20207eb80fd4/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>PEPM 2019</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala X</room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/pepm-2019-papers</url>
    <url_link_display>PEPM 2019</url_link_display>
    <tracks>
      <track>PEPM 2019</track>
    </tracks>
    <timeslot>
      <slot_id>50e102f9-b64c-423a-854c-3affc63cbf4d</slot_id>
      <title>Welcome to PEPM19</title>
      <room>Hotel Cascais Miragem | Sala X</room>
      <date>2019/01/14</date>
      <start_time>11:00</start_time>
      <end_time>11:05</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Co-chair</role>
          <sort_key>1</sort_key>
          <first_name>Atsushi</first_name>
          <last_name>Igarashi</last_name>
          <affiliation>Kyoto University, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fos.kuis.kyoto-u.ac.jp/~igarashi/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/atsushiigarashi/bbac1695-343a-4091-b33c-b7f01dea73da/small.jpg</picture_url>
        </person>
        <person>
          <role>Co-chair</role>
          <sort_key>2</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Hermenegildo</last_name>
          <affiliation>IMDEA Software Institute and T.U. of Madrid (UPM)</affiliation>
          <bio>Manuel Hermenegildo is a Full Professor and (Founding) Scientific Director of the IMDEA Software Institute. He is also a full Prof. of Computer Science at the Tech. U. of Madrid, UPM. Previously he held an Endowed Chair in Information Science and Technology at the U. of New Mexico. He was also project leader at the MCC research center and Adjunct Assoc. Prof. at the CS Department of the U. of Texas, both in Austin, Texas. See his home page for more information. 
Research interests: Energy-Aware Computing, Resource / non-functional property analysis, verification, and control; Global Program Analysis, Optimization, Verification, Debugging; Abstract Interpretation; Partial Evaluation; Parallelism and Parallelizing Compilers; Constraint/Logic/Functional Programming Theory and Implementation, Abstract Machines; Automatic Documentation Tools, Execution Visualization; Sequential and Parallel Computer Architecture.</bio>
          <homepage_url>http://cliplab.org/herme</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/manuelhermengildo/8eef27e4-befd-4c22-b6c8-20207eb80fd4/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>PEPM 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6fa2eb52-4e4e-4f2f-b50b-1534bb29da1c</slot_id>
      <title>A Simpler Lambda Calculus</title>
      <room>Hotel Cascais Miragem | Sala X</room>
      <date>2019/01/14</date>
      <start_time>12:00</start_time>
      <end_time>12:30</end_time>
      <description>Closure calculus is simpler than pure lambda-calculus as it does not mention free variables or index manipulation, variable renaming, implicit substitution, or any other meta-theory. Further, all programs, even recursive ones, can be expressed as normal forms. Third, there are reduction-preserving translations to calculi built from combinations of operators, in the style of combinatory logic. These improvements are achieved without sacrificing three fundamental properties of lambda-calculus, being a confluent rewriting system, supporting the Turing computable numerical functions, and supporting simple typing.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Barry</first_name>
          <last_name>Jay</last_name>
          <affiliation>University of Technology Sydney</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>PEPM 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>856c0cfa-3d1b-45eb-8e89-87e88fb098dc</slot_id>
      <title>Applying Futamura projections to compose languages and tools in GraalVM (Invited Talk)</title>
      <room>Hotel Cascais Miragem | Sala X</room>
      <date>2019/01/14</date>
      <start_time>11:05</start_time>
      <end_time>12:00</end_time>
      <description>Most high-performance dynamic language virtual machines duplicate language semantics in the interpreter, compiler, and runtime system. This violates the principle to not repeat yourself. In contrast, in GraalVM, we define languages solely by writing an interpreter [1]. To achieve high-performance we use an approach that was first described in 1971 by Y. Futamura [2], and is known as the first Futamura projection. The first Futamura projection allows languages to express powerful optimizations while keeping the compiler fully language agnostic. The runtime system composes interpreter nodes of multiple languages in one compilation unit to support polyglot interoperability and compilation [3]. A language agnostic instrumentation mechanism enables us to attach cross-cutting concerns to polyglot applications with zero overhead [4]. In this talk, I will introduce the theoretical concepts behind GraalVM and show how we build composable high-performance language implementations and tools. I will also preview some new ideas on how we want to apply the second Futamura projection in order to reach the compilation efficiency of specialized language-specific compilers. 
References: 
[1] Würthinger, Thomas, et al. “Practical partial evaluation for high-performance dynamic language runtimes.” ACM SIGPLAN Notices. Vol. 52. No. 6. ACM, 2017. [2] Futamura, Yoshihiko. “Partial evaluation of computation process–an approach to a compiler-compiler.” Higher-Order and Symbolic Computation 12.4 (1999): 381-391. [3] Grimmer, Matthias, et al. “High-performance cross-language interoperability in a multi-language runtime.” ACM SIGPLAN Notices. Vol. 51. No. 2. ACM, 2015. [4] Van De Vanter, Michael, et al. “Fast, Flexible, Polyglot Instrumentation Support for Debuggers and other Tools.” arXiv preprint arXiv:1803.10201 (2018).</description>
      <persons>
        <person>
          <role>invited speaker</role>
          <sort_key>1</sort_key>
          <first_name>Christian</first_name>
          <last_name>Humer</last_name>
          <affiliation>Oracle Labs, Switzerland</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/christianhumer/74984e5f-8039-4b31-9f4f-12d2d940d486/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>PEPM 2019</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>397d6d2c-3d5b-4db8-abcd-f0e6583c923f</subevent_id>
    <title>OPCT: ALGEBRA, COALGEBRA</title>
    <timeslot>
      <slot_id>322ac301-9c66-4c71-acb8-d664240a84ac</slot_id>
      <title>Session: OPCT - ALGEBRA, COALGEBRA</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/15</date>
      <start_time>16:00</start_time>
      <end_time>17:20</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Alexandra</first_name>
          <last_name>Silva</last_name>
          <affiliation>University College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.alexandrasilva.org/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/alexandrasilva/4b4137d3-8abf-423d-89b7-64b1a17139a5/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VII   </room>
    <date>2019/01/15</date>
    <url>https://popl19.sigplan.org/track/opct-2019-papers</url>
    <url_link_display>OPCT 2019</url_link_display>
    <tracks>
      <track>OPCT 2019</track>
    </tracks>
    <timeslot>
      <slot_id>0275f045-60ec-46ff-84f5-b910bc20ab42</slot_id>
      <title>Closing</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/15</date>
      <start_time>17:15</start_time>
      <end_time>17:20</end_time>
      <description>undefined</description>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>131e9d8a-37b3-41f4-8e66-7e19cfa7b4b9</slot_id>
      <title>A metric semantics for coordination languages</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/15</date>
      <start_time>16:25</start_time>
      <end_time>16:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Valentina</first_name>
          <last_name>Castiglioni</last_name>
          <affiliation>Inria Saclay - Ile de France</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>238f2ff9-3629-4373-b2eb-b3f0954ab62e</slot_id>
      <title>Hybrid system iteration</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/15</date>
      <start_time>16:50</start_time>
      <end_time>17:15</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Renato</first_name>
          <last_name>Neves</last_name>
          <affiliation>University of Minho &amp; INESC TEC</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://alfa.di.uminho.pt/~nevrenato/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a3571bec-480e-4a0b-a619-3d51718bdedd</slot_id>
      <title>Coalgebra Learning via Duality</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/15</date>
      <start_time>16:00</start_time>
      <end_time>16:25</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Juriaan</first_name>
          <last_name>Rot</last_name>
          <affiliation>Radboud University Nijmegen</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://jurriaan.me/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>79e08d49-8a56-4917-9c99-6b394bae9dde</subevent_id>
    <title>PEPM: Session 2</title>
    <timeslot>
      <slot_id>e3457d2d-75b8-4500-9235-74cff93a995f</slot_id>
      <title>Session: PEPM - Session 2</title>
      <room>Hotel Cascais Miragem | Sala X</room>
      <date>2019/01/14</date>
      <start_time>14:00</start_time>
      <end_time>15:30</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Thomas P.</first_name>
          <last_name>Jensen</last_name>
          <affiliation>INRIA Rennes</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.irisa.fr/celtique/jensen/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/thomaspjensen/88563f7d-114a-474a-aa4d-4eb39db60f73/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>PEPM 2019</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala X</room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/pepm-2019-papers</url>
    <url_link_display>PEPM 2019</url_link_display>
    <tracks>
      <track>PEPM 2019</track>
    </tracks>
    <timeslot>
      <slot_id>0f266513-c5e0-4528-abd2-2064ba7339d5</slot_id>
      <title>Reduction from Branching-Time Property Verification of Higher-Order Programs to HFL Validity Checking</title>
      <room>Hotel Cascais Miragem | Sala X</room>
      <date>2019/01/14</date>
      <start_time>14:30</start_time>
      <end_time>15:00</end_time>
      <description>Various methods have recently been proposed for temporal property verification of higher-order programs. In those methods, however, either temporal properties were limited to linear-time ones, or target programs were limited to finite-data programs. In this paper, we extend Kobayashi et al.'s recent method for verification of linear-time temporal properties based on HFLZ model checking, to deal with branching-time properties. We formalize branching-time property verification problems as an extension of HORS model checking called HORSZ model checking, present a sound and complete reduction to validity checking of (modal-free) HFLZ formulas, and prove its correctness. The correctness of the reduction subsumes the decidability of HORS model checking. The HFLZ formula obtained by the reduction from a HORSZ model checking problem can be considered a kind of verification condition for the orignal model checking problem. We also discuss interactive and automated methods for discharging the verification condition.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Keiichi</first_name>
          <last_name>Watanabe</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Takeshi</first_name>
          <last_name>Tsukada</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Hiroki</first_name>
          <last_name>Oshikawa</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Naoki</first_name>
          <last_name>Kobayashi</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>PEPM 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1bdba3e4-e05e-443c-ab84-06fe1bbab819</slot_id>
      <title>Typed Parsing and Unparsing for Untyped Regular Expression Engines</title>
      <room>Hotel Cascais Miragem | Sala X</room>
      <date>2019/01/14</date>
      <start_time>15:00</start_time>
      <end_time>15:30</end_time>
      <description>Regular expressions are used for a wide variety of purposes from web-page input validation to log file crawling. Very often, they are used not only to match strings, but also to extract data from them. Unfortunately, most regular expression engines only return a list of the substrings captured by the regular expression. The data has to be extracted from the matched substrings to be validated and transformed manually into a more structured format. 
For richer classes of grammars like CFGs, such issues can be solved using type-indexed combinators. Most combinator libraries provide a monadic API to track the type returned by the parser through easy-to-use combinators. This allows users to transform the input into a custom data-structure and go through complex validations as they describe their grammar. 
In this paper, we present the Tyre library which provides type-indexed combinators for regular languages. Our combinators provide type-safe extraction while delegating the task of substring matching to a preexisting regular expression engine. To do this, we use a two layer approach where the typed layer sits on top of an untyped layer. This technique is also amenable to several extensions, such as routing, unparsing and static generation of the extraction code. We also provide a syntax extension, which recovers the familiar and compact syntax of regular expressions. We implemented this technique in a very concise manner and evaluated its usefulness on two practical examples.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gabriel</first_name>
          <last_name>Radanne</last_name>
          <affiliation>University of Freiburg, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.irif.fr/~gradanne/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/gabrielradanne/ae153ba4-dd3c-4cfd-bb04-bbf449802f9b/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>PEPM 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7a7c1602-e9ce-44d7-a727-3f8723211a33</slot_id>
      <title>Method Name Suggestion with Hierarchical Attention Networks</title>
      <room>Hotel Cascais Miragem | Sala X</room>
      <date>2019/01/14</date>
      <start_time>14:00</start_time>
      <end_time>14:30</end_time>
      <description>Method Rename has been a widely used refactoring operation that improves program comprehension and maintenance. Descriptive method names that summarize functionalities of source code can facilitate program comprehension. Much research has been done to suggest method names through source code summarization. However, unlike natural language, a code snippet consists of basic blocks organized by complicated structures. In this work, we observe a hierarchical structure — tokens form basic blocks and basic blocks form a code snippet. Based on this observation, we exploit a hierarchical attention network to learn the representation of methods. Specifically, we apply two-level attention mechanisms to learn the importance of each token in a basic block and that of a basic block in a method respectively. We evaluated our approach on 10 open source repositories and compared it against three state-of-the-art approaches. The results on these open-source data show the superiority of our hierarchical attention networks in terms of effectiveness.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sihan</first_name>
          <last_name>Xu</last_name>
          <affiliation>Nankai University, China</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sen</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Nankai University, China</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Weijing</first_name>
          <last_name>Wang</last_name>
          <affiliation>Nankai University, China</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Xinya</first_name>
          <last_name>Cao</last_name>
          <affiliation>Nankai University, China</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Chenkai</first_name>
          <last_name>Guo</last_name>
          <affiliation>Nankai University, China</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Jing</first_name>
          <last_name>Xu</last_name>
          <affiliation>Nankai University, China</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>PEPM 2019</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>926e6623-b139-461a-8a74-80016c5601c5</subevent_id>
    <title>OPCT: ALGEBRA, COALGEBRA, MODEL CHECKING</title>
    <timeslot>
      <slot_id>e9df8d7b-5397-495d-ad27-3e1ecf014f0b</slot_id>
      <title>Session: OPCT - ALGEBRA, COALGEBRA, MODEL CHECKING</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/15</date>
      <start_time>13:50</start_time>
      <end_time>15:30</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Barbara</first_name>
          <last_name>Koenig</last_name>
          <affiliation>University of Duisburg-Essen</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VII   </room>
    <date>2019/01/15</date>
    <url>https://popl19.sigplan.org/track/opct-2019-papers</url>
    <url_link_display>OPCT 2019</url_link_display>
    <tracks>
      <track>OPCT 2019</track>
    </tracks>
    <timeslot>
      <slot_id>76af802f-897d-4ced-a378-5dec059b2e76</slot_id>
      <title>Model checking true concurrency properties</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/15</date>
      <start_time>14:15</start_time>
      <end_time>14:40</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Paolo</first_name>
          <last_name>Baldan</last_name>
          <affiliation>University of Padova</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.math.unipd.it/~baldan</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/paolobaldan/74ce6038-7d9f-47e9-bd84-724fc0253f29/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cb5bf00f-2e5b-4d00-8341-29b52ec1d177</slot_id>
      <title>Weak Bisimulation Metrics in Models with Nondeterminism and Continuous States Space: A Logical Characterization</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/15</date>
      <start_time>15:05</start_time>
      <end_time>15:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Simone</first_name>
          <last_name>Tini</last_name>
          <affiliation>University of Insubria</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://disat.uninsubria.it/~simone.tini/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ceb26058-db85-4edd-a744-43ed69f97b31</slot_id>
      <title>A (Co)algebraic Approach to Hennessy-Milner Theorems for Weakly Expressive Logics</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/15</date>
      <start_time>14:40</start_time>
      <end_time>15:05</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Helle Hvid</first_name>
          <last_name>Hansen</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://homepage.tudelft.nl/c9d1n/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ea0a53d8-b50c-4acb-9efb-8a8d5aea561a</slot_id>
      <title>Bayes meets Dijkstra: Verifying Bayes Networks by Program Verification</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/15</date>
      <start_time>13:50</start_time>
      <end_time>14:15</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Joost-Pieter</first_name>
          <last_name>Katoen</last_name>
          <affiliation>RWTH Aachen University</affiliation>
          <bio>I am full professor at the RWTH Aachen University in the Software Modeling and Verification (MOVES) group and part-time associated to the Formal Methods &amp;amp; Tools group at the University of Twente. Since 2013, I hold a distinguished professorship at RWTH Aachen University and am member of the Academia Europaea.</bio>
          <homepage_url>http://www-i2.informatik.rwth-aachen.de/~katoen/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/joostpieterkatoen/1ea5c4a0-80d3-4a86-be9a-daf5471ea24d/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5ba15aeb-b489-4476-8815-ce1f2caed6c3</subevent_id>
    <title>OPCT: CYBERPHYSICAL SYSTEMS, HYBRID SYSTEMS</title>
    <timeslot>
      <slot_id>0b7ab47b-8af0-4a1b-9636-56e7311d2a78</slot_id>
      <title>Session: OPCT - CYBERPHYSICAL SYSTEMS, HYBRID SYSTEMS</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/15</date>
      <start_time>11:15</start_time>
      <end_time>12:30</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Philippa</first_name>
          <last_name>Gardner</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~pg/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VII   </room>
    <date>2019/01/15</date>
    <url>https://popl19.sigplan.org/track/opct-2019-papers</url>
    <url_link_display>OPCT 2019</url_link_display>
    <tracks>
      <track>OPCT 2019</track>
    </tracks>
    <timeslot>
      <slot_id>3675fa28-e78d-432d-b448-b9dccac8f29f</slot_id>
      <title>Attribute based communication for Collective Adaptive Systems</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/15</date>
      <start_time>11:40</start_time>
      <end_time>12:05</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Rocco</first_name>
          <last_name>De Nicola</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9b6732f5-18e9-4c79-b1c7-25932c9262b4</slot_id>
      <title>Designing Resilient Large Scaled CPS: Models, Languages and Tools </title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/15</date>
      <start_time>12:05</start_time>
      <end_time>12:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michele</first_name>
          <last_name>Loreti</last_name>
          <affiliation>University of Camerino</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.micheleloreti.com</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/micheleloreti/9af2fa00-9085-40b2-af5b-484dade53f21/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e883a236-8551-496b-b872-9f363f937b6c</slot_id>
      <title>Hybrid systems reachability analysis</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/15</date>
      <start_time>11:15</start_time>
      <end_time>11:40</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Erika</first_name>
          <last_name>Abraham</last_name>
          <affiliation>RWTH Aachen University</affiliation>
          <bio> 
  2013-today: Full professor, RWTH Aachen University, Germany. Head of the research group Theory of Hybrid Systems. Research topics: SMT solving, formal methods for probabilistic and hybrid systems.  
  2008-2013: Junior professor, RWTH Aachen University, Germany. Head of the junior research group Theory of Hybrid Systems. Research topics: SMT solving, formal methods for probabilistic and hybrid systems.  
  2007-2008: Postdoctoral researcher, Jülich Research Centre, Germany. Research topics: parallel and high-performance computing, performance analysis.  
  2005-2007: Postdoctoral researcher, Albert-Ludwigs-University Freiburg, Germany. Research topics: Verification of hybrid systems, bounded model checking, SAT and SMT solving.  
  1999-2005: Ph.D. student, Christian-Albrechts-University Kiel, Germany. Research topics: Deductive proof systems for multithreaded object-oriented languages.  
</bio>
          <homepage_url>http://ths.rwth-aachen.de/people/erika-abraham/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/erikaabraham/24df4f80-87f3-44d7-8a64-b57a03770233/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>482381f3-e37d-4307-8ead-f0368a53555b</subevent_id>
    <title>CPP: Research Papers: Program Verification</title>
    <timeslot>
      <slot_id>90ed09ac-8873-44d7-8a15-a3c967c6bf9e</slot_id>
      <title>Session: CPP - Research Papers: Program Verification</title>
      <room>Hotel Cascais Miragem | Sala XII</room>
      <date>2019/01/14</date>
      <start_time>14:00</start_time>
      <end_time>15:30</end_time>
      <tracks>
        <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala XII</room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/CPP-2019</url>
    <url_link_display>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</url_link_display>
    <tracks>
      <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
    </tracks>
    <timeslot>
      <slot_id>097d12ff-3d70-4710-a4ce-488615f9b534</slot_id>
      <title>From C to Interaction Trees: Specifying, Verifying, and Testing a Networked Server</title>
      <room>Hotel Cascais Miragem | Sala XII</room>
      <date>2019/01/14</date>
      <start_time>15:00</start_time>
      <end_time>15:30</end_time>
      <description>We present the first formal verification of a networked server implemented in C. Interaction trees, a general structure for representing reactive computations, are used to tie together disparate verification and testing tools (Coq, VST, and QuickChick) and to axiomatize the behavior of the operating-system on which the server runs (CertiKOS). The main theorem connects a specification of acceptable server behaviors, written in a straightforward “one client at a time” style, with the CompCert semantics of the C program. The variability introduced by low-level buffering of messages and interleaving of multiple TCP connections is captured using network refinement, a variant of observational refinement.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nicolas</first_name>
          <last_name>Koh</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yao</first_name>
          <last_name>Li</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://lastland.github.io/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/yaoli/ac58cfa1-acf7-454b-a4fc-cbdf519f65fb/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Yishuai</first_name>
          <last_name>Li</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cis.upenn.edu/~yishuai/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/yishuaili/68c0fe34-2fe1-4f8a-bacd-b9f3fba048ca/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Li-yao</first_name>
          <last_name>Xia</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Lennart</first_name>
          <last_name>Beringer</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.princeton.edu/~eberinge</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/lennartberinger/8d7941ba-0ebb-43e7-a71e-11f1c3b01754/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Wolf</first_name>
          <last_name>Honore</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>William</first_name>
          <last_name>Mansky</last_name>
          <affiliation>University of Illinois at Chicago</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.uic.edu/~mansky/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/williammansky/19f34f65-0c47-4bc2-9da6-21d1cc2ed8dc/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Benjamin C.</first_name>
          <last_name>Pierce</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>Benjamin Pierce is Henry Salvatori Professor of Computer and Information Science at the University of Pennsylvania and a Fellow of the ACM. His research interests include programming languages, type systems, language-based security, computer-assisted formal verification, differential privacy, and synchronization technologies. He is the author of the widely used graduate textbooks Types and Programming Languages and Software Foundations. He has served as co-Editor in Chief of the Journal of Functional Programming, as Managing Editor for Logical Methods in Computer Science, and as editorial board member of Mathematical Structures in Computer Science, Formal Aspects of Computing, and ACM Transactions on Programming Languages and Systems. He is also the lead designer of the popular Unison file synchronizer.</bio>
          <homepage_url>http://www.cis.upenn.edu/~bcpierce/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/benjamincpierce/f2ee6f41-5bf7-4a0d-9b8d-71de6a666b1b/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>9</sort_key>
          <first_name>Steve</first_name>
          <last_name>Zdancewic</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cis.upenn.edu/~stevez</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/stevezdancewic/41b883c6-4689-4ae3-b6f1-6b7a24622e99/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c0263aec-a3bc-4e52-b3e5-7d205c37a0d0</slot_id>
      <title>Formally Verified Big Step Semantics out of x86-64 Binaries</title>
      <room>Hotel Cascais Miragem | Sala XII</room>
      <date>2019/01/14</date>
      <start_time>14:00</start_time>
      <end_time>14:30</end_time>
      <description>This paper presents a methodology for generating formally proven equivalence theorems between decompiled x86-64 machine code and big step semantics. These proofs are built on top of two additional contributions. First, a robust and tested formal x86-64 machine model containing small step semantics for 1625 instructions. Second, a decompilation-into-logic methodology supporting both x86-64 assembly and machine code at large scale. This work enables black-box binary verification, i.e., formal verification of a binary where source code is unavailable. As such, it can be applied to safety-critical systems that consist of legacy components, or components whose source code is unavailable due to proprietary reasons. The methodology minimizes the trusted code base by leveraging machine-learned semantics to build a formal machine model. We apply the methodology to several case studies, including binaries that heavily rely on the SSE2 floating-point instruction set, and binaries that are obtained by compiling code that is obtained by inlining assembly into C code.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ian</first_name>
          <last_name>Roessle</last_name>
          <affiliation>Virginia Tech, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ianroessle.org</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/ianroessle/baa9935c-5770-4b60-8d7c-7a59335ef8f3/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Freek</first_name>
          <last_name>Verbeek</last_name>
          <affiliation>Open University of the Netherlands, The Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ru.nl/~freekver/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Binoy</first_name>
          <last_name>Ravindran</last_name>
          <affiliation>Virginia Tech</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c47c17c2-d79c-48eb-97ec-45cd17a46bc3</slot_id>
      <title>Formal Verification of a Program Obfuscation Based on Mixed Boolean-Arithmetic Expressions</title>
      <room>Hotel Cascais Miragem | Sala XII</room>
      <date>2019/01/14</date>
      <start_time>14:30</start_time>
      <end_time>15:00</end_time>
      <description>The insertion of expressions mixing arithmetic operators and bitwise boolean operators is a widespread protection of sensitive data in source programs. This recent advanced obfuscation technique is one of the less studied among program obfuscations even if it is commonly found in binary code. In this paper, we formally verify in Coq this data obfuscation. It operates over a generic notion of mixed boolean-arithmetic expressions and on properties of bitwise operators operating over machine integers. Our obfuscation performs two kinds of program transformations: rewriting of expressions and insertion of modular inverses. To facilitate its proof of correctness, we define boolean semantic tables, a data structure inspired from truth tables. Our obfuscation is integrated into the CompCert formally verified compiler where it operates over Clight programs. The automatic extraction of our program obfuscator into OCaml yields a program with competitive results.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sandrine</first_name>
          <last_name>Blazy</last_name>
          <affiliation>Univ Rennes- IRISA</affiliation>
          <bio>I am professor in the computer science department of the University of Rennes 1, where I am in charge of the research master in computer science. I am a member of CELTIQUE, a joint project-team with Inria Rennes Bretagne Atlantique and the IRISA laboratory. 
My research activities concern the formal verification using the Coq proof assistant of program transformations and semantic properties of programming languages, such as those found in the CompCert compiler and the Verasco static analyzer. I teach mechanized semantics (in Coq), functional programming (in OCaml), formal methods (using the Why3 tool), and software vulnerabilities.</bio>
          <homepage_url>https://people.irisa.fr/Sandrine.Blazy/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/sandrineblazy/bacd0031-1d22-476c-b6e5-fc58b1ab1177/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Rémi</first_name>
          <last_name>Hutin</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.irisa.fr/Remi.Hutin/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0af9e8ba-0ec3-4f74-b97c-6fb6e867f28a</subevent_id>
    <title>PEPM: Session 5</title>
    <timeslot>
      <slot_id>bbf96ab0-7090-4340-82f1-f50614d57eca</slot_id>
      <title>Session: PEPM - Session 5</title>
      <room>Hotel Cascais Miragem | Sala X</room>
      <date>2019/01/15</date>
      <start_time>14:00</start_time>
      <end_time>15:30</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Alberto</first_name>
          <last_name>Pettorossi</last_name>
          <affiliation>University of Rome Tor Vergata, Italy</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/albertopettorossi/83ce5b1c-392f-422f-90ba-f3046b54fb73/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>PEPM 2019</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala X</room>
    <date>2019/01/15</date>
    <url>https://popl19.sigplan.org/track/pepm-2019-papers</url>
    <url_link_display>PEPM 2019</url_link_display>
    <tracks>
      <track>PEPM 2019</track>
    </tracks>
    <timeslot>
      <slot_id>1ac7c179-d8db-4a04-bf37-c413da083c02</slot_id>
      <title>Futures and Promises in Haskell and Scala</title>
      <room>Hotel Cascais Miragem | Sala X</room>
      <date>2019/01/15</date>
      <start_time>14:30</start_time>
      <end_time>15:00</end_time>
      <description>Futures and promises are a high-level concurrency construct to aid the user in writing scalable and correct asynchronous programs. We introduce a simple core language based on which we can derive a rich set of future and promise features. We discuss ways to implement the core features via shared-state concurrency making either use of Software Transactional Memory, an elementary lock-based primitive, or an atomic compare-and-swap operation. The approach has been fully implemented in Haskell and Scala. For both languages, we provide empirical evidence of the effectiveness of our method. We consider program transformations in the context of futures and promises and observe potential problems in existing Scala-based libraries.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tamino</first_name>
          <last_name>Dauth</last_name>
          <affiliation>Karlsruhe University of Applied Sciences, Germany</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Martin</first_name>
          <last_name>Sulzmann</last_name>
          <affiliation>Karlsruhe University of Applied Sciences, Germany</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>PEPM 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5992ed1a-f5c1-4937-89a2-0c58b42f4280</slot_id>
      <title>Generating Mutually Recursive Definitions</title>
      <room>Hotel Cascais Miragem | Sala X</room>
      <date>2019/01/15</date>
      <start_time>15:00</start_time>
      <end_time>15:30</end_time>
      <description>Many functional programs — state machines top-down and bottom-up parsers, evaluators, GUI initialization graphs, etc. — are conveniently expressed as groups of mutually recursive bindings. One therefore expects program generators, such as those written in MetaOCaml, to be able to build programs with mutual recursion. 
Unfortunately, currently MetaOCaml can only build recursive groups whose size is hard-coded in the generating program. The general case requires something other than quotation, and seemingly weakens static guarantees on the resulting code. We describe the challenges and propose a new language construct for assuredly generating binding groups of arbitrary size~– illustrating with a collection of examples for mutual, n-ary, heterogeneous, value and polymorphic recursion.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jeremy</first_name>
          <last_name>Yallop</last_name>
          <affiliation>University of Cambridge, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cl.cam.ac.uk/~jdy22/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Oleg</first_name>
          <last_name>Kiselyov</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://okmij.org/ftp/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/olegkiselyov/f324364f-02c8-4bde-8df7-fc07f4057507/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>PEPM 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e9302c95-e710-4f88-b15e-85cdf99cec60</slot_id>
      <title>Extracting a Call-by-Name Partial Evaluator from a Proof of Termination</title>
      <room>Hotel Cascais Miragem | Sala X</room>
      <date>2019/01/15</date>
      <start_time>14:00</start_time>
      <end_time>14:30</end_time>
      <description>It is well known that the computational content of a termination proof of a calculus is an interpreter that computes the result of an input term. Traditionally, such extraction has been tried for a calculus with deterministic reduction rules, producing the result as a value, i.e., in weak head normal form where no redexes are reduced under lambda. In this paper, we consider non-deterministic reduction rules where any redexes can be reduced, even the ones under lambda, and extract a partial evaluator, rather than an interpreter, that produces the result in normal form. We formalize a call-by-name, simply-typed, lambda calculus in the Agda proof assistant and prove its termination using a logical predicate. We observe that the extracted program can be regarded as an online partial evaluator and present future perspectives about how we can extend the framework to a call-by-value calculus.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kenichi</first_name>
          <last_name>Asai</last_name>
          <affiliation>Ochanomizu University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pllab.is.ocha.ac.jp/~asai/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/kenichiasai/8f4ff835-8fd8-4b50-bcae-abd92601a71b/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>PEPM 2019</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>16402b3c-26ff-48eb-9b20-62a1b223b663</subevent_id>
    <title>CPP: Research Papers: Formalization of Mathematics and Computer Algebra</title>
    <timeslot>
      <slot_id>25512d1e-9ca0-4cec-b42c-143b54ac06c2</slot_id>
      <title>Session: CPP - Research Papers: Formalization of Mathematics and Computer Algebra</title>
      <room>Hotel Cascais Miragem | Sala XII</room>
      <date>2019/01/14</date>
      <start_time>16:00</start_time>
      <end_time>17:30</end_time>
      <tracks>
        <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala XII</room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/CPP-2019</url>
    <url_link_display>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</url_link_display>
    <tracks>
      <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
    </tracks>
    <timeslot>
      <slot_id>24198080-1563-456b-93f0-5830959ad170</slot_id>
      <title>A formal proof of Hensel's lemma over the p-adic integers</title>
      <room>Hotel Cascais Miragem | Sala XII</room>
      <date>2019/01/14</date>
      <start_time>16:00</start_time>
      <end_time>16:30</end_time>
      <description>The field of p-adic numbers Qp and the ring of p-adic integers Zp are essential constructions of modern number theory. Hensel’s lemma, described by Gouvêa as the “most important algebraic property of the p-adic numbers”, shows the existence of roots of polynomials over Zp provided an initial seed point. The theorem can be proved for the p-adics with significantly weaker hypotheses than for general rings. We construct Qp and Zp in the Lean proof assistant, with various associated algebraic properties, and formally prove a strong form of Hensel’s lemma. The proof lies at the intersection of algebraic and analytic reasoning and demonstrates how the Lean mathematical library handles such a heterogeneous topic.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Robert Y.</first_name>
          <last_name>Lewis</last_name>
          <affiliation>Vrije Universiteit Amsterdam</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://robertylewis.com</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/robertlewis/6c801efe-bcae-47a2-a00b-3fdac706fec0/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>761ea622-78d1-43e3-81a7-845519fcb361</slot_id>
      <title>Smooth Manifolds and Types to Sets for Linear Algebra in Isabelle/HOL</title>
      <room>Hotel Cascais Miragem | Sala XII</room>
      <date>2019/01/14</date>
      <start_time>17:00</start_time>
      <end_time>17:30</end_time>
      <description>We formalize the definition and basic properties of smooth manifolds in Isabelle/HOL. Concepts covered include partition of unity, tangent and cotangent spaces, and the fundamental theorem for line integrals. We also construct some concrete manifolds such as spheres and projective spaces. The formalization makes extensive use of the existing libraries for topology and analysis. The existing library for linear algebra is not flexible enough for our needs. We therefore set up the first systematic and large scale application of ``types to sets''. It allows us to automatically transform the existing (type based) library of linear algebra to one with explicit carrier sets.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Fabian</first_name>
          <last_name>Immler</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Bohua</first_name>
          <last_name>Zhan</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c694a578-ce18-492c-804f-92c5163b39cd</slot_id>
      <title>Counting Polynomial Roots in Isabelle/HOL: A formal Proof of the Budan-Fourier Theorem</title>
      <room>Hotel Cascais Miragem | Sala XII</room>
      <date>2019/01/14</date>
      <start_time>16:30</start_time>
      <end_time>17:00</end_time>
      <description>Many problems in computer algebra and numerical analysis can be reduced to counting or approximating the real roots of a polynomial within an interval. Existing verified root-counting procedures in major proof assistants are mainly based on the classical Sturm theorem, which only counts distinct roots. 
In this paper, we have strengthened the root-counting ability in Isabelle/HOL by first formally proving the Budan-Fourier theorem. Subsequently, based on Descartes’ rule of signs and Taylor shift, we have provided a verified procedure to efficiently over-approximate the number of real roots within an interval, counting multiplicity. For counting multiple roots exactly, we have extended our previous formalisation of Sturm’s theorem. Finally, as an application, we apply the results above to improve our previous certified complex-root-counting procedures based on Cauchy indices. We believe those verified routines will be crucial for certifying programs and building tactics.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Wenda</first_name>
          <last_name>Li</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cl.cam.ac.uk/~wl302/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Lawrence</first_name>
          <last_name>Paulson</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>Lawrence Paulson is Professor of Computational Logic at the University of Cambridge Computer Laboratory, where he has held established positions since 1983. He has written over 90 refereed conference and journal papers as well as four books. He introduced the popular Isabelle theorem proving environment in 1986, and made contributions to the verification of cryptographic protocols, the formalisation of mathematics, automated theorem proving technology, and other fields. He has supervised over 20 postgraduate students and numerous postdoctoral researchers. In 2008, he introduced MetiTarski, an automatic theorem prover for real-valued functions such as logarithms and exponentials. He has the honorary title of Distinguished Affiliated Professor from the Technical University of Munich and is an ACM Fellow.</bio>
          <homepage_url>http://www.cl.cam.ac.uk/~lp15/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/lawrencepaulson/0728a8a4-67ec-4322-94e1-6a38c1d8a26f/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e2cfc398-8015-4436-8117-7fdde332eb40</subevent_id>
    <title>PADL: PADL Session 4</title>
    <timeslot>
      <slot_id>949f68ee-c6a7-4f03-a48e-bba6cd1d0961</slot_id>
      <title>Session: PADL - PADL Session 4</title>
      <room>Hotel Cascais Miragem | Sala IV</room>
      <date>2019/01/15</date>
      <start_time>11:00</start_time>
      <end_time>12:30</end_time>
      <tracks>
        <track>PADL 2019 - 21st International Symposium on Practical Aspects of Declarative Languages</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala IV</room>
    <date>2019/01/15</date>
    <url>https://popl19.sigplan.org/track/PADL-2019</url>
    <url_link_display>PADL 2019 - 21st International Symposium on Practical Aspects of Declarative Languages</url_link_display>
    <tracks>
      <track>PADL 2019 - 21st International Symposium on Practical Aspects of Declarative Languages</track>
    </tracks>
    <timeslot>
      <slot_id>1cd8902e-db0f-4746-a6ad-e228b834f5c9</slot_id>
      <title>An ASP-based Approach to Representing and Querying Textual Knowledge</title>
      <room>Hotel Cascais Miragem | Sala IV</room>
      <date>2019/01/15</date>
      <start_time>11:00</start_time>
      <end_time>11:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dhruva</first_name>
          <last_name>Pendharkar</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Gopal</first_name>
          <last_name>Gupta</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>PADL 2019 - 21st International Symposium on Practical Aspects of Declarative Languages</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3a567368-a003-4e99-baf8-e19ea39b720b</slot_id>
      <title>Automatic Program Rewriting in Non-Ground Answer Set Programs</title>
      <room>Hotel Cascais Miragem | Sala IV</room>
      <date>2019/01/15</date>
      <start_time>12:00</start_time>
      <end_time>12:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nick</first_name>
          <last_name>Hippen</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yuliya</first_name>
          <last_name>Lierler</last_name>
          <affiliation>University of Nebraska</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://faculty.ist.unomaha.edu/ylierler/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>PADL 2019 - 21st International Symposium on Practical Aspects of Declarative Languages</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>546329e7-b7de-4bac-90eb-0e626b1b7997</slot_id>
      <title>Strong Equivalence and Program's Structure in Arguing Essential Equivalence</title>
      <room>Hotel Cascais Miragem | Sala IV</room>
      <date>2019/01/15</date>
      <start_time>11:30</start_time>
      <end_time>12:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yuliya</first_name>
          <last_name>Lierler</last_name>
          <affiliation>University of Nebraska</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://faculty.ist.unomaha.edu/ylierler/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>PADL 2019 - 21st International Symposium on Practical Aspects of Declarative Languages</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>10d2e773-15d1-4267-b48f-9f4c47dc024e</subevent_id>
    <title>CPP: Research Papers: Program Verification</title>
    <timeslot>
      <slot_id>fb19bd25-6266-488d-816f-dfd9a54a5faf</slot_id>
      <title>Session: CPP - Research Papers: Program Verification</title>
      <room>Hotel Cascais Miragem | Sala XII</room>
      <date>2019/01/15</date>
      <start_time>14:00</start_time>
      <end_time>15:30</end_time>
      <tracks>
        <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala XII</room>
    <date>2019/01/15</date>
    <url>https://popl19.sigplan.org/track/CPP-2019</url>
    <url_link_display>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</url_link_display>
    <tracks>
      <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
    </tracks>
    <timeslot>
      <slot_id>33dc2adf-8c5a-4820-9762-1a4bfafee9f6</slot_id>
      <title>A Coq mechanised formal semantics for realistic SQL queries - Formally reconciling SQL and bag relational algebra</title>
      <room>Hotel Cascais Miragem | Sala XII</room>
      <date>2019/01/15</date>
      <start_time>14:30</start_time>
      <end_time>15:00</end_time>
      <description>In this article, we provide a Coq mechanised, executable, formal semantics for a realistic fragment of SQL consisting of select [distinct] from where group by having queries with NULL values, functions, aggregates, quantifiers and nested potentially correlated sub-queries. Relying on the Coq extraction mechanism to Ocaml, we produce a Coq certified semantic analyser for a SQL compiler. We then relate this fragment to a Coq formalised (extended) relational algebra that enjoys a bag semantics hence recovering all well-known algebraic equivalences upon which are based most of compilation optimisations. By doing so, we provide the first formally mechanised proof of the equivalence of SQL and extended relational algebra.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Véronique</first_name>
          <last_name>Benzaken</last_name>
          <affiliation>LRI, Université Paris-Sud</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.lri.fr/~benzaken/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/veroniquebenzaken/b23ded8d-6b45-4c92-84fd-d345b2587e4b/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Evelyne</first_name>
          <last_name>Contejean</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>35cef381-1c41-4973-9f9b-3d52a0e45998</slot_id>
      <title>A Verified Protocol Buffer Compiler</title>
      <room>Hotel Cascais Miragem | Sala XII</room>
      <date>2019/01/15</date>
      <start_time>14:00</start_time>
      <end_time>14:30</end_time>
      <description>The code responsible for serializing and deserializing untrusted external data is a vital component of any software that communicates with the outside world, as any bugs in these components represent a key attack vector for remote attackers. This situation is particularly acute for verified systems, where any defects in the parsing code can invalidate any formal proofs about the system. One way to reduce the trusted code base of these systems is to use interface generators like Protocol Buffer and ASN.1 to generate serializers and deserializers from data descriptors. Of course, these generators are not immune from bugs. 
In this work, we formally verify a compiler for a realistic subset of the popular Protocol Buffer serialization format using the Coq proof assistant, proving once and for all the correctness of every generated serializer and deserializer. One of the challenges we had to overcome was the extreme flexibility of the Protocol Buffer format: the same source data can be encoded in an infinite number of ways, and the deserializer must faithfully recover the original source value from each. We have validated our verified system using the official conformance tests.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Qianchuan</first_name>
          <last_name>Ye</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Benjamin</first_name>
          <last_name>Delaware</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.purdue.edu/homes/bendy/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/benjamindelaware/39bbf6b3-d145-435c-8956-8acf8cfcaffa/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c8c0d99a-6cd8-4dfe-8cb2-532bf4b47132</slot_id>
      <title>Dynamic Class Initialization Semantics: a Jinja Extension</title>
      <room>Hotel Cascais Miragem | Sala XII</room>
      <date>2019/01/15</date>
      <start_time>15:00</start_time>
      <end_time>15:30</end_time>
      <description>The Java Virtual Machine (JVM) postpones running class initialization methods until their classes are first referenced, such as by a \texttt{new} or static instruction. This process is called dynamic class initialization. Jinja is a semantic framework for Java and JVM developed in the theorem prover Isabelle that includes several semantics: Java-level big-step and small-step semantics, JVM-level small-step semantics, and an intermediate compilation step, J1, between these two levels. In this paper, we extend Jinja to include support for static instructions and dynamic class initialization. We also extend and re-prove related proofs, including Java-level type safety, equivalence between Java-level big-step and small-step semantics, and the correctness of a compilation from the Java level to the JVM level through J1. This work is based on the Java SE 8 specification.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Susannah</first_name>
          <last_name>Mansky</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Elsa</first_name>
          <last_name>Gunter</last_name>
          <affiliation>University of Illinois</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://egunter.cs.illinois.edu/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/elsagunter/fec4e9dd-f691-4462-a2e0-198dd02b8498/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e8234f60-d4e5-4f51-8858-f9433afe8058</subevent_id>
    <title>CPP: Keynote 2 and Research Paper</title>
    <timeslot>
      <slot_id>083205ea-40f6-4111-a52e-eb85273b0e3b</slot_id>
      <title>Session: CPP - Keynote 2 and Research Paper</title>
      <room>Hotel Cascais Miragem | Sala XII</room>
      <date>2019/01/15</date>
      <start_time>09:00</start_time>
      <end_time>10:30</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Assia</first_name>
          <last_name>Mahboubi</last_name>
          <affiliation>INRIA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://specfun.inria.fr/mahboubi</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala XII</room>
    <date>2019/01/15</date>
    <url>https://popl19.sigplan.org/track/CPP-2019</url>
    <url_link_display>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</url_link_display>
    <tracks>
      <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
    </tracks>
    <timeslot>
      <slot_id>531635c5-5ed3-402f-a719-2d428c90a84f</slot_id>
      <title>A Verified Prover Based on Ordered Resolution</title>
      <room>Hotel Cascais Miragem | Sala XII</room>
      <date>2019/01/15</date>
      <start_time>10:00</start_time>
      <end_time>10:30</end_time>
      <description>The superposition calculus, which underlies first-order theorem provers such as E, SPASS, and Vampire, combines ordered resolution and equality reasoning. As a step towards verifying modern provers, we specify, using Isabelle/HOL, a purely functional ordered resolution prover and establish its soundness and refutational completeness. Methodologically, we apply stepwise refinement to obtain, from an abstract specification of a nondeterministic prover, a verified deterministic program, written in a subset of Isabelle/HOL from which we extract purely functional Standard ML code that constitutes a semidecision procedure for first-order logic.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Anders</first_name>
          <last_name>Schlichtkrull</last_name>
          <affiliation>Technical University of Denmark</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.compute.dtu.dk/andschl/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jasmin Christian</first_name>
          <last_name>Blanchette</last_name>
          <affiliation>Vrije Universiteit Amsterdam</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.vu.nl/~jbe248/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/jasminblanchette/9e79875a-976b-43a7-9453-18e510e97ae7/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Dmitriy</first_name>
          <last_name>Traytel</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.inf.ethz.ch/trayteld/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/dmitriytraytel/8bbd70fd-409d-4088-bce0-24fa055cf5c4/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a7a9f299-ee7b-4edc-a1cf-3c1085fe6e6e</slot_id>
      <title>Formalizing the Metatheory of Logical Calculi and Automatic Provers in Isabelle/HOL</title>
      <room>Hotel Cascais Miragem | Sala XII</room>
      <date>2019/01/15</date>
      <start_time>09:00</start_time>
      <end_time>10:00</end_time>
      <description>IsaFoL (Isabelle Formalization of Logic) is an undertaking that aims at developing formal theories about logics, proof systems, and automatic provers, using Isabelle/HOL. At the heart of the project is the conviction that proof assistants have become mature enough to actually help researchers in automated reasoning when they develop new calculi and tools. In this paper, I describe and reflect on three verification subprojects to which I contributed: a first-order resolution prover, an imperative SAT solver, and generalized term or- ders for λ-free higher-order logic.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jasmin Christian</first_name>
          <last_name>Blanchette</last_name>
          <affiliation>Vrije Universiteit Amsterdam</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.vu.nl/~jbe248/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/jasminblanchette/9e79875a-976b-43a7-9453-18e510e97ae7/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>91da86fa-d878-40b5-aa4c-43e43794a43c</subevent_id>
    <title>PEPM: Session 3</title>
    <timeslot>
      <slot_id>227b40bc-451d-4409-b0f5-4c8ab3308802</slot_id>
      <title>Session: PEPM - Session 3</title>
      <room>Hotel Cascais Miragem | Sala X</room>
      <date>2019/01/14</date>
      <start_time>16:00</start_time>
      <end_time>17:30</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Atsushi</first_name>
          <last_name>Igarashi</last_name>
          <affiliation>Kyoto University, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fos.kuis.kyoto-u.ac.jp/~igarashi/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/atsushiigarashi/bbac1695-343a-4091-b33c-b7f01dea73da/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>PEPM 2019</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala X</room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/pepm-2019-papers</url>
    <url_link_display>PEPM 2019</url_link_display>
    <tracks>
      <track>PEPM 2019</track>
    </tracks>
    <timeslot>
      <slot_id>84e7ad6f-d622-4006-a08e-2f0273001a0e</slot_id>
      <title>What is the type of a partial evaluator? (Invited Talk)</title>
      <room>Hotel Cascais Miragem | Sala X</room>
      <date>2019/01/14</date>
      <start_time>16:00</start_time>
      <end_time>17:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>invited speaker</role>
          <sort_key>1</sort_key>
          <first_name>Jens</first_name>
          <last_name>Palsberg</last_name>
          <affiliation>University of California, Los Angeles (UCLA)</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ucla.edu/~palsberg</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/jenspalsberg/9e470c6a-532d-472c-9fea-253b7fa22c7c/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>PEPM 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bdd9c512-2e3f-43b3-b576-aa4353c64660</slot_id>
      <title>Combining Higher-Order Model Checking with Refinement Type Inference</title>
      <room>Hotel Cascais Miragem | Sala X</room>
      <date>2019/01/14</date>
      <start_time>17:00</start_time>
      <end_time>17:30</end_time>
      <description>There have been two major approaches to fully automated verification of higher-order functional programs: higher-order model checking and refinement type inference. The former approach is precise, but suffers from a bottleneck in the predicate discovery phase. The latter approach is generally faster than the former, thanks to the recent advances in constrained Horn clause (CHC) solving, but is imprecise, in that it rejects some valid programs. To take the best of the two approaches, we refine the higher-order model checking approach, by employing CHC solving in the predicate discovery phase. We have implemented the new approach and confirmed that the new system can verify more programs than those based on the previous two approaches.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ryosuke</first_name>
          <last_name>Sato</last_name>
          <affiliation>Kyushu University, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://posl.ait.kyushu-u.ac.jp/~sato/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Naoki</first_name>
          <last_name>Iwayama</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Naoki</first_name>
          <last_name>Kobayashi</last_name>
          <affiliation>University of Tokyo, Japan</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>PEPM 2019</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>98fdc48e-2d3d-411b-b710-7c640a51f828</subevent_id>
    <title>PADL: PADL Session 2</title>
    <timeslot>
      <slot_id>16734461-2b4c-4d3b-ab73-537eaa53f59b</slot_id>
      <title>Session: PADL - PADL Session 2</title>
      <room>Hotel Cascais Miragem | Sala IV</room>
      <date>2019/01/14</date>
      <start_time>16:00</start_time>
      <end_time>17:30</end_time>
      <tracks>
        <track>PADL 2019 - 21st International Symposium on Practical Aspects of Declarative Languages</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala IV</room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/PADL-2019</url>
    <url_link_display>PADL 2019 - 21st International Symposium on Practical Aspects of Declarative Languages</url_link_display>
    <tracks>
      <track>PADL 2019 - 21st International Symposium on Practical Aspects of Declarative Languages</track>
    </tracks>
    <timeslot>
      <slot_id>319edfbf-955e-4814-81d5-27f234401c0d</slot_id>
      <title>Classes of Arbitrary Kind</title>
      <room>Hotel Cascais Miragem | Sala IV</room>
      <date>2019/01/14</date>
      <start_time>17:00</start_time>
      <end_time>17:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alejandro</first_name>
          <last_name>Serrano</last_name>
          <affiliation>Utrecht University, Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.uu.nl/staff/mena.html</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/alejandroserrano/c5a07b2e-70da-4956-a386-442651bfcabb/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Victor Cacciari</first_name>
          <last_name>Miraldo</last_name>
          <affiliation>Utrecht University, Netherlands</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://victorcmiraldo.github.io</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>PADL 2019 - 21st International Symposium on Practical Aspects of Declarative Languages</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5b74ae11-4632-4962-98b9-4c59d0e31853</slot_id>
      <title>Faster Coroutine Pipelines: A Reconstruction</title>
      <room>Hotel Cascais Miragem | Sala IV</room>
      <date>2019/01/14</date>
      <start_time>16:00</start_time>
      <end_time>16:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ruben P.</first_name>
          <last_name>Pieters</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tom</first_name>
          <last_name>Schrijvers</last_name>
          <affiliation>KU Leuven</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.kuleuven.be/~tom.schrijvers</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/tomschrijvers/dd5db9f4-87bc-4ff3-a091-a5c076b925fb/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>PADL 2019 - 21st International Symposium on Practical Aspects of Declarative Languages</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fcd551ea-091b-40cf-ae4b-33022da2cb56</slot_id>
      <title>Distributed Protocol Combinators</title>
      <room>Hotel Cascais Miragem | Sala IV</room>
      <date>2019/01/14</date>
      <start_time>16:30</start_time>
      <end_time>17:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kristoffer</first_name>
          <last_name>Just Arndal Andersen</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>Currently visiting PPLV at University College London.</bio>
          <homepage_url>http://cs.au.dk/~kja</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/kristofferjustandersen/b4b424d6-bdee-48ae-90af-cb25145d9b99/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ilya</first_name>
          <last_name>Sergey</last_name>
          <affiliation>Yale-NUS College</affiliation>
          <bio>I am a tenure-track Associate Professor at Yale-NUS College and NUS School of Computing (Singapore). 
Prior to joining Yale-NUS, I was a faculty at University College London. Before then, I was a postdoctoral researcher at IMDEA Software Institute (Madrid, Spain). I defended my PhD in 2012 in the DistriNet research group at the Department of Computer Sciences of KU Leuven (Belgium). Before that I received my MSc degree in Mathematics and Computer Science from Saint Petersburg State University (Russia) in 2008. 
My research interests dwell in the area of the design and implementation of programming languages, including but not limited to program semantics, certified programming, concurrency and abstract interpretation. I am particularly interested in developing verification techniques and static analyses for higher-order and concurrent programs.</bio>
          <homepage_url>http://ilyasergey.net</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/ilyasergey/b2941c89-4843-4194-852a-81c8a30814fa/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>PADL 2019 - 21st International Symposium on Practical Aspects of Declarative Languages</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>fc6d79b1-c8e2-4f52-be33-aa24a467cf60</subevent_id>
    <title>CPP: Keynote 1 and Research Paper</title>
    <timeslot>
      <slot_id>6486251f-b56c-4280-add4-6e8cb662e1e9</slot_id>
      <title>Session: CPP - Keynote 1 and Research Paper</title>
      <room>Hotel Cascais Miragem | Sala XII</room>
      <date>2019/01/14</date>
      <start_time>09:00</start_time>
      <end_time>10:30</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Magnus O.</first_name>
          <last_name>Myreen</last_name>
          <affiliation>Chalmers University of Technology, Sweden</affiliation>
          <bio>I did a B.A. in Computer Science at the University of Oxford, tutored by Dr Jeff Sanders. 
I completed my Ph.D. on program verification in 2009 at the University of Cambridge, supervised by Prof. Mike Gordon. My PhD dissertation was selected as the winner of the BCS Distinguished Dissertation Competition 2010. 
In 2012, I became a Royal Society Research Fellow, UK. 
In 2014, I moved to Chalmers where I became a tenured Associate Professor in 2015.</bio>
          <homepage_url>http://www.cse.chalmers.se/~myreen/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/magnusomyreen/ccd5e9cd-2811-4ef2-a9f0-3dd7802233ca/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala XII</room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/CPP-2019</url>
    <url_link_display>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</url_link_display>
    <tracks>
      <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
    </tracks>
    <timeslot>
      <slot_id>2fa5cf3a-d69f-4d51-a3fd-00ff144df1b1</slot_id>
      <title>Certified Undecidability of Intuitionistic Linear Logic via Binary Stack Machines and Minsky Machines</title>
      <room>Hotel Cascais Miragem | Sala XII</room>
      <date>2019/01/14</date>
      <start_time>10:00</start_time>
      <end_time>10:30</end_time>
      <description>We formally prove the undecidability of entailment in intuitionistic linear logic in Coq. We reduce the Post correspondence problem (PCP) via binary stack machines and Minsky machines to intuitionistic linear logic. The reductions rely on several technically involved formalisations, amongst them a binary stack machine simulator for PCP, a verified low-level compiler for instruction-based languages and a soundness proof for intuitionistic linear logic with respect to trivial phase semantics. We exploit the computability of all functions definable in constructive type theory and thus do not have to rely on a concrete model of computation, enabling the reduction proofs to focus on correctness properties.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yannick</first_name>
          <last_name>Forster</last_name>
          <affiliation>Saarland University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.ps.uni-saarland.de/~forster/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/yannickforster/6dd381ff-83b3-4144-8470-8bc786421ca4/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dominique</first_name>
          <last_name>Larchey-Wendling</last_name>
          <affiliation>CNRS, LORIA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.loria.fr/~larchey</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/dominiquelarcheywendling/26e28786-60c1-45eb-a3d4-76573b2c0bfb/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>de2dc9d3-53e4-43fa-9f5c-09ae796aa64a</slot_id>
      <title>A Linear Logical Framework in Hybrid</title>
      <room>Hotel Cascais Miragem | Sala XII</room>
      <date>2019/01/14</date>
      <start_time>09:00</start_time>
      <end_time>10:00</end_time>
      <description>We present a linear logical framework implemented within the Hybrid system. Hybrid is designed to support the use of higher-order abstract syntax for representing and reasoning about formal systems, implemented in the Coq Proof Assistant. In this work, we extend the system with a linear specification logic, which provides infrastructure for reasoning directly about object languages with linear features. We developed this framework in order to address the chal- lenges of reasoning about the type system of a quantum lambda calculus. In particular, we started by considering the Proto-Quipper language, which contains the core of Quipper. Quipper is a new quantum programming lan- guage under active development with a linear type system. We have completed a formal proof of type soundness for Proto-Quipper. Our current work includes extending this work to other properties of Proto-Quipper as well as reason- ing about other quantum programming languages. It also includes reasoning about other object languages with linear features in areas such as meta-theory of low-level abstract machine code, proof theory of focused linear sequent calculi, and modeling biological processes as transition systems and proving properties about them.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Amy</first_name>
          <last_name>Felty</last_name>
          <affiliation>University of Ottawa</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.eecs.uottawa.ca/~afelty/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/amyfelty/e92f5ff9-e908-41d4-8d04-cfe5c6c984fe/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e6f0eb74-b027-4445-ae7b-d45091cdb83f</subevent_id>
    <title>PEPM: Session 6</title>
    <timeslot>
      <slot_id>05afd264-0afc-4735-90ec-6e9f6c00b9d8</slot_id>
      <title>Session: PEPM - Session 6</title>
      <room>Hotel Cascais Miragem | Sala X</room>
      <date>2019/01/15</date>
      <start_time>16:00</start_time>
      <end_time>17:30</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Hermenegildo</last_name>
          <affiliation>IMDEA Software Institute and T.U. of Madrid (UPM)</affiliation>
          <bio>Manuel Hermenegildo is a Full Professor and (Founding) Scientific Director of the IMDEA Software Institute. He is also a full Prof. of Computer Science at the Tech. U. of Madrid, UPM. Previously he held an Endowed Chair in Information Science and Technology at the U. of New Mexico. He was also project leader at the MCC research center and Adjunct Assoc. Prof. at the CS Department of the U. of Texas, both in Austin, Texas. See his home page for more information. 
Research interests: Energy-Aware Computing, Resource / non-functional property analysis, verification, and control; Global Program Analysis, Optimization, Verification, Debugging; Abstract Interpretation; Partial Evaluation; Parallelism and Parallelizing Compilers; Constraint/Logic/Functional Programming Theory and Implementation, Abstract Machines; Automatic Documentation Tools, Execution Visualization; Sequential and Parallel Computer Architecture.</bio>
          <homepage_url>http://cliplab.org/herme</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/manuelhermengildo/8eef27e4-befd-4c22-b6c8-20207eb80fd4/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>PEPM 2019</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala X</room>
    <date>2019/01/15</date>
    <url>https://popl19.sigplan.org/track/pepm-2019-papers</url>
    <url_link_display>PEPM 2019</url_link_display>
    <tracks>
      <track>PEPM 2019</track>
    </tracks>
    <timeslot>
      <slot_id>1800d87c-f276-40fe-ae34-980d42c06e48</slot_id>
      <title>PEPM Poster Session</title>
      <room>Hotel Cascais Miragem | Sala X</room>
      <date>2019/01/15</date>
      <start_time>16:00</start_time>
      <end_time>17:30</end_time>
      <description>undefined</description>
      <tracks>
        <track>PEPM 2019</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>191963fa-6990-4ab0-8c88-2571ebe88257</subevent_id>
    <title>PEPM: Session 4</title>
    <timeslot>
      <slot_id>fcc8fad0-1ad7-4b51-a539-0b2189287d1c</slot_id>
      <title>Session: PEPM - Session 4</title>
      <room>Hotel Cascais Miragem | Sala X</room>
      <date>2019/01/15</date>
      <start_time>11:00</start_time>
      <end_time>12:30</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Roberto</first_name>
          <last_name>Giacobazzi</last_name>
          <affiliation>University of Verona and IMDEA Software Institute</affiliation>
          <bio>Roberto Giacobazzi received the Laurea degree in Computer Science in 1988 from the University of Pisa, and in 1993 he received the Ph.D. in Computer Science from the same university, with a Ph.D. thesis on Semantic aspects of logic program analysis, under the supervision of Prof. Giorgio Levi. From 1993 to 1995 he had a Post Doctoral Research position at Laboratoire d’Informatique (LIX), Ecole Polytechnique (Paris) in the equipe Cousot. From 1995 to 1998 he was (tenured) Assistant Professor in Computer Science at the University of Pisa. From May 2000 until now he is Full Professor in Computer Science at the University of Verona. The research interests of Roberto Giacobazzi include abstract interpretation, static program analysis, semantics of programming languages, program verification, abstract model-checking, program transformation and optimization, digital asset protection, code obfuscation, malware detection, software watermarking, computability and lattice theory. He has been Program Chair of SAS, VMCAI, of workshops in programming languages and language based security, and General Chair of ACM POPL2013. From 2006 to 2012 he has been Dean of the College of Science of the University of Verona. He works at the University of Verona and at IMDEA Software Institute.</bio>
          <homepage_url>http://profs.sci.univr.it/~giaco/index.html</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/robertogiacobazzi/3a292abe-6f69-4d5d-bfa3-305417b39cba/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>PEPM 2019</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala X</room>
    <date>2019/01/15</date>
    <url>https://popl19.sigplan.org/track/pepm-2019-papers</url>
    <url_link_display>PEPM 2019</url_link_display>
    <tracks>
      <track>PEPM 2019</track>
    </tracks>
    <timeslot>
      <slot_id>f8e2efe8-155f-4621-b70a-71b97baee018</slot_id>
      <title>Making proofs easy: Horn clause transformations to the aid of program verification (Invited Talk)</title>
      <room>Hotel Cascais Miragem | Sala X</room>
      <date>2019/01/15</date>
      <start_time>11:00</start_time>
      <end_time>12:00</end_time>
      <description>Constrained Horn Clauses (CHCs) provide a suitable logical formalism for addressing a wide range of program verification problems. For this reason, a lot of effort has been recently devoted to the development of sophisticated solvers for checking the satisfiability of CHCs on various constraint theories (e.g., Linear Integer or Real Arithmetic, arrays, bitvectors, inductively defined data types). However, the effectiveness of solvers often depends on how the verification problem is encoded into clausal form, and suitable pre-processing techniques can significantly simplify the search for a satisfiability proof. In this talk we present recent and ongoing research on transformation techniques for CHCs that can be used to ease satisfiability proofs, and hence program verification. We follow a very general approach based on transformation rules such as unfolding, folding, and constraint rewriting. These rules are combined together in more complex transformation strategies, such as CHC specialization and predicate tupling. We demonstrate the usefulness of these transformations for various program verification tasks, such as proving partial correctness with respect to pre/post-conditions and proving relational properties (e.g., equivalence and non-interference). We also show that the approach based on CHC transformation is, to a large extent, language agnostic, by considering verification problems for programs written in various programming languages.</description>
      <persons>
        <person>
          <role>invited speaker</role>
          <sort_key>1</sort_key>
          <first_name>Maurizio</first_name>
          <last_name>Proietti</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.iasi.cnr.it/~proietti/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>PEPM 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fbf25526-ca4a-452c-aed8-937adf98d521</slot_id>
      <title>Control Flow Obfuscation via CPS Transformation</title>
      <room>Hotel Cascais Miragem | Sala X</room>
      <date>2019/01/15</date>
      <start_time>12:00</start_time>
      <end_time>12:30</end_time>
      <description>Control flow obfuscation protects software from being reverse-engineered by altering the control flow transfer without without changing the software's run-time semantics. We propose a new control flow obfuscation technique by rewriting the source program in the continuation passing style (CPS). The continuation is encoded through higher order combinators and function pointers at the target language level. As a result, the original control flow graph is fragmented which makes any software tampering attempt through binary static analysis hard. We implemented a prototype which performs obfuscation on C source codes. The benchmark shows that this approach is practical compared to existing techniques.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kenny Zhuo Ming</first_name>
          <last_name>Lu</last_name>
          <affiliation>Nanyang Polytechnic, Singapore</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>PEPM 2019</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>accc1328-ae93-48af-907b-7872f086214c</subevent_id>
    <title>OPCT: CAUSALITY, REVERSIBILITY</title>
    <timeslot>
      <slot_id>c16d1c90-9f79-403d-be62-e428005e0d1a</slot_id>
      <title>Session: OPCT - CAUSALITY, REVERSIBILITY</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/14</date>
      <start_time>11:15</start_time>
      <end_time>12:30</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Thomas</first_name>
          <last_name>H. Hildebrandt</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VII   </room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/opct-2019-papers</url>
    <url_link_display>OPCT 2019</url_link_display>
    <tracks>
      <track>OPCT 2019</track>
    </tracks>
    <timeslot>
      <slot_id>0ddbaae9-8d21-4dcc-b8a4-9448d8448992</slot_id>
      <title>A Calculus of Branching Processes</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/14</date>
      <start_time>11:40</start_time>
      <end_time>12:05</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jean</first_name>
          <last_name>Krivine</last_name>
          <affiliation>CNRS</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.irif.fr/~jkrivine/homepage/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/jeankrivine/05622389-69f2-43b0-8623-9c313575aaeb/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>162e4405-2498-4f2e-9e88-2fddd0942176</slot_id>
      <title>Causal Reasoning for Safety</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/14</date>
      <start_time>11:15</start_time>
      <end_time>11:40</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Georgiana</first_name>
          <last_name>Caltais</last_name>
          <affiliation>University of Konstanz</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.sen.uni-konstanz.de/members/research-staff/dr-georgiana-caltais/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/georgianacaltais/f4e1ab61-6a05-4356-8082-6220aa2b6fa2/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>73bac475-dc54-4dab-9571-a05fc70cad00</slot_id>
      <title>An axiomatic approach to reversible computation</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/14</date>
      <start_time>12:05</start_time>
      <end_time>12:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Irek</first_name>
          <last_name>Ulidowski</last_name>
          <affiliation>University of Leicester</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cs.le.ac.uk/people/iu3/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>bf9a9f23-4775-4440-9020-1f4b33b76cbc</subevent_id>
    <title>PADL: PADL Session 5</title>
    <timeslot>
      <slot_id>96bd407d-7690-494d-bffe-3d6fd286d2cf</slot_id>
      <title>Session: PADL - PADL Session 5</title>
      <room>Hotel Cascais Miragem | Sala IV</room>
      <date>2019/01/15</date>
      <start_time>14:00</start_time>
      <end_time>15:30</end_time>
      <tracks>
        <track>PADL 2019 - 21st International Symposium on Practical Aspects of Declarative Languages</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala IV</room>
    <date>2019/01/15</date>
    <url>https://popl19.sigplan.org/track/PADL-2019</url>
    <url_link_display>PADL 2019 - 21st International Symposium on Practical Aspects of Declarative Languages</url_link_display>
    <tracks>
      <track>PADL 2019 - 21st International Symposium on Practical Aspects of Declarative Languages</track>
    </tracks>
    <timeslot>
      <slot_id>5287d5c4-e7c7-4989-b98c-9e4507b82ad4</slot_id>
      <title>Proof Carrying Plans</title>
      <room>Hotel Cascais Miragem | Sala IV</room>
      <date>2019/01/15</date>
      <start_time>14:30</start_time>
      <end_time>15:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Christopher</first_name>
          <last_name>Schwaab</last_name>
          <affiliation>University of St Andrews</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ekaterina</first_name>
          <last_name>Komendantskaya</last_name>
          <affiliation>Heriot-Watt University, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.macs.hw.ac.uk/~ek19/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/ekaterinakomendantskaya/672a7ccf-8545-4e52-85a8-78540eebdd4e/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Alasdair</first_name>
          <last_name>Hill</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Frantisek</first_name>
          <last_name>Farka</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ron</first_name>
          <last_name>Petrick</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Joe</first_name>
          <last_name>Wells</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Kevin</first_name>
          <last_name>Hammond</last_name>
          <affiliation>University of St. Andrews, UK</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>PADL 2019 - 21st International Symposium on Practical Aspects of Declarative Languages</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c4c83348-98fb-4c09-b5df-3fa42f5d6067</slot_id>
      <title>A Combinatorial Testing Framework for Intuitionistic Propositional Theorem Provers</title>
      <room>Hotel Cascais Miragem | Sala IV</room>
      <date>2019/01/15</date>
      <start_time>15:00</start_time>
      <end_time>15:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Paul</first_name>
          <last_name>Tarau</last_name>
          <affiliation>University of North Texas</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.unt.edu/~tarau/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/paultarau/79013cf3-bf98-4bbd-aaec-7f4bdc977f08/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>PADL 2019 - 21st International Symposium on Practical Aspects of Declarative Languages</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d9264cc8-f260-4e9a-ad68-b83829e4219a</slot_id>
      <title>Composing Syntactical Constructs to Create Domain-Specific Languages</title>
      <room>Hotel Cascais Miragem | Sala IV</room>
      <date>2019/01/15</date>
      <start_time>14:00</start_time>
      <end_time>14:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Viktor</first_name>
          <last_name>Palmkvist</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>David</first_name>
          <last_name>Broman</last_name>
          <affiliation>KTH Royal Institute of Technology</affiliation>
          <bio>David Broman is an Associate Professor at the KTH Royal Institute of Technology in Sweden, where he is leading the Model-based Computing Systems (MCS) research group. Between 2012 and 2014, he was a visiting scholar at the University of California, Berkeley, where he also was employed as a part time researcher until 2016. David received his Ph.D. in Computer Science in 2010 from Linköping University, Sweden, and was appointed Assistant Professor there in 2011. He earned a Docent degree in Computer Science in 2015. His research focuses on model-based design of time-aware systems, including cyber-physical systems, embedded systems, and real-time systems. In particular, he is interested in modeling language theory, formal semantics, compilers, and machine learning. In 2017, he was awarded the individual grant for future leaders (FFL 6) from the Swedish Foundation for Strategic Research (SSF). David has worked several years within the software industry, co-founded the EOOLT workshop series, and is a member of IFIP WG 2.4, Modelica Association, and the TAACCS steering committee.</bio>
          <homepage_url>https://people.kth.se/~dbro/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/davidbroman/dcc9932a-010a-4ca4-952d-af2114e4dc76/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>PADL 2019 - 21st International Symposium on Practical Aspects of Declarative Languages</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>098847cd-749b-4367-bb79-ce4b86098524</subevent_id>
    <title>PADL: PADL Session 1</title>
    <timeslot>
      <slot_id>a610795c-3e65-441b-98c7-30af6d17209d</slot_id>
      <title>Session: PADL - PADL Session 1</title>
      <room>Hotel Cascais Miragem | Sala IV</room>
      <date>2019/01/14</date>
      <start_time>14:00</start_time>
      <end_time>15:30</end_time>
      <tracks>
        <track>PADL 2019 - 21st International Symposium on Practical Aspects of Declarative Languages</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala IV</room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/PADL-2019</url>
    <url_link_display>PADL 2019 - 21st International Symposium on Practical Aspects of Declarative Languages</url_link_display>
    <tracks>
      <track>PADL 2019 - 21st International Symposium on Practical Aspects of Declarative Languages</track>
    </tracks>
    <timeslot>
      <slot_id>05f031d2-c765-4bf7-9075-1502d8c12556</slot_id>
      <title>Incremental Evaluation of Lattice-Based Aggregates in Logic Programming Using Modular TCLP</title>
      <room>Hotel Cascais Miragem | Sala IV</room>
      <date>2019/01/14</date>
      <start_time>14:30</start_time>
      <end_time>15:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Joaquin</first_name>
          <last_name>Arias</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Manuel</first_name>
          <last_name>Carro</last_name>
          <affiliation>IMDEA Software Institute and T.U. of Madrid (UPM)</affiliation>
          <bio>Manuel Carro received his Bachelor degree in Computer Science from the Technical University of Madrid (UPM), and his PhD degree from the same University in 2003. He is currently Associate Research Professor and Director at the IMDEA Software Institute, and an Associate Professor at the Technical University of Madrid. He has previously been representative of UPM at the NESSI and INES technological platforms, and is now representative of UPM at SpaRCIM and deputy representative of IMDEA Software at ERCIM and Informatics Europe. He has published over 80 papers in international conferences and journals, and received best paper awards at ICLP 2005 and ICSOC 2011. He has been organizer and PC member of many international conferences and workshops, and participated in research projects at the regional, national, and European level. He was UPM’s principal investigator for the S-Cube European Network of Excellence and is currently the principal investigator of a European, a national, and a regional research project. He has completed the supervision of three PhD thesis and is actively supervising another one. 
His interests span several topics, including the design and implementation of high-level (logic- and constraint-based) programming languages, answer-set programming, the analysis of service-based systems, the use of program transformation techniques for compilation on hybrid architectures, and the effective usage of formal specifications in the process of teaching programming. He has long been interested in parallel programming and parallel implementations of declarative languages, and visualization of program execution.</bio>
          <homepage_url>http://www.clip.dia.fi.upm.es/~mcarro</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/manuelcarro/f90cc86f-6f5d-4ecb-9229-0a84d5b5168e/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>PADL 2019 - 21st International Symposium on Practical Aspects of Declarative Languages</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2ed4a49c-c3a0-4ef3-b241-48c7f8e633bc</slot_id>
      <title>Improving Residuation in Declarative Programs</title>
      <room>Hotel Cascais Miragem | Sala IV</room>
      <date>2019/01/14</date>
      <start_time>15:00</start_time>
      <end_time>15:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Hanus</last_name>
          <affiliation>Kiel University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.informatik.uni-kiel.de/~mh/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/michaelhanus/927da22f-64f0-4cdc-8d40-509351cd6462/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>PADL 2019 - 21st International Symposium on Practical Aspects of Declarative Languages</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7b995f39-de30-4bf5-b436-f4da95bb2caa</slot_id>
      <title>Natural Language Generation From Ontologies</title>
      <room>Hotel Cascais Miragem | Sala IV</room>
      <date>2019/01/14</date>
      <start_time>14:00</start_time>
      <end_time>14:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Van</first_name>
          <last_name>Nguyen</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tran Cao</first_name>
          <last_name>Son</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Enrico</first_name>
          <last_name>Pontelli</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>PADL 2019 - 21st International Symposium on Practical Aspects of Declarative Languages</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f8f48aa8-ed0a-4709-9e47-6621ab399b85</subevent_id>
    <title>CPP: Research Papers: Rewriting, Automated Reasoning</title>
    <timeslot>
      <slot_id>c2931d00-1af7-4ace-8866-da1b68e73ec0</slot_id>
      <title>Session: CPP - Research Papers: Rewriting, Automated Reasoning</title>
      <room>Hotel Cascais Miragem | Sala XII</room>
      <date>2019/01/15</date>
      <start_time>11:00</start_time>
      <end_time>12:30</end_time>
      <tracks>
        <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala XII</room>
    <date>2019/01/15</date>
    <url>https://popl19.sigplan.org/track/CPP-2019</url>
    <url_link_display>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</url_link_display>
    <tracks>
      <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
    </tracks>
    <timeslot>
      <slot_id>1419a608-81ad-4327-961e-6a3010108391</slot_id>
      <title>Certified ACKBO</title>
      <room>Hotel Cascais Miragem | Sala XII</room>
      <date>2019/01/15</date>
      <start_time>11:30</start_time>
      <end_time>12:00</end_time>
      <description>Term rewriting in the presence of associative and commutative function symbols constitutes a highly expressive model of computation, which is for example well-suited to reason about parallel computations. However, it is well-known that the standard notion of termination does not apply any more: any term rewrite system containing a commutativity rule is nonterminating. Thus, instead of adding AC-rules to a rewrite system and trying to prove termination, we switch to the notion of AC-termination. AC-termination can for example be shown using well-founded AC-compatible reduction orders. One specific example of such an order is ACKBO. We present our Isabelle/HOL formalization of the ACKBO order. On an abstract level this gives us a mechanized proof of the fact that ACKBO is indeed an AC-compatible reduction order. Moreover, we integrated corresponding check functions into the verified certifier CeTA. This has the more practical consequence of enabling the machine certification of AC-termination proofs generated by automated termination tools.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alexander</first_name>
          <last_name>Lochmann</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Christian</first_name>
          <last_name>Sternagel</last_name>
          <affiliation>University of Innsbruck, Austria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cl-informatik.uibk.ac.at/~griff</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/christiansternagel/447d2a33-d54a-40b3-ae4e-ebb4d2700d7a/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>47ba3eb4-9b82-4d31-9ff1-8008178c4875</slot_id>
      <title>A Verified Ground Confluence Tool for Linear Variable-Separated Rewrite Systems in Isabelle/HOL</title>
      <room>Hotel Cascais Miragem | Sala XII</room>
      <date>2019/01/15</date>
      <start_time>12:00</start_time>
      <end_time>12:30</end_time>
      <description>It is well known that (ground) confluence is a decidable property of ground term rewrite systems, and that this extends to larger classes. Here we present a formally verified ground confluence checker for linear, variable-separated rewrite systems. To this end, we formalize procedures for ground tree transducers and so-called RR_n relations. The ground confluence checker is an important milestone on the way to formalizing the decidability of the first-order theory of ground rewriting for linear, variable-separated rewrite systems. It forms the basis for a formalized confluence checker for left-linear, right-ground systems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Bertram</first_name>
          <last_name>Felgenhauer</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>aart</first_name>
          <last_name>Middeldorp</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Turaga</first_name>
          <last_name>Prathamesh</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Franziska</first_name>
          <last_name>Rapp</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>50caed79-10cf-4f4c-94a2-de58d0f62270</slot_id>
      <title>Autosubst 2: Reasoning with Multi-Sorted de Bruijn Terms and Vector Substitutions</title>
      <room>Hotel Cascais Miragem | Sala XII</room>
      <date>2019/01/15</date>
      <start_time>11:00</start_time>
      <end_time>11:30</end_time>
      <description>Formalising metatheory in the Coq proof assistant is tedious as native support for reasoning with binders requires a lot of uninteresting technicalities. To relieve users from so-produced boilerplate, the Autosubst framework automates working with de Bruijn terms: For each annotated inductive type, Autosubst generates a corresponding instantiation operation for parallel substitutions and a decision procedure for assumption-free substitution lemmas. However, Autosubst is implemented in Ltac, Coq’s tactic language, and thus suffers from Ltac’s limitations. In particular, Autosubst is restricted to Coq and unscoped, non-mutual inductive types with a single sort of variables. In this paper, we present a new version of Autosubst that overcomes these restrictions. Autosubst 2 is an external code generator, which translates second-order HOAS specifications into potentially mutual inductive term sorts. We extend the equational theory of Autosubst to the case of mutual inductive sorts by combining the application of multiple parallel substitutions into exactly one instantiation operation for each sort, i.e. we parallelise substitutions to vector substitutions. The resulting equational theory is both simpler and more expressive than that of the original Autosubst framework and allows us to present an even more elegant proof for the POPLMark challenge.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kathrin</first_name>
          <last_name>Stark</last_name>
          <affiliation>Saarland University, Germany</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Steven</first_name>
          <last_name>Schäfer</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/stevenschafer/ca198129-c83e-48bb-a5e0-07c1cea127f9/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jonas</first_name>
          <last_name>Kaiser</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>CPP 2019 - The 8th ACM SIGPLAN International Conference on Certified Programs and Proofs, January 14-15 2019</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f3712056-ece3-49c9-8074-ac9076bd30e1</subevent_id>
    <title>OPCT: SESSION TYPES </title>
    <timeslot>
      <slot_id>0fa85d8d-e87e-4de6-9f37-cdeee6ff5264</slot_id>
      <title>Session: OPCT - SESSION TYPES </title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/14</date>
      <start_time>09:00</start_time>
      <end_time>10:30</end_time>
      <persons>
        <person>
          <role>Session Chair</role>
          <sort_key>1</sort_key>
          <first_name>Ilaria</first_name>
          <last_name>Castellani</last_name>
          <affiliation>INRIA Sophia Antipolis, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www-sop.inria.fr/members/Ilaria.Castellani/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/ilariacastellani/47b6f877-6713-449c-8974-610a9bfd2cf1/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VII   </room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/opct-2019-papers</url>
    <url_link_display>OPCT 2019</url_link_display>
    <tracks>
      <track>OPCT 2019</track>
    </tracks>
    <timeslot>
      <slot_id>1d2506d0-e01e-46d0-bc80-60f6c3d01bc6</slot_id>
      <title>Opening</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/14</date>
      <start_time>09:00</start_time>
      <end_time>09:15</end_time>
      <description>undefined</description>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>53d76cd5-dfe7-4d85-a146-b52d98666b15</slot_id>
      <title>A Foundation for Runtime Enforcement</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/14</date>
      <start_time>09:40</start_time>
      <end_time>10:05</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Adrian</first_name>
          <last_name>Francalanza</last_name>
          <affiliation>University of Malta</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://staff.um.edu.mt/afra1/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/adrianfrancalanza/6e6d0dd9-c580-4596-abde-30e3716ea961/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>90fb5981-70b9-4e1d-a86b-6e2bc1b7abce</slot_id>
      <title>A concurrent functional language with session types and control effects based on linear logic</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/14</date>
      <start_time>09:15</start_time>
      <end_time>09:40</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Luís</first_name>
          <last_name>Caires</last_name>
          <affiliation>NOVA-LINCS, FCT NOVA / Universidade Nova de Lisboa</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ctp.di.fct.unl.pt/~lcaires/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/luiscaires/019ae02e-ff01-4b8f-93eb-356665812a5d/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bfeaf324-92f5-47f8-829c-cec003866c72</slot_id>
      <title>Processes as names?</title>
      <room>Hotel Cascais Miragem | Sala VII   </room>
      <date>2019/01/14</date>
      <start_time>10:05</start_time>
      <end_time>10:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hans</first_name>
          <last_name>Hüttel</last_name>
          <affiliation>Department of Computer Science, Aalborg University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.cs.aau.dk/~hans</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>OPCT 2019</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>5530f704-16e1-40c6-bac4-b8483b381cf3</subevent_id>
    <title>VMCAI: Invited Talk 1</title>
    <timeslot>
      <slot_id>c9cafe9f-a30b-44ad-8306-93a979345d60</slot_id>
      <title>Session: VMCAI - Invited Talk 1</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/13</date>
      <start_time>09:00</start_time>
      <end_time>10:30</end_time>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala III</room>
    <date>2019/01/13</date>
    <url>https://popl19.sigplan.org/track/VMCAI-2019</url>
    <url_link_display>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</url_link_display>
    <tracks>
      <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
    </tracks>
    <timeslot>
      <slot_id>deb26e8c-0bf4-4ae8-b593-0cb44b422c33</slot_id>
      <title>Under and Over Approximated Reachability Analysis for the Verifcation of Control Systems</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/13</date>
      <start_time>09:00</start_time>
      <end_time>10:30</end_time>
      <description>This talk will present a class of methods to compute under and over approximating flowpipes for differential systems, possibly with delays, systems that are pervasive in the modeling networked control systems. Computing over-approximations of the reachable states has become a classical tool for the safety verification of control systems. Under-approximations are notoriously more difficult to compute, and their use for verification much less studied. We will discuss the guarantees and properties that can be obtained from the joint use of these under and over-approximations for control systems with inputs and disturbances.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Sylvie</first_name>
          <last_name>Putot</last_name>
          <affiliation>École Polytechnique</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.lix.polytechnique.fr/Labo/Sylvie.Putot/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e9551674-1442-4203-9973-fb02e7b03e1a</subevent_id>
    <title>VMCAI: Software Verification</title>
    <timeslot>
      <slot_id>13ec081c-91da-4243-b5cf-9e62891192de</slot_id>
      <title>Session: VMCAI - Software Verification</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/15</date>
      <start_time>14:00</start_time>
      <end_time>15:30</end_time>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala III</room>
    <date>2019/01/15</date>
    <url>https://popl19.sigplan.org/track/VMCAI-2019</url>
    <url_link_display>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</url_link_display>
    <tracks>
      <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
    </tracks>
    <timeslot>
      <slot_id>1481ec6a-f084-4e0a-8fac-0c4cbd4a9a61</slot_id>
      <title>Type-directed Bounding of Collections in Reactive Programs</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/15</date>
      <start_time>14:00</start_time>
      <end_time>14:30</end_time>
      <description>Our aim is to statically verify that in a given reactive program, the length of collection variables does not grow beyond a given bound. We propose a scalable type-based technique that checks that each collection variable has a given refinement type that specifies constraints about its length. A novel feature of our refinement types is that the refinements can refer to AST counters that track how many times an AST node has been executed. This feature enables type refinements to track limited flow-sensitive information. We generate verification conditions that ensure that the AST counters are used consistently, and that the types imply the given bound. The verification conditions are discharged by an off-the-shelf SMT solver. Experimental results demonstrate that our technique is scalable, and effective at verifying reactive programs with respect to requirements on length of collections.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tianhan</first_name>
          <last_name>Lu</last_name>
          <affiliation>University of Colorado Boulder</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Pavol</first_name>
          <last_name>Cerny</last_name>
          <affiliation>University of Colorado Boulder</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ecee.colorado.edu/pavol/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/pavolcerny/3137d160-e201-47a8-a4c2-9e2a461d204e/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Bor-Yuh Evan</first_name>
          <last_name>Chang</last_name>
          <affiliation>University of Colorado Boulder</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.colorado.edu/~bec/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/boryuhevanchang/0cbe7e94-aaf8-458b-9670-3892350bc209/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ashutosh</first_name>
          <last_name>Trivedi</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>47d89056-01c4-4349-976c-a6664bae718f</slot_id>
      <title>Small Faults Grow Up - Verification of Error Masking Robustness in Arithmetically Encoded Programs</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/15</date>
      <start_time>15:00</start_time>
      <end_time>15:30</end_time>
      <description>The increasing prevalence of soft errors and security concerns due to recent attacks like rowhammer have caused increased interest in the robustness of software against bit flips. 
Arithmetic codes can be used as a protection mechanism to detect small errors injected in the program’s data. However, the accumulation of propagated errrors can increase the number of bits flips in a variable - possibly up to an undetectable level. 
The effect of error masking can occur: An error weight exceeds the limitations of the code and a new, valid, but incorrect code word is formed. Masked errors are undetectable, and it is crucial to check variables for bit flips before error masking can occur. 
In this paper, we develop a theory of provably robust arithmetic programs. We focus on the interaction of bit flips that can happen at different locations in the program and the propagation and possible masking of errors. We show how this interaction can be formally modeled and how off-the-shelf model checkers can be used to show correctness. We evaluate our approach based on prominent and security relevant algorithms and show that even multiple faults injected at any time into any variables can be handled by our method.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Anja</first_name>
          <last_name>Karl</last_name>
          <affiliation>Institute of Applied Information Processing and Communications, Graz University of Technology</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/anjakarl/b84710c0-b101-4f08-8f46-cb7c77a13250/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Robert</first_name>
          <last_name>Schilling</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Roderick</first_name>
          <last_name>Bloem</last_name>
          <affiliation>Institute of Software Technology, Graz University of Technology	</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/roderickbloemen/809a821f-ab45-4738-98c8-e3a6f1246776/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Stefan</first_name>
          <last_name>Mangard</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e92440b6-d605-4596-9f3b-38fcc012d715</slot_id>
      <title>Exploiting Pointer Analysis in Memory Models for Deductive Verification</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/15</date>
      <start_time>14:30</start_time>
      <end_time>15:00</end_time>
      <description>Cooperation between verification methods is crucial to tackle the challenging problem of software verification. The paper focuses on the verification of C programs using pointers and it formalizes a cooperation between static analyzers doing pointer analysis and a deductive verification tool based on first order logic. We propose a framework based on memory models that captures the partitioning of memory inferred by pointer analyses, and complies with the memory models used to generate verification conditions. The framework guided us to propose a pointer analysis that accommodates to various low-level operations on pointers while providing precise information about memory partitioning to the deductive verification. We implemented this cooperation inside the Frama-C platform and we show its effectiveness in reducing the task of deductive verification on a complex case study.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Quentin</first_name>
          <last_name>Bouillaguet</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>François</first_name>
          <last_name>Bobot</last_name>
          <affiliation>CEA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/francoisbobot/c6483650-f718-485a-bf58-bf7dc0285bf1/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Mihaela</first_name>
          <last_name>Sighireanu</last_name>
          <affiliation>IRIF, University Paris Diderot and CNRS, France</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Boris</first_name>
          <last_name>Yakobowski</last_name>
          <affiliation>CEA - LIST</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.yakobowski.org/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>cd58b559-8973-4e9a-85a7-af071233fd9c</subevent_id>
    <title>VMCAI: Software  Verification and Synthesis</title>
    <timeslot>
      <slot_id>ca21d561-66e8-4d5a-a38e-d35f09f860c6</slot_id>
      <title>Session: VMCAI - Software  Verification and Synthesis</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/15</date>
      <start_time>11:00</start_time>
      <end_time>12:30</end_time>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala III</room>
    <date>2019/01/15</date>
    <url>https://popl19.sigplan.org/track/VMCAI-2019</url>
    <url_link_display>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</url_link_display>
    <tracks>
      <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
    </tracks>
    <timeslot>
      <slot_id>3475dca7-85a8-41f4-97ce-7348f026c60e</slot_id>
      <title>Program Synthesis with Equivalence Reduction</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/15</date>
      <start_time>12:00</start_time>
      <end_time>12:30</end_time>
      <description>We introduce program synthesis with equivalence reduction, a synthesis methodology that utilizes relational specifications over components of a given synthesis domain to reduce the search space. Leveraging a blend of classic and modern techniques from term rewriting, we use relational specifications to discover a canonical representative per equivalence class of programs. We show how to design synthesis procedures that only consider programs in normal form, thus pruning the search space. We discuss how to implement equivalence reduction using efficient data structures, and demonstrate the significant reductions it can achieve in synthesis time.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Calvin</first_name>
          <last_name>Smith</last_name>
          <affiliation>University of Wisconsin - Madison</affiliation>
          <bio>5th-year graduate student at UW-Madison.</bio>
          <homepage_url>http://pages.cs.wisc.edu/~cjsmith/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/calvinsmith/8ae2632c-ffa7-46b2-8e30-67769165ea83/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Aws</first_name>
          <last_name>Albarghouthi</last_name>
          <affiliation>University of Wisconsin-Madison</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/awsalbarghouthi/3a3382aa-47f5-4e02-ac71-509eb94703ff/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4bdb352f-c1e2-45bf-bdd7-f5156a5ef454</slot_id>
      <title>euforia: Complete Software Model Checking with Uninterpreted Functions</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/15</date>
      <start_time>11:30</start_time>
      <end_time>12:00</end_time>
      <description>We introduce and evaluate a novel algorithm for an \iccc{}-style checker that operates entirely at the level of equality with uninterpreted functions (EUF). Our checker, called \euforia{}, targets control properties by treating a program’s data operations/relations as uninterpreted functions/predicates. This results in an EUF abstract transition system that \euforia{} analyzes to either (1) discover an inductive strengthening EUF formula that proves the property or (2) produce an abstract counterexample that corresponds to zero, one, or many concrete counterexamples. Infeasible counterexamples are eliminated by an efficient refinement method that constrains the EUF abstraction until the property is proved or a feasible counterexample is produced. We formalize the EUF transition system, prove our algorithm correct, and demonstrate our results on a subset of benchmarks from the software verification competition (SV-COMP) 2017.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Denis</first_name>
          <last_name>Bueno</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Karem A.</first_name>
          <last_name>Sakallah</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d66cb925-a1b8-4ebe-a1cd-ca01f8e5641e</slot_id>
      <title>Mechanically Proving Determinacy of Hierarchical Block Diagram Translations</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/15</date>
      <start_time>11:00</start_time>
      <end_time>11:30</end_time>
      <description>Hierarchical block diagrams (HBDs) are at the heart of embedded system design tools, including Simulink. Numerous translations exist from HBDs into languages with formal semantics, amenable to formal verification. However, none of these translations has been proven correct, to our knowledge. 
We present in this paper the first mechanically proven HBD translation algorithm. The algorithm translates HBDs into an algebra of terms with three basic composition operations (serial, parallel, and feedback). In order to capture various translation strategies resulting in different terms achieving different tradeoffs, the algorithm is nondeterministic. Despite this, we prove its {\em semantic determinacy}: for every input HBD, all possible terms that can be generated by the algorithm are semantically equivalent. We apply this result to show how three Simulink translation strategies introduced previously can be formalized as determinizations of the algorithm, and derive that these strategies yield semantically equivalent results (a question left open in previous work). All results are formalized and proved in the Isabelle theorem-prover and the code is publicly available.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Viorel</first_name>
          <last_name>Preoteasa</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Iulia</first_name>
          <last_name>Dragomir</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Stavros</first_name>
          <last_name>Tripakis</last_name>
          <affiliation>Aalto University and UC Berkeley</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.eecs.berkeley.edu/~stavros/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/stavrostripakis/3f20654e-4d72-4949-9d56-572d9c914625/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7b767436-93d0-4797-b4d8-dc1d29800df8</subevent_id>
    <title>VMCAI: Probabilistic Systems</title>
    <timeslot>
      <slot_id>080013c0-26e1-4079-8e30-89ac0d998965</slot_id>
      <title>Session: VMCAI - Probabilistic Systems</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/14</date>
      <start_time>14:00</start_time>
      <end_time>15:30</end_time>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala III</room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/VMCAI-2019</url>
    <url_link_display>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</url_link_display>
    <tracks>
      <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
    </tracks>
    <timeslot>
      <slot_id>1329c00a-1ae4-4931-83b2-9ad8de193af1</slot_id>
      <title>Combining Refinement of Parametric Models with Goal-Oriented Reduction of Dynamics</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/14</date>
      <start_time>15:00</start_time>
      <end_time>15:30</end_time>
      <description>Parametric models abstract part of the specification of dynamical models by integral parameters. They are for example used in computational systems biology, notably with parametric regulatory networks, which specify the global architecture (interactions) of the networks, while parameterising the precise rules for drawing the possible temporal evolutions of the states of the components. A key challenge is then to identify the discrete parameters corresponding to concrete models with desired dynamical properties. 
This paper addresses the restriction of the abstract execution of parametric regulatory (discrete) networks by the means of static analysis of reachability properties (goal states). Initially defined at the level of concrete parameterised models, the goal-oriented reduction of dynamics is lifted to parametric networks, and is proven to preserve all the minimal traces to the specified goal states. It results that one can jointly perform the refinement of parametric networks (restriction of domain of parameters) while reducing the necessary transitions to explore and preserving reachability properties of interest.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Stefan</first_name>
          <last_name>Haar</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Juraj</first_name>
          <last_name>Kolčák</last_name>
          <affiliation>LSV, CNRS &amp; ENS Cachan, University Paris Saclay</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://lsv.fr/~kolcak</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Loïc</first_name>
          <last_name>Paulevé</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>1caca213-1607-4dee-98a7-fbb5e9265a70</slot_id>
      <title>Syntactic Partial Order Compression for Probabilistic Reachability</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/14</date>
      <start_time>14:00</start_time>
      <end_time>14:30</end_time>
      <description>The state space explosion problem is among the largest impediments to the performance of any model checker. Modelling languages for compositional systems contribute to this problem by placing each instruction of an instruction sequence onto a dedicated transition, giving concurrent processes opportunities to interleave after every instruction. Users wishing to avoid the excessive number of interleavings caused by this default can choose to explicitly declare instruction sequences as atomic, which however requires careful considerations regarding the impact this might have on the model as well as on the properties that are to be checked. We instead propose a preprocessing technique that automatically identifies instruction sequences that can safely be considered atomic. This is done in the context of concurrent variable-decorated Markov Decision Processes. Our approach is compatible with any off-the-shelf probabilistic model checker. We prove that our transformation preserves maximal reachability probabilities and present case studies to illustrate its usefulness.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gereon</first_name>
          <last_name>Fox</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://depend.cs.uni-saarland.de/~fox/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Stan</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Holger</first_name>
          <last_name>Hermanns</last_name>
          <affiliation>Saarland University</affiliation>
          <bio>Holger Hermanns is a full professor in computer science at Saarland University in Germany, heading the Dependable Systems and Software group. From April 2004 to March 2006, Holger Hermanns has served as Dean of Studies of the Faculty of Mathematics and Computer Science, and has served as its Dean from April 2010 to March 2012. Afterwards he did his best to serve as Dean of Hearts. Holger Hermanns is elected member of Academia Europaea. In 2016 he got awarded an ERC Advanced Grant.</bio>
          <homepage_url>https://depend.cs.uni-saarland.de/~hermanns/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/holgerhermanns/68e5edaa-7aa8-4baf-a62f-9bfce2054e99/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>85ab24ef-56aa-4323-9ff4-e41326f73e06</slot_id>
      <title>Termination of Nondeterministic Probabilistic Programs</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/14</date>
      <start_time>14:30</start_time>
      <end_time>15:00</end_time>
      <description>We study the termination problem for nondeterministic probabilistic programs. We consider the bounded termination problem that asks whether the supremum of the expected termination time over all schedulers is bounded. First, we show that ranking supermartingales (RSMs) are both sound and complete for proving bounded termination over nondeterministic probabilistic programs. For nondeterministic probabilistic programs a previous result claimed that RSMs are not complete for bounded termination, whereas our result corrects the previous flaw and establishes completeness with a rigorous proof. Second, we present the first sound approach to establish lower bounds on expected termination time through RSMs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Hongfei</first_name>
          <last_name>Fu</last_name>
          <affiliation>IST Austria</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Krishnendu</first_name>
          <last_name>Chatterjee</last_name>
          <affiliation>IST Austria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pub.ist.ac.at/~kchatterjee/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>dc2087e4-9a0f-44a0-b198-0e93a88d2334</subevent_id>
    <title>VMCAI: Invited Talk 3</title>
    <timeslot>
      <slot_id>7ff3133a-4553-44c1-a893-aab084b56583</slot_id>
      <title>Session: VMCAI - Invited Talk 3</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/15</date>
      <start_time>09:00</start_time>
      <end_time>10:30</end_time>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala III</room>
    <date>2019/01/15</date>
    <url>https://popl19.sigplan.org/track/VMCAI-2019</url>
    <url_link_display>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</url_link_display>
    <tracks>
      <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
    </tracks>
    <timeslot>
      <slot_id>b5e1e0da-27c6-4668-9d3f-9f499570e218</slot_id>
      <title>Semantics for Compiler IRs: Undefined Behavior is not Evil!</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/15</date>
      <start_time>09:00</start_time>
      <end_time>10:30</end_time>
      <description>Building a compiler IR is tricky. First, it should be efficient to compile the desired source language to this IR. Second, the IR should support all the desired optimizations and analyses, and these should run efficiently. Finally, it should be possible to lower this IR into the desired target assembly efficiently. Striking a good tradeoff in this design space isn’t easy. 
Undefined behavior (UB) has been used in production compilers’ IRs for a long time. In this talk, we will explore what’s UB, what it achieves, why it may be a good idea, and why it is not as evil as most people think it is.</description>
      <persons>
        <person>
          <role>invited speaker</role>
          <sort_key>1</sort_key>
          <first_name>Nuno P.</first_name>
          <last_name>Lopes</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.ist.utl.pt/nuno.lopes/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/nunoplopes/51903af2-1afa-498e-95d4-72829128f32c/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2124501f-ddcc-44ea-a9e7-790a13b1ffb2</subevent_id>
    <title>VMCAI: Abstract interpretation (1)</title>
    <timeslot>
      <slot_id>c38436e9-8fb3-4c11-a531-ad439281ff54</slot_id>
      <title>Session: VMCAI - Abstract interpretation (1)</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/13</date>
      <start_time>11:00</start_time>
      <end_time>12:30</end_time>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala III</room>
    <date>2019/01/13</date>
    <url>https://popl19.sigplan.org/track/VMCAI-2019</url>
    <url_link_display>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</url_link_display>
    <tracks>
      <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
    </tracks>
    <timeslot>
      <slot_id>0834677f-9746-4579-b391-14b717dc3bd1</slot_id>
      <title>Disjunctive Relational Abstract Interpretation for Interprocedural Program Analysis</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/13</date>
      <start_time>11:30</start_time>
      <end_time>12:00</end_time>
      <description>Program analysis by abstract interpretation using relational abstract domains — like polyhedra or octagons — easily extends from state analysis (construction of reachable states) to relational analysis (construction of input-output relations). In this paper, we exploit this extension to enable interprocedural program analysis, by constructing relational summaries of procedures. In order to improve the accuracy of procedure summaries, we propose a method to refine them into disjunctions of relations, these disjunctions being directed by preconditions on input parameters.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Rémy</first_name>
          <last_name>Boutonnet</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nicolas</first_name>
          <last_name>Halbwachs</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>87f458f8-d630-4039-b4c9-2317e38e450c</slot_id>
      <title>Static Analysis Of Binary Code With Memory Indirections Using Polyhedra</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/13</date>
      <start_time>11:00</start_time>
      <end_time>11:30</end_time>
      <description>In this paper we propose a new abstract domain for static analysis of binary code. Our motivation stems from the need to improve the precision of the estimation of the Worst-Case Execution Time (WCET) of safety-critical real-time code. WCET estimation requires computing information such as upper bounds on the number of loop iterations, unfeasible execution paths, etc. These estimations are usually performed on binary code, mainly to avoid making assumptions on how the compiler works. Our abstract domain, based on polyhedra and on two mapping functions that associate polyhedra variables with registers and memory, targets the precise computation of such information. We prove the correctness of the method, and demonstrate its effectiveness on benchmarks and examples from typical embedded code.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Clément</first_name>
          <last_name>Ballabriga</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Julien</first_name>
          <last_name>Forget</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Laure</first_name>
          <last_name>Gonnord</last_name>
          <affiliation>University of Lyon &amp; LIP, France</affiliation>
          <bio>Laure Gonnord received her PhD degree in computer science from the University Joseph Fourier (Grenoble, France), in 2007. She currently holds an assistant professor position at University Lyon I/UCBL, France. Her main research interests lie in the design of static analyses, with emphasis on the automatic synthesis of numerical invariants and application in compilation (scheduling) and termination proofs. She belongs to the ROMA team of the LIP laboratory (ENS Lyon).</bio>
          <homepage_url>http://laure.gonnord.org/pro</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/lauregonnord/6b741986-7933-4cba-9205-8e5e8451d8fa/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Giuseppe</first_name>
          <last_name>Lipari</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Jordy</first_name>
          <last_name>Ruiz</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a8801de8-7b2c-4a33-8793-0ec62f3c4e9a</slot_id>
      <title>Application of Abstract Interpretation to the Automotive Electronic Control System</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/13</date>
      <start_time>12:00</start_time>
      <end_time>12:30</end_time>
      <description>The verification and validation of industrial automotive systems is increasingly challenging as they become larger and more complex. Recent automotive Electric Control Units (ECUs) have approximately one half to one million of lines of code, and a modern automobile can contain hundreds of controllers. Significant work-hours are needed to understand and manage systems of this level of complexity. One particular challenge is understanding the changes to the software across development phases and revisions. To this end, we present a code dependency analysis tool that enhances designer understanding. It combines abstract interpretation and graph based data analysis to generate visualized dependency graphs on demand to support designer’s understanding of the code. We demonstrate its value by presenting dependency graph visuals for an industrial application, and report results showing significant reduction of work-hours and enhancement of the ability to understand the software.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tomoya</first_name>
          <last_name>Yamaguchi</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Martin</first_name>
          <last_name>Brain</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Chris</first_name>
          <last_name>Ryder</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Yosikazu</first_name>
          <last_name>Imai</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Yoshiumi</first_name>
          <last_name>Kawamura</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1170cf47-5316-4c23-9c94-2bc3e63b1d58</subevent_id>
    <title>VMCAI: Invited Talk 2</title>
    <timeslot>
      <slot_id>bfe00d6a-9ccb-444b-ae0d-dbca5cf8f2bc</slot_id>
      <title>Session: VMCAI - Invited Talk 2</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/14</date>
      <start_time>09:00</start_time>
      <end_time>10:30</end_time>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala III</room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/VMCAI-2019</url>
    <url_link_display>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</url_link_display>
    <tracks>
      <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
    </tracks>
    <timeslot>
      <slot_id>84a821d1-497b-4127-9edd-e1a63427a800</slot_id>
      <title>Designing Self-Certifying Software Systems</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/14</date>
      <start_time>09:00</start_time>
      <end_time>10:30</end_time>
      <description>Large software systems are hard to understand. The size and complexity of the implementation, possibly written in a mix of programming languages; a large number of potential configurations; concurrency and distribution, all contribute to the difficulty of precisely analyzing system behavior. How can one have confidence in the correct working of such a complex system? 
In this talk, I will explore an unusual approach to this challenge. Suppose that the software system is designed so that it produces a mathematical certificate to justify the correctness of its result. The behavior of such a “self-certifying” system can then be formally verified at run time, by checking the validity of each certificate as it is generated, without having to examine or reason directly about the system implementation. Self-certification thus shrinks the size of the trusted computing base, often by orders of magnitude, as only the certificate checker must be trusted. 
The central research question is to design a certificate format which is comprehensive, easy to generate, and straightforward to check. I will sketch how this may be done for a variety of software system types: model checkers and static analyzers, network operating systems, and optimizing compilers. I will also discuss intriguing open questions and talk about some of the unexpected benefits of certification.</description>
      <persons>
        <person>
          <role>invited speaker</role>
          <sort_key>1</sort_key>
          <first_name>Kedar</first_name>
          <last_name>Namjoshi</last_name>
          <affiliation>Bell Labs, Nokia</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0c1a82fe-e9b1-442a-80b3-3a0c200d629d</subevent_id>
    <title>VMCAI: Model Checking</title>
    <timeslot>
      <slot_id>1559716e-3c30-4aa0-9946-eec705fd244c</slot_id>
      <title>Session: VMCAI - Model Checking</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/14</date>
      <start_time>16:00</start_time>
      <end_time>17:30</end_time>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala III</room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/VMCAI-2019</url>
    <url_link_display>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</url_link_display>
    <tracks>
      <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
    </tracks>
    <timeslot>
      <slot_id>0d41190f-6592-4cf9-a6eb-7dc7d427f37a</slot_id>
      <title>A Parallel Relation-Based Algorithm for Symbolic Bisimulation Minimization</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/14</date>
      <start_time>17:00</start_time>
      <end_time>17:30</end_time>
      <description>Symbolic computation using BDDs and bisimulation minimization are alternative ways to cope with the state space explosion in model checking. The combination of both techniques opens up many parameters that can be tweaked for further optimization. Most importantly, the bisimulation can either be represented as equivalence classes or as a relation. While recent work argues that storing partitions is more efficient, we show that the relation-based approach is preferable. We do so by deriving a relation-based minimization algorithm based on new coarse-grained BDD operations. The implementation demonstrates that the relational approach uses fewer memory and performs better.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alfons</first_name>
          <last_name>Laarman</last_name>
          <affiliation>Leiden University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/alfonslaarman/badc8cc1-6b6a-4cf4-bf17-452815e3d8c6/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Richard</first_name>
          <last_name>Huybers</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ba6a6728-afc7-4d8f-96d5-db9690efce0f</slot_id>
      <title>Parametric Timed Broadcast Protocols</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/14</date>
      <start_time>16:00</start_time>
      <end_time>16:30</end_time>
      <description>In this paper we consider state reachability in networks composed of many identical processes running a parametric timed broadcast protocol (PTBP). PTBP are a new model extending both broadcast protocols and parametric timed automata. This work is, up to our knowledge, the first to consider the combination of both a parametric network size and timing parameters in clock guard constraints. Since the communication topology is of utmost importance in broadcast protocols, we investigate reachability problems in both clique semantics where every message reaches every processes, and in reconfigurable semantics where the set of receivers is chosen non-deterministically. In addition, we investigate the decidability status depending on whether the timing parameters in guards appear only as upper bounds in guards (U-PTBP), as lower bounds or when the set of parameters is partitioned in lower-bound and upper-bound parameters (L/U-PTBP).</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Étienne</first_name>
          <last_name>André</last_name>
          <affiliation>LIPN, CNRS UMR 7030, Université Paris 13</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://lipn.univ-paris13.fr/~andre/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/etienneandre/cc098139-5c90-4720-bdb2-1d4dbea073a0/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Benoit</first_name>
          <last_name>Delahaye</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Paulin</first_name>
          <last_name>Fournier</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Didier</first_name>
          <last_name>Lime</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cf63f024-e1a7-4c46-86e0-1bc4f316c479</slot_id>
      <title>Flat Model Checking for Counting LTL using Quantifier-free Presburger Arithmetic</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/14</date>
      <start_time>16:30</start_time>
      <end_time>17:00</end_time>
      <description>This paper presents an approximation approach to verifying counter systems with respect to properties formulated in an expressive counting extension of linear temporal logic. It can express, e.g., that the number of acknowledgements never exceeds the number of requests to a service, by counting specific positions along a run and imposing arithmetic constraints. The addressed problem is undecidable and therefore solved on flat under-approximations of a system. This provides a flexibly adjustable trade-off between exhaustiveness and computational effort, similar to bounded model checking. Recent techniques and results for model-checking frequency properties over flat Kripke structures are lifted and employed to construct a parametrised encoding of the (approximated) problem in quantifier-free Presburger arithmetic. A prototype implementation based on the z3 SMT solver demonstrates the effectiveness of the approach based on problems from the RERS Challange.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Normann</first_name>
          <last_name>Decker</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Anton</first_name>
          <last_name>Pirogov</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a2709d72-dc57-4ec2-9b82-c073b207eb1a</subevent_id>
    <title>VMCAI: Abstract Interpretation (2)</title>
    <timeslot>
      <slot_id>eda432dc-e56e-4875-a410-b0eae01b621e</slot_id>
      <title>Session: VMCAI - Abstract Interpretation (2)</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/13</date>
      <start_time>16:00</start_time>
      <end_time>17:30</end_time>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala III</room>
    <date>2019/01/13</date>
    <url>https://popl19.sigplan.org/track/VMCAI-2019</url>
    <url_link_display>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</url_link_display>
    <tracks>
      <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
    </tracks>
    <timeslot>
      <slot_id>681ebde3-be92-43d8-ad11-9452e55684c0</slot_id>
      <title>Relatively Complete Pushdown Analysis of Escape Continuations</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/13</date>
      <start_time>16:30</start_time>
      <end_time>17:00</end_time>
      <description>Escape continuations are weaker than full, first-class continuations but nevertheless can express many common control operators. Although language and compiler designs profitably leverage escape continuations, all previous approaches to analyze them statically in a higher-order setting have been ad hoc or imprecise. We present MCCFA2, a generalization of CFA2 that analyzes them with pushdown precision in their most-general form. In particular, the summarization algorithm of MCCFA2 is both sound and complete with respect to a conservative extension of CFA2’s abstract semantics. We also sketch an integration into our framework of Vardoulakis and Shivers’ technique to handle first-class continuations that offers the full precision of MCCFA2 to uses of them as mere escape continuations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kimball</first_name>
          <last_name>Germane</last_name>
          <affiliation>University of Utah</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Might</last_name>
          <affiliation>University of Alabama at Birmingham | Harvard Medical School</affiliation>
          <bio>Professor of Internal Medicine and Computer Science, UAB 
Hugh Kaul Endowed Chair in Personalized Medicine 
Director, Hugh Kaul Precision Medicine Institute 
Senior Lecturer, Harvard Medical School</bio>
          <homepage_url>http://matt.might.net/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/matthewmight/ec69937a-3cff-49b4-aedb-73494c1181ac/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b4d3c8cf-a597-49ed-895a-51a7b7440313</slot_id>
      <title>Demand Control-Flow Analysis</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/13</date>
      <start_time>16:00</start_time>
      <end_time>16:30</end_time>
      <description>Points-to analysis manifests in a functional setting as control-flow analysis. Despite the ubiquity of demand points-to analyses, there are no analogous demand control-flow analyses for functional languages in general. We present demand 0CFA, a demand control-flow analysis that offers clients in a functional setting the same pricing model that demand points-to analysis clients enjoy in an imperative setting. We establish demand 0CFA’s correctness via an intermediary exact semantics, demand evaluation, that can potentially support demand variants of more-precise analyses.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kimball</first_name>
          <last_name>Germane</last_name>
          <affiliation>University of Utah</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jay</first_name>
          <last_name>McCarthy</last_name>
          <affiliation>University of Massachusetts Lowell</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Michael D.</first_name>
          <last_name>Adams</last_name>
          <affiliation>University of Utah</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://michaeldadams.org</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/michaeldadams/08a0803f-e67b-46c4-8276-b66598925879/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Might</last_name>
          <affiliation>University of Alabama at Birmingham | Harvard Medical School</affiliation>
          <bio>Professor of Internal Medicine and Computer Science, UAB 
Hugh Kaul Endowed Chair in Personalized Medicine 
Director, Hugh Kaul Precision Medicine Institute 
Senior Lecturer, Harvard Medical School</bio>
          <homepage_url>http://matt.might.net/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/matthewmight/ec69937a-3cff-49b4-aedb-73494c1181ac/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c0465375-0302-439a-aeac-0464fabed8d4</slot_id>
      <title>Effect-driven Flow Analysis</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/13</date>
      <start_time>17:00</start_time>
      <end_time>17:30</end_time>
      <description>Traditional machine-based static analyses use a worklist algorithm to explore the analysis state space, and compare each state in the worklist against a set of seen states as part of their fixed-point computation. This may require many state comparisons, which gives rise to a computational overhead. Even an analysis with a global store has to clear its set of seen states each time the store updates because of allocation or side-effects, which results in more states being reanalyzed and compared. 
In this work we present a static analysis technique, ModF, that does not rely on a set of seen states, and apply it to a machine-based analysis with global-store widening. ModF analyzes one function execution at a time to completion while tracking read, write, and call effects. These effects trigger the analysis of other function executions, and the analysis terminates when no new effects can be discovered. 
We compared ModF to a traditional machine-based analysis implementation on a set of 20 benchmark programs and found that ModF is faster for 17 programs with speedups ranging between 1.4x and 12.3x. Furthermore, ModF exhibits similar precision as the traditional analysis and yields state graphs that are comparable in size.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jens</first_name>
          <last_name>Nicolay</last_name>
          <affiliation>Vrije Universiteit Brussel, Belgium</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://soft.vub.ac.be/~jnicolay/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/jensnicolay/307f2d75-b933-43f4-ae6c-1cb9a2db8e92/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Quentin</first_name>
          <last_name>Stiévenart</last_name>
          <affiliation>Vrije Universiteit Brussel, Belgium</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://soft.vub.ac.be/~qstieven</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/quentinstievenart/7d195a5f-4ea9-4d26-a55f-2b8d1c5853b8/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Wolfgang</first_name>
          <last_name>De Meuter</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://soft.vub.ac.be/soft/users/wdmeuter</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Coen</first_name>
          <last_name>De Roover</last_name>
          <affiliation>Vrije Universiteit Brussel</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://soft.vub.ac.be/~cderoove/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/coenderoover/ef3a26a6-56c3-420e-b1ce-b4a0e6cd653e/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>94b2fd12-a65b-400a-a1e8-0f8091a9d9d9</subevent_id>
    <title>VMCAI: Networks and Concurrency</title>
    <timeslot>
      <slot_id>8a937b64-0b62-49bd-a1ea-dde4c5bd0705</slot_id>
      <title>Session: VMCAI - Networks and Concurrency</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/15</date>
      <start_time>16:00</start_time>
      <end_time>17:30</end_time>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala III</room>
    <date>2019/01/15</date>
    <url>https://popl19.sigplan.org/track/VMCAI-2019</url>
    <url_link_display>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</url_link_display>
    <tracks>
      <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
    </tracks>
    <timeslot>
      <slot_id>1518119e-53d6-46fd-804b-3f241ed9d31c</slot_id>
      <title>Verification of an Industrial Asynchronous Leader Election Algorithm Using Abstractions and Parametric Model Checking</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/15</date>
      <start_time>17:00</start_time>
      <end_time>17:30</end_time>
      <description>The election of a leader in a network is a challenging task, especially when the processes are asynchronous, i.e., execute an algorithm with time-varying periods. Thales developed an industrial election algorithm with an arbitrary number of processes, that can possibly fail. In this work, we prove the correctness of a variant of this industrial algorithm. We use a method combining abstraction, an SMT solver, and a parametric timed model-checker. This allows us to prove the correctness of the algorithm for a large number p of processes (p=5000).</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Étienne</first_name>
          <last_name>André</last_name>
          <affiliation>LIPN, CNRS UMR 7030, Université Paris 13</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://lipn.univ-paris13.fr/~andre/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/etienneandre/cc098139-5c90-4720-bdb2-1d4dbea073a0/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Laurent</first_name>
          <last_name>Fribourg</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Romain</first_name>
          <last_name>Soulat</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jean-Marc</first_name>
          <last_name>Mota</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>37df11ee-7683-40c3-9f98-80eb03b976df</slot_id>
      <title>Fast BGP Simulation of Large Datacenters</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/15</date>
      <start_time>16:30</start_time>
      <end_time>17:00</end_time>
      <description>Frequent configuration churn caused by maintenance, upgrades, hardware and firmware failures regularly leads to costly outages. Preventing network outages caused by misconfigurations is important for ensuring high network availability. Dealing with production datacenters with thousands of routers is a major challenge. 
Network verification inspects the forwarding tables of routers. These tables are determined by the so-called control plane, which is given by the steady state of the routing protocols. The ability to simulate routing protocols given router configuration files and thus obtain the control plane is a key enabling technology. 
In this paper, we present FastPlane, an efficient BGP simulator. BGP support is mandated by modern datacenter designs, which choose BGP as the routing protocol. The key to FastPlane’s performance is our insight into the routing policy of cloud datacenters that allows the usage of a generalized Dijkstra’s algorithm. The insight reveals that these networks are monotonic, i.e., route advertisements decrease preference when propagated through the network. 
The evaluation on real world, production datacenters of a major cloud provider shows that FastPlane 1) is two orders of magnitude faster than the state-of-the-art on small and medium datacenters, and 2) goes beyond the state-of-the-art by scaling to large datacenters. FastPlane was instrumental in finding several production bugs in router firmware, routing policy, and network architecture.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nuno P.</first_name>
          <last_name>Lopes</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://web.ist.utl.pt/nuno.lopes/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/nunoplopes/51903af2-1afa-498e-95d4-72829128f32c/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andrey</first_name>
          <last_name>Rybalchenko</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://research.microsoft.com/en-us/people/rybal/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/andreyrybalchenko/6a82d181-045a-4268-b923-13bdd175f20a/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>444e2894-0b04-4049-8462-122b07575a4b</slot_id>
      <title>On the Semantics of Snapshot Isolation</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/15</date>
      <start_time>16:00</start_time>
      <end_time>16:30</end_time>
      <description>Snapshot isolation (SI) is a standard transactional consistency model used in databases, distributed systems and software transactional memory (STM). Its semantics is formally defined both declaratively as an acyclicity axiom, and operationally as a concurrent algorithm with memory bearing timestamps. 
We develop two simpler equivalent operational definitions of SI as lock-based reference implementations that do not use timestamps. Our first locking implementation is prescient in that requires a priori knowledge of the data accessed by a transaction and carries out transactional writes eagerly (in-place). Our second implementation is non-prescient and performs transactional writes lazily by recording them in a local log and propagating them to memory at commit time. Whilst our first implementation is simpler and may be better suited for developing a program logic for SI transactions, our second implementation is more practical due to its non-prescience. We show that both implementations are sound and complete against the declarative SI specification and thus yield equivalent operational definitions for SI. 
We further consider, for the first time formally, the use of SI in a context with racy non-transactional accesses, as can arise in STM implementations of SI. We introduce robust snapshot isolation (RSI), an adaptation of SI with similar semantics and guarantees in this mixed setting. We present a declarative specification of RSI as an acyclicity axiom and analogously develop two operational models as lock-based reference implementations (one eager, one lazy). We show that these operational models are both sound and complete against the declarative RSI model.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Azalea</first_name>
          <last_name>Raad</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.SoundAndComplete.org</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/azalearaad/180ee602-475f-483f-a01b-ea187c9e8ac1/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ori</first_name>
          <last_name>Lahav</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~orilahav/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/orilahav/89b656f6-7634-49d1-9917-4b74da70a976/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Viktor</first_name>
          <last_name>Vafeiadis</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>Viktor Vafeiadis is a tenured faculty at the Max Planck Institute for Software Systems (MPI-SWS) in Germany. He got his BA and PhD from the University of Cambridge, and held post-doctoral researcher positions at the University of Cambridge and at Microsoft Research Cambridge before joining MPI-SWS in October 2010.</bio>
          <homepage_url>http://www.mpi-sws.org/~viktor/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/viktorvafeiadis/6a063832-47ca-4c32-8047-4bf4f74ae764/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>e12a6361-5664-4099-950e-96d7c6c8c8d9</subevent_id>
    <title>VMCAI: Decision Procedures</title>
    <timeslot>
      <slot_id>4cddae30-5e10-4ff9-a75b-fc5e98d40274</slot_id>
      <title>Session: VMCAI - Decision Procedures</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/14</date>
      <start_time>11:00</start_time>
      <end_time>12:30</end_time>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala III</room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/VMCAI-2019</url>
    <url_link_display>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</url_link_display>
    <tracks>
      <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
    </tracks>
    <timeslot>
      <slot_id>0725c88b-dcee-4398-a42f-87f998911d6c</slot_id>
      <title>Solving and Interpolating Constant Arrays Based on Weak Equivalences</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/14</date>
      <start_time>11:00</start_time>
      <end_time>11:30</end_time>
      <description>We present a new solver and interpolation algorithm for the theory of arrays with constant arrays. It is based on our previous work on weakly equivalent arrays. Constant arrays store the same value at every index, which is useful for model checking of programs with initialised memory. Instead of using a store chain to explicitly initialise the memory, using a constant array can considerably simplify the queries and thus reduce the solving and interpolation time. We show that only a few new rules are required for constant arrays and prove the correctness of the decision procedure and the interpolation procedure. We implemented the algorithm in our interpolating solver SMTInterpol.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jochen</first_name>
          <last_name>Hoenicke</last_name>
          <affiliation>Universität Freiburg</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://swt.informatik.uni-freiburg.de/staff/hoenicke</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/jochenhoenicke/7e5249eb-9086-4f85-9082-2bd5e68b0c1f/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Tanja</first_name>
          <last_name>Schindler</last_name>
          <affiliation>University of Freiburg</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://swt.informatik.uni-freiburg.de/staff/schindler</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cf194118-3f66-4a37-a5d5-fccf5adb126a</slot_id>
      <title>A Decidable Logic for Tree Data-Structures with Measurements</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/14</date>
      <start_time>11:30</start_time>
      <end_time>12:00</end_time>
      <description>We present Dryad_dec, a decidable logic that allows reasoning about tree data-structures with measurements. This logic supports user-defined recursive measure functions based on Max or Sum, and recursive predicates based on these measure functions, such as AVL trees or red-black trees. We prove that the logic’s satisfiability is decidable. The crux of the decidability proof is a small model property which allows us to reduce the satisfiability of Dryad_dec to quantifier-free linear arithmetic theory which can be solved efficiently using SMT solvers. We also show that Dryad_dec can encode a variety of verification and synthesis problems, including natural proof verification conditions for functional correctness of recursive tree-manipulating programs, legality conditions for fusing tree traversals, synthesis conditions for conditional linear-integer arithmetic functions. We developed the decision procedure and successfully solved 220+ Dryad_dec formulae raised from these application scenarios, including verifying functional correctness of programs manipulating AVL trees, red-black trees and treaps, checking the fusibility of height-based mutually recursive tree traversals, and counterexample-guided synthesis from linear integer arithmetic specifications. To our knowledge, Dryad_dec is the first decidable logic that can solve such a wide variety of problems requiring flexible combination of measure-related, data-related and shape-related properties for trees.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xiaokang</first_name>
          <last_name>Qiu</last_name>
          <affiliation>Purdue University</affiliation>
          <bio>I am an assistant professor with the School of Electrical and Computer Engineering at Purdue University.</bio>
          <homepage_url>https://engineering.purdue.edu/~xqiu/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/xiaokangqiu/be55b21e-fb5d-4540-a2c2-1110cac11fc6/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Yanjun</first_name>
          <last_name>Wang</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ed1c7153-c140-4fd6-9fea-d2efa0a2e1e0</slot_id>
      <title>A Practical Algorithm for Structure Embedding</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/14</date>
      <start_time>12:00</start_time>
      <end_time>12:30</end_time>
      <description>This paper presents an algorithm for the structure embedding problem: given two finite first-order structures over a common relational vocabulary, does there exist an injective homomorphism from one to the other? The structure embedding problem is NP-complete in the general case, but for monadic structures (each predicate has arity &amp;lt;= 1) we observe that it can be solved in polytime by reduction to bipartite graph matching. Our algorithm, MatchEmbeds, extends the bipartite matching approach to the general case by using it as the foundation of a backtracking search procedure. We show that MatchEmbeds outperforms state-of-the-art SAT, CSP, and subgraph isomorphism solvers on difficult random instances and significantly improves the performance of a client model checker for multi-threaded programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Charlie</first_name>
          <last_name>Murphy</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>I am a Ph.D. candidate at Princeton University studying Computer Science. I received my BS in Computer Science from Ohio University’s Honors Tutorial College in 2016 and my MA in Computer Science from Princeton University in 2018. 
My primary research interests lie in Programming Languages, Automated Reasoning, and software verification with an emphasis on design and analysis of logics, solvers, and algorithms for automated or semi-automated reasoning of concurrent and distributed systems. Additionally, I have a broad interest in machine learning, artificial intelligence, and statistical inference and how it may be incorporated with more logical / sound reasoning principles.</bio>
          <homepage_url>http://www.cs.princeton.edu/~tcm3/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/timothymurphy/b5864712-ec87-424c-849c-ca084eebbe4f/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Zachary</first_name>
          <last_name>Kincaid</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.princeton.edu/~zkincaid</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/zacharykincaid/a26b486e-94a5-45f1-a8b3-9a2221495ff7/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>df6472ac-0712-4e2d-8547-a0924b4a895c</subevent_id>
    <title>VMCAI: Program Synthesis</title>
    <timeslot>
      <slot_id>3b5cec9b-a6cf-4977-8033-3d9c8a5ed225</slot_id>
      <title>Session: VMCAI - Program Synthesis</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/13</date>
      <start_time>14:00</start_time>
      <end_time>15:30</end_time>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala III</room>
    <date>2019/01/13</date>
    <url>https://popl19.sigplan.org/track/VMCAI-2019</url>
    <url_link_display>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</url_link_display>
    <tracks>
      <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
    </tracks>
    <timeslot>
      <slot_id>83609219-386b-442d-9f2a-adb504a695d4</slot_id>
      <title>Lazy but Effective Functional Synthesis</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/13</date>
      <start_time>14:30</start_time>
      <end_time>15:00</end_time>
      <description>We present a new technique for generating a function implementation from a declarative specification formulated as a Forall-Exists-formula in first-order logic. We follow a classic approach of eliminating existential quantifiers and extracting Skolem functions for the theory of linear arithmetic. Our method eliminates quantifiers lazily and produces a synthesis solution in the form of a decision tree. Compared to prior approaches, our decision trees have fewer nodes due to deriving theory terms that can be shared both within a single output as well as across multiple outputs. Our approach is implemented in a tool called AE-VAL, and its evaluation on a set of reactive synthesis benchmarks shows promise.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Grigory</first_name>
          <last_name>Fedyukovich</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.princeton.edu/~grigoryf/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/grigoryfedyukovich/902a9cea-9078-42f4-9fb4-19a433865738/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Arie</first_name>
          <last_name>Gurfinkel</last_name>
          <affiliation>University of Waterloo</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://ece.uwaterloo.ca/~agurfink</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/ariegurfinkel/afd05be2-69c7-40dd-990c-230fef4cacf9/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Aarti</first_name>
          <last_name>Gupta</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.princeton.edu/~aartig/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/aartigupta/7c2a5663-e856-45a9-a19f-37ac2e4cd0fc/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>df219d57-9dba-4094-ab00-f1d007dbb523</slot_id>
      <title>Minimal Synthesis of String To String Functions From Examples</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/13</date>
      <start_time>14:00</start_time>
      <end_time>14:30</end_time>
      <description>We study the problem of synthesizing string to string transformations from a set of input/output examples. The transformations we consider are expressed using deterministic finite automata (DFA) that read pairs of letters, one letter from the input and one from the output. The DFA corresponding to these transformations have additional constraints, ensuring that each input string is mapped to exactly one output string. 
We suggest that, given a set of input/output examples, the smallest DFA consistent with the examples is a good candidate for the transformation the user was expecting. We therefore study the problem of, given a set of examples, finding a minimal DFA consistent with the examples and satisfying the functionality and totality constraints mentioned above. 
We prove that, in general, this problem (the corresponding decision problem) is NP-complete. This is unlike the standard DFA minimization problem which can be solved in polynomial time. We provide several NP-hardness proofs that show the hardness of multiple (independent) variants of the problem. 
Finally, we propose an algorithm for finding the minimal DFA consistent with input/output examples, that uses a reduction to SMT solvers. We implemented the algorithm, and used it to evaluate the likelihood that the minimal DFA indeed corresponds to the DFA expected by the user.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jad</first_name>
          <last_name>Hamza</last_name>
          <affiliation>LIAFA, Université Paris Diderot</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Viktor</first_name>
          <last_name>Kuncak</last_name>
          <affiliation>EPFL, Switzerland</affiliation>
          <bio>Viktor Kuncak is an associate professor in the EPFL School of Computer and Communication Sciences, where he leads the Laboratory for Automated Reasoning and Analysis (http://lara.epfl.ch). He works in formal methods with emphasis on algorithms and tools, such as Leon (http://leon.epfl.ch). He received a PhD degree from the Massachusetts Institute of Technology (MIT) in 2007. He was a program co-chair of FMCAD 2014 and VMCAI 2012, and led an international COST Action to establish standardized formats for verification and synthesis (Rich Model Toolkit). His invited talks include those at LOPSTR, SYNT, ICALP, CSL, RV, VMCAI, and SMT. He received an ACM SIGSOFT distinguished paper award for work on automated testing. His work on software synthesis procedures was published in the Communications of the ACM as a Research Highlight article. His recent work on Implicit Programming, funded by a European Research Council (ERC) grant, aims to bridge the gap between human goals and their computational realizations.</bio>
          <homepage_url>http://lara.epfl.ch/~kuncak/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/viktorkuncak/78636806-30c9-45e6-8dc3-f26d91a04f02/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>eeec1aa0-5652-4823-9f5e-08cbb8e7fec8</slot_id>
      <title>Automatic Program Repair using Formal Verification and Expression Templates</title>
      <room>Hotel Cascais Miragem | Sala III</room>
      <date>2019/01/13</date>
      <start_time>15:00</start_time>
      <end_time>15:30</end_time>
      <description>We present an automated approach to repair programs using formal verification and expression templates. In our approach, an input program is first verified against its formal specification to discover potentially buggy statements. For each of these statements, we identify the expression that needs to be repaired and set up a template patch which is a linear expression composed of the program’s variables and unknown coefficients. Then, we analyze the template-patched program against its specification to collect a set of constraints of the template patch. This constraint set will be solved by a constraint solving technique using Farkas’ lemma to identify the unknown coefficients, consequently discovering the patch. We implement our approach in a tool called Maple and evaluate it with various buggy programs from a widely used benchmark TCAS as well as a synthetic, yet challenging benchmark containing recursive programs. Our tool outperforms state-of-the-art program repair tools in returning desired patches.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Thanh-Toan</first_name>
          <last_name>Nguyen</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Quang-Trung</first_name>
          <last_name>Ta</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Wei-Ngan</first_name>
          <last_name>Chin</last_name>
          <affiliation>National University of Singapore</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>VMCAI 2019 - 20th International Conference on Verification, Model Checking, and Abstract Interpretation</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>57cf0f4a-069f-4e99-9891-216294aee62c</subevent_id>
    <title>POPL TutorialFest: Linear and Graded Modal Types for Fine-Grained Program Reasoning I</title>
    <timeslot>
      <slot_id>d0d938c9-bb90-4863-8c1c-cc3f7d506e9b</slot_id>
      <title>Session: POPL TutorialFest - Linear and Graded Modal Types for Fine-Grained Program Reasoning I</title>
      <room>Hotel Cascais Miragem | Sala VI</room>
      <date>2019/01/14</date>
      <start_time>09:00</start_time>
      <end_time>10:30</end_time>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VI</room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>0c7f4ad9-7d44-4ec4-99d3-e6ddda6cc667</slot_id>
      <title>[T3] Linear and Graded Modal Types for Fine-Grained Program Reasoning</title>
      <room>Hotel Cascais Miragem | Sala VI</room>
      <date>2019/01/14</date>
      <start_time>09:00</start_time>
      <end_time>10:30</end_time>
      <description>Linear types have long been heralded as a mechanism for enforcing strict adherence to resource-based protocols, e.g., file handles, operation system APIs, and communication protocols in concurrency. Recent work has seen linear types become an increasingly popular topic in our community, with the rise in the work on session types, with new proposed extensions to Haskell for linear types, and with languages such as Rust and ATS. This tutorial provides an introduction to linear types and a look at the state-of-the-art in type systems extending linear types with graded modal types as a basis for more fine-grained program reasoning as embodied by the Granule programming language. Granule combines linear types with lightweight dependent types and graded modal types, providing a rich type system for enforcing fine-grained resource constraints on top of a functional language in the style of Haskell/ML. This tutorial will cover both the theoretical and practical aspects of linear and graded modal types, with an opportunity to try Granule via exercises as well an introduction to the research context and recent work in the literature.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dominic</first_name>
          <last_name>Orchard</last_name>
          <affiliation>University of Kent, UK</affiliation>
          <bio>Dr Dominic Orchard is a Lecturer in the School of Computing at the University of Kent, UK and he is a fellow of the SSI. His research interests are programming language design and semantics, mathematically structured programming, effect and coeffect systems, embedded domain-specific languages (esp. for parallelisation), and applying programming language research to computational science.</bio>
          <homepage_url>http://dorchard.co.uk</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/dominicorchard/f448aa26-a342-457c-91a6-3f9525a759a3/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Harley D.</first_name>
          <last_name>Eades III</last_name>
          <affiliation>Augusta University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://metatheorem.org/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/harleydeadesiii/f905a133-193a-43a2-a974-2a9e8c8383b6/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Vilem-Benjamin</first_name>
          <last_name>Liepelt</last_name>
          <affiliation>University of Kent, UK</affiliation>
          <bio>Research 
PhD at School of Computing, University of Kent (ongoing) 
I am collaborating with my supervisor Dominic Orchard (Kent, UK) and Harley Eades III (Augusta, GA) on Granule, a linear functional language with graded modal types. This is a continuation of research I started during my undergraduate degree. I was awarded a funded research PhD position to continue work in the area of linearity and graded modal types from September 2018. 
 
 I co-authored an extended abstract and gave a joint talk at SREPLS 7 about this work. 
 I completed a final year research project about adding (G)ADTs to Granule, along with a working (prototype) Haskell implementation. 
 
Internship at School of Computing, University of Kent (2017) 
In the context of CamFort, a static analyser for Fortran source code written in Haskell, I evaluated the possibility of discharging units-of-measure checking and inference to an off-the-shelf SMT solver (Z3). This was my first time both working on a serious Haskell codebase and using SMT solvers. 
 
Industry work 
Internship at Google, London (2017) 
I worked on extending email preferences for customers of a major Google product. My project involved using Java 8 streams within Google’s infrastructure. 
Internship at Adjoint, London (2018) 
In the context of a distributed ledger infrastructure built using Haskell, I worked on adding permissions and statically checking absence of concurrency bugs for concurrent, multi-party workflows.</bio>
          <homepage_url>https://www.cs.kent.ac.uk/people/rpg/vl200/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/vilembenjaminliepelt/fd5dce5e-b08a-44aa-853f-d27c221e3692/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ecc1152b-b5f9-4746-9631-02344b064f62</subevent_id>
    <title>POPL TutorialFest: Building Your Own Modular Static Analyser with Infer I</title>
    <timeslot>
      <slot_id>3810729e-2361-49f5-baf4-1b5ff9709fca</slot_id>
      <title>Session: POPL TutorialFest - Building Your Own Modular Static Analyser with Infer I</title>
      <room>Hotel Cascais Miragem | Sala IX</room>
      <date>2019/01/14</date>
      <start_time>14:00</start_time>
      <end_time>15:30</end_time>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala IX</room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>b3b8e07e-ddff-49f8-9c12-944c5cbabb0a</slot_id>
      <title>[T7] Higher-Order Probabilistic Programming</title>
      <room>Hotel Cascais Miragem | Sala IX</room>
      <date>2019/01/14</date>
      <start_time>14:00</start_time>
      <end_time>15:30</end_time>
      <description>This tutorial is meant to be an introduction to the principles of randomized and bayesian higher-order programming languages. We will start by giving some simple examples of probabilistic higher-order programs, written in generic or domain specific functional programming languages. Particular attention will be given in highlighting why sampling and conditioning can be useful in programming, and how the metatheory of higher-order probabilistic programming differs from the one of its deterministic sibling.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ugo</first_name>
          <last_name>Dal Lago</last_name>
          <affiliation>University of Bologna, Italy / Inria, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.unibo.it/~dallago/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/ugodallago/446eb4fe-dc38-4ed0-85ba-5f746abe1550/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>fbc53a97-fcc3-4292-af2e-b83c7bacb07b</subevent_id>
    <title>POPL TutorialFest: QuickChick: Property-Based Testing in Coq II</title>
    <timeslot>
      <slot_id>7142d065-cfc1-4348-8c6a-269729111852</slot_id>
      <title>Session: POPL TutorialFest - QuickChick: Property-Based Testing in Coq II</title>
      <room>Hotel Cascais Miragem | Sala V</room>
      <date>2019/01/14</date>
      <start_time>11:00</start_time>
      <end_time>12:30</end_time>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala V</room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>0bed4ea3-274e-4968-8a29-44e63a037fbd</slot_id>
      <title>[T1] QuickChick: Property-Based Testing in Coq</title>
      <room>Hotel Cascais Miragem | Sala V</room>
      <date>2019/01/14</date>
      <start_time>11:00</start_time>
      <end_time>12:30</end_time>
      <description>This tutorial will introduce QuickChick, a property-based random testing tool for the Coq proof assistant. For Coq users, it should be able to facilitate their verification efforts, uncovering bugs early on in the design process, before wasting time and resources on futile proof attempts. Our aim with this tutorial is to give an overview of QuickChick’s functionality through a series of simple examples</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Benjamin C.</first_name>
          <last_name>Pierce</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>Benjamin Pierce is Henry Salvatori Professor of Computer and Information Science at the University of Pennsylvania and a Fellow of the ACM. His research interests include programming languages, type systems, language-based security, computer-assisted formal verification, differential privacy, and synchronization technologies. He is the author of the widely used graduate textbooks Types and Programming Languages and Software Foundations. He has served as co-Editor in Chief of the Journal of Functional Programming, as Managing Editor for Logical Methods in Computer Science, and as editorial board member of Mathematical Structures in Computer Science, Formal Aspects of Computing, and ACM Transactions on Programming Languages and Systems. He is also the lead designer of the popular Unison file synchronizer.</bio>
          <homepage_url>http://www.cis.upenn.edu/~bcpierce/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/benjamincpierce/f2ee6f41-5bf7-4a0d-9b8d-71de6a666b1b/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Leonidas</first_name>
          <last_name>Lampropoulos</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cis.upenn.edu/~llamp/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/leonidaslampropoulos/0533948d-2e45-449e-b1d5-5fe451706ede/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1698632d-853e-4ca6-8f98-509076b615b5</subevent_id>
    <title>POPL TutorialFest: Engineering Distributed Systems via Protocols and Commitments I</title>
    <timeslot>
      <slot_id>279568ff-c78d-4629-94d6-2baa4e1b0098</slot_id>
      <title>Session: POPL TutorialFest - Engineering Distributed Systems via Protocols and Commitments I</title>
      <room>Hotel Cascais Miragem | Sala VIII</room>
      <date>2019/01/14</date>
      <start_time>09:00</start_time>
      <end_time>10:30</end_time>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VIII</room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>e35142ab-72f0-4e77-86f2-08db067d7c4c</slot_id>
      <title>[T2] Engineering Distributed Systems via Protocols and Commitments</title>
      <room>Hotel Cascais Miragem | Sala VIII</room>
      <date>2019/01/14</date>
      <start_time>09:00</start_time>
      <end_time>10:30</end_time>
      <description>Many applications in domains such as finance, health, and e-commerce are conceptually decentralized in that they involve multiple autonomous parties. Protocol specification for such decentralized settings represents an exciting and growing area of research in the programming language community (PL). Witness the surge in interest around session types and related formalisms. 
This tutorial dwells upon the theoretical foundations of multiparty protocols. We motivate information causality and information integrity as fundamental aspects of protocol specifications. Causality characterizes the knowledge needed to send a communication; integrity characterizes the consistency of communications. We show how causality and integrity yield elegant characterization of progress and safety of protocols. We present a declarative language, BSPL, that is based upon these ideas. 
A fundamental challenge in protocol specification is supporting flexible concurrent enactments over a shared- nothing asynchronous infrastructure. We compare BSPL with PL approaches. Our analysis shows that the PL approaches demand more from the infrastructure (e.g., FIFO channels) but yet are unable to specify elementary real-world scenarios. BSPL would benefit from the theoretical treatments developed in the PL approaches. 
Ultimately, what is of important to the parties are the social meanings of information communicated in protocol enactments. Social meanings include business contracts, which too are of interest to the PL community and which have applications for distributed ledger settings. We present the theoretical foundations for commitments (elemental business contracts) and a declarative language, Cupid, for specifying them. We show how commitments may be computed in a decentralized manner over BSPL protocols. We compare Cupid+BSPL with approaches developed in PL. 
Both BSPL and Cupid stem from research done in the multiagent systems community (MAS). Despite a broad overlap of concerns, PL and MAS have largely worked in isolation from each other. This tutorial presents an opportunity for the cross fertilization of ideas.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Amit</first_name>
          <last_name>Chopra</last_name>
          <affiliation>Lancaster University, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.lancaster.ac.uk/staff/chopraak/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Munindar</first_name>
          <last_name>P. Singh</last_name>
          <affiliation>North Carolina State University</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>1e18ac60-44be-4506-b64e-12da8f1246f3</subevent_id>
    <title>POPL TutorialFest: Correct-by-Construction Programming in Agda I</title>
    <timeslot>
      <slot_id>fe80682e-d176-4151-8404-4d1b48e74142</slot_id>
      <title>Session: POPL TutorialFest - Correct-by-Construction Programming in Agda I</title>
      <room>Hotel Cascais Miragem | Sala V</room>
      <date>2019/01/14</date>
      <start_time>14:00</start_time>
      <end_time>15:30</end_time>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala V</room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>3cce57e7-d4fd-4700-926e-4e150c8545e6</slot_id>
      <title>[T5] Correct-by-Construction Programming in Agda</title>
      <room>Hotel Cascais Miragem | Sala V</room>
      <date>2019/01/14</date>
      <start_time>14:00</start_time>
      <end_time>15:30</end_time>
      <description>In a dependently typed programming language you can get much stronger static guarantees about the correctness of your program than in most other languages. At the same time, dependent types enable new forms of interactive programming, by letting the types guide the construction of the program. Dependently typed languages have existed for many years, but only recently have they become usable for practical programming. 
In this tutorial, you will learn how to write correct-by-construction programs in the dependently typed programming language Agda. Concretely, we will together implement a verified typechecker and interpreter for a small C-like imperative language. Along the way, We will explore several modern features of the Agda language that make this task more pleasant, such as dependent pattern matching, monads and do-notation, coinduction and copattern matching, instance arguments, sized types, and the Haskell FFI.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Andreas</first_name>
          <last_name>Abel</last_name>
          <affiliation>Gothenburg University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jesper</first_name>
          <last_name>Cockx</last_name>
          <affiliation>Chalmers | University of Gothenburg</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jesper.sikanda.be</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/jespercockx/113f5ec5-aa52-443e-93e2-e7d8d136577b/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f7cf16aa-2405-4d93-8cb6-b6554eb91e25</subevent_id>
    <title>POPL TutorialFest: Programming Cyber-Physical Systems With Logic II</title>
    <timeslot>
      <slot_id>38a4c439-01f9-401c-8eb2-0c764c5973d9</slot_id>
      <title>Session: POPL TutorialFest - Programming Cyber-Physical Systems With Logic II</title>
      <room>Hotel Cascais Miragem | Sala IX</room>
      <date>2019/01/14</date>
      <start_time>11:00</start_time>
      <end_time>12:30</end_time>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala IX</room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>ba34e37f-2516-4bb1-b3ab-a6637a3ef0f0</slot_id>
      <title>[T4] Programming Cyber-Physical Systems With Logic</title>
      <room>Hotel Cascais Miragem | Sala IX</room>
      <date>2019/01/14</date>
      <start_time>11:00</start_time>
      <end_time>12:30</end_time>
      <description>Conventional digital computers are not the only devices that need to be programmed. This tutorial studies the programming language principles of cyber-physical systems (CPS), which are those that combine cyber aspects such as communication and computer control with physical aspects such as movement in space. CPSs have many important applications, e.g., in robotics, aerospace, and automotive domains, but require careful designs to meet stringent safety demands and have many surprises in store for the uninitiated. 
In order to do justice to the rich behaviors of a CPS, their mathematical programming models need to handle multi-dynamical systems, including, at least, the discrete dynamics of stepwise controller computations and the continuous dynamics of their differential equations. This tutorial explains how differential dynamic logic (dL) can be used to recover from those radical changes to the very essence of computation. We will show how to use dL and its implementation in the KeYmaera X theorem prover to design, specify, and verify the safety of CPS programs in an instructive chain of examples. More detail about the presented approach can also be found in the recent textbook on Logical Foundations of Cyber-Physical Systems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>André</first_name>
          <last_name>Platzer</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>André Platzer is an Associate Professor of Computer Science at Carnegie Mellon University. He develops the logical foundations of cyber-physical systems to characterize their fundamental principles and to answer the question how we can trust a computer to control physical processes. 
André Platzer has a Ph.D. from the University of Oldenburg, Germany, received an ACM Doctoral Dissertation Honorable Mention and NSF CAREER Award, and was named one of the Brilliant 10 Young Scientists by the Popular Science magazine and one of the AI’s 10 to Watch by the IEEE Intelligent Systems Magazine.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aplatzer/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/andreplatzer/51df19ff-8446-4bd2-8988-01edaa16ee24/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ba7a658e-b261-44a4-bb94-a0d1ac0fc62e</subevent_id>
    <title>POPL TutorialFest: Correct-by-Construction Programming in Agda II</title>
    <timeslot>
      <slot_id>4d053efd-cc60-4781-855d-dfa24591e614</slot_id>
      <title>Session: POPL TutorialFest - Correct-by-Construction Programming in Agda II</title>
      <room>Hotel Cascais Miragem | Sala V</room>
      <date>2019/01/14</date>
      <start_time>16:00</start_time>
      <end_time>17:30</end_time>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala V</room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>4aa514d2-dc58-4635-af8e-1870bfa209c3</slot_id>
      <title>[T5] Correct-by-Construction Programming in Agda</title>
      <room>Hotel Cascais Miragem | Sala V</room>
      <date>2019/01/14</date>
      <start_time>16:00</start_time>
      <end_time>17:30</end_time>
      <description>In a dependently typed programming language you can get much stronger static guarantees about the correctness of your program than in most other languages. At the same time, dependent types enable new forms of interactive programming, by letting the types guide the construction of the program. Dependently typed languages have existed for many years, but only recently have they become usable for practical programming. 
In this tutorial, you will learn how to write correct-by-construction programs in the dependently typed programming language Agda. Concretely, we will together implement a verified typechecker and interpreter for a small C-like imperative language. Along the way, We will explore several modern features of the Agda language that make this task more pleasant, such as dependent pattern matching, monads and do-notation, coinduction and copattern matching, instance arguments, sized types, and the Haskell FFI.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Andreas</first_name>
          <last_name>Abel</last_name>
          <affiliation>Gothenburg University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jesper</first_name>
          <last_name>Cockx</last_name>
          <affiliation>Chalmers | University of Gothenburg</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jesper.sikanda.be</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/jespercockx/113f5ec5-aa52-443e-93e2-e7d8d136577b/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>bb20d7c5-83cc-4fc2-9f81-0f5bb9536c9a</subevent_id>
    <title>POPL TutorialFest: QuickChick: Property-Based Testing in Coq I</title>
    <timeslot>
      <slot_id>04eba6e2-3fbc-4cae-9b16-76979c0a87f4</slot_id>
      <title>Session: POPL TutorialFest - QuickChick: Property-Based Testing in Coq I</title>
      <room>Hotel Cascais Miragem | Sala V</room>
      <date>2019/01/14</date>
      <start_time>09:00</start_time>
      <end_time>10:30</end_time>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala V</room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>dec488bf-2b03-49c9-a9b8-891da9a9cf57</slot_id>
      <title>[T1] QuickChick: Property-Based Testing in Coq</title>
      <room>Hotel Cascais Miragem | Sala V</room>
      <date>2019/01/14</date>
      <start_time>09:00</start_time>
      <end_time>10:30</end_time>
      <description>This tutorial will introduce QuickChick, a property-based random testing tool for the Coq proof assistant. For Coq users, it should be able to facilitate their verification efforts, uncovering bugs early on in the design process, before wasting time and resources on futile proof attempts. Our aim with this tutorial is to give an overview of QuickChick’s functionality through a series of simple examples</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Benjamin C.</first_name>
          <last_name>Pierce</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>Benjamin Pierce is Henry Salvatori Professor of Computer and Information Science at the University of Pennsylvania and a Fellow of the ACM. His research interests include programming languages, type systems, language-based security, computer-assisted formal verification, differential privacy, and synchronization technologies. He is the author of the widely used graduate textbooks Types and Programming Languages and Software Foundations. He has served as co-Editor in Chief of the Journal of Functional Programming, as Managing Editor for Logical Methods in Computer Science, and as editorial board member of Mathematical Structures in Computer Science, Formal Aspects of Computing, and ACM Transactions on Programming Languages and Systems. He is also the lead designer of the popular Unison file synchronizer.</bio>
          <homepage_url>http://www.cis.upenn.edu/~bcpierce/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/benjamincpierce/f2ee6f41-5bf7-4a0d-9b8d-71de6a666b1b/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Leonidas</first_name>
          <last_name>Lampropoulos</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cis.upenn.edu/~llamp/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/leonidaslampropoulos/0533948d-2e45-449e-b1d5-5fe451706ede/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c7c9f0bc-88b1-4479-8bc3-dbb778f1d3fd</subevent_id>
    <title>POPL TutorialFest: Higher-Order Probabilistic Programming II</title>
    <timeslot>
      <slot_id>1493d9f7-1f79-4260-9a38-c222bc5b8a4f</slot_id>
      <title>Session: POPL TutorialFest - Higher-Order Probabilistic Programming II</title>
      <room>Hotel Cascais Miragem | Sala VI</room>
      <date>2019/01/14</date>
      <start_time>16:00</start_time>
      <end_time>17:30</end_time>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VI</room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>c123116e-3b0f-4242-9ab8-7ef8de4152f1</slot_id>
      <title>[T8] Building Your Own Modular Static Analyser with Infer</title>
      <room>Hotel Cascais Miragem | Sala VI</room>
      <date>2019/01/14</date>
      <start_time>16:00</start_time>
      <end_time>17:30</end_time>
      <description>Infer is an open-source static analyser that is used to find bugs in code at Facebook. Every month, Infer runs on thousands of code changes and detects thousands of bugs that are fixed by developers before they reach production. 
Over the years, Infer has evolved from a standalone separation logic-based analyser to a powerful framework for quickly implementing modular interprocedural analyses. This framework can take a simple intraprocedural analysis that computes the summary for a single procedure and lift it to a compositional interprocedural analysis that scales to millions of lines of code. Because of compositionality, the analysis can run much more quickly on a code change than on an entire codebase, opening the way to a “move fast” form of deployment which keeps pace with the workflow of developers. Infer analyses target a common intermediate language, which allows each analyser to be run on Java, C++, Objective-C, and C code with minimal language-specific logic. 
The goal of this tutorial is to explain the capabilities of this framework and encourage attendees to use Infer as a platform for their own research. Attendees will learn tips and tricks for compositional program analysis at scale and gain hands-on experience in writing new analyses using the Infer infrastructure.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jules</first_name>
          <last_name>Villard</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ezgi</first_name>
          <last_name>Çiçek</last_name>
          <affiliation>Facebook London</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/ezgicicek/12d59906-480a-4b13-b5e7-85bb743ea9f0/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Dino</first_name>
          <last_name>Distefano</last_name>
          <affiliation>Facebook London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.eecs.qmul.ac.uk/~ddino/ddino_homepage/About_me.html</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Nikos</first_name>
          <last_name>Gorogiannis</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Peter</first_name>
          <last_name>O'Hearn</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www0.cs.ucl.ac.uk/staff/p.ohearn/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8cb13e7f-0312-4ec4-b546-17d27146d3a5</subevent_id>
    <title>POPL TutorialFest: Session-Typed Concurrent Programming II</title>
    <timeslot>
      <slot_id>e3549e5f-4c6a-418b-ab47-237299f068a3</slot_id>
      <title>Session: POPL TutorialFest - Session-Typed Concurrent Programming II</title>
      <room>Hotel Cascais Miragem | Sala VIII</room>
      <date>2019/01/14</date>
      <start_time>16:00</start_time>
      <end_time>17:30</end_time>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VIII</room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>89636c74-fd24-49f3-b685-04d6ac5692ae</slot_id>
      <title>[T6] Session-Typed Concurrent Programming</title>
      <room>Hotel Cascais Miragem | Sala VIII</room>
      <date>2019/01/14</date>
      <start_time>16:00</start_time>
      <end_time>17:30</end_time>
      <description>The recent introduction of manifest sharing into session-typed message-passing programming has increased the range of applicability of session-typed programming from a purely linear setting to one supporting shared resources. As opposed to persistent servers available through the exponential modality in linear session types, which have a copying semantics, shared resources have a sharing semantics and thus can accommodate server resources, such as shared data bases or shared output devices. To uphold the benefits of linear session-typed programming, manifest sharing integrates linear session types and shared session types using adjoint modalities. Semantically, the modalities give rise to an acquire-release discipline, where an acquire yields exclusive access to a shared process, if the process is available, and a release relinquishes exclusive access. 
In this tutorial, we review linear session types and their logical foundation, based on the existence of a Curry-Howard isomorphism between linear logic and the session-typed π-calculus. We then focus on manifest sharing, explore its logical foundation, and discuss its resulting gain in program expressiveness, which is witnessed by an encoding of the untyped asynchronous π-calculus into shared session types. The encoding crucially depends on the existence of shared channels, which are key to introducing observable non-determinism in the resulting language. Various program examples are used throughout the tutorial for illustration purposes.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Stephanie</first_name>
          <last_name>Balzer</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~balzers/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/stephaniebalzer/f9d2b097-d049-4f71-b0d4-d7870c219338/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7f58dc30-82fc-41ac-8a0e-5015d800294f</subevent_id>
    <title>POPL TutorialFest: Higher-Order Probabilistic Programming I</title>
    <timeslot>
      <slot_id>54a1d47d-7070-4688-9516-ed36f9f8b273</slot_id>
      <title>Session: POPL TutorialFest - Higher-Order Probabilistic Programming I</title>
      <room>Hotel Cascais Miragem | Sala VI</room>
      <date>2019/01/14</date>
      <start_time>14:00</start_time>
      <end_time>15:30</end_time>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VI</room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>b3a21d64-f6a5-4779-aea7-ef80eb335616</slot_id>
      <title>[T8] Building Your Own Modular Static Analyser with Infer</title>
      <room>Hotel Cascais Miragem | Sala VI</room>
      <date>2019/01/14</date>
      <start_time>14:00</start_time>
      <end_time>15:30</end_time>
      <description>Infer is an open-source static analyser that is used to find bugs in code at Facebook. Every month, Infer runs on thousands of code changes and detects thousands of bugs that are fixed by developers before they reach production. 
Over the years, Infer has evolved from a standalone separation logic-based analyser to a powerful framework for quickly implementing modular interprocedural analyses. This framework can take a simple intraprocedural analysis that computes the summary for a single procedure and lift it to a compositional interprocedural analysis that scales to millions of lines of code. Because of compositionality, the analysis can run much more quickly on a code change than on an entire codebase, opening the way to a “move fast” form of deployment which keeps pace with the workflow of developers. Infer analyses target a common intermediate language, which allows each analyser to be run on Java, C++, Objective-C, and C code with minimal language-specific logic. 
The goal of this tutorial is to explain the capabilities of this framework and encourage attendees to use Infer as a platform for their own research. Attendees will learn tips and tricks for compositional program analysis at scale and gain hands-on experience in writing new analyses using the Infer infrastructure.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jules</first_name>
          <last_name>Villard</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ezgi</first_name>
          <last_name>Çiçek</last_name>
          <affiliation>Facebook London</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/ezgicicek/12d59906-480a-4b13-b5e7-85bb743ea9f0/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Dino</first_name>
          <last_name>Distefano</last_name>
          <affiliation>Facebook London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.eecs.qmul.ac.uk/~ddino/ddino_homepage/About_me.html</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Nikos</first_name>
          <last_name>Gorogiannis</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Peter</first_name>
          <last_name>O'Hearn</last_name>
          <affiliation>Facebook</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www0.cs.ucl.ac.uk/staff/p.ohearn/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>917cad76-7680-4c5e-97a7-01bfeb905de6</subevent_id>
    <title>POPL TutorialFest: Session-Typed Concurrent Programming I</title>
    <timeslot>
      <slot_id>0ae47819-d4a5-4526-b572-016f6676448e</slot_id>
      <title>Session: POPL TutorialFest - Session-Typed Concurrent Programming I</title>
      <room>Hotel Cascais Miragem | Sala VIII</room>
      <date>2019/01/14</date>
      <start_time>14:00</start_time>
      <end_time>15:30</end_time>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VIII</room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>7d76c9cb-6696-4334-9986-8b4394abc193</slot_id>
      <title>[T6] Session-Typed Concurrent Programming</title>
      <room>Hotel Cascais Miragem | Sala VIII</room>
      <date>2019/01/14</date>
      <start_time>14:00</start_time>
      <end_time>15:30</end_time>
      <description>The recent introduction of manifest sharing into session-typed message-passing programming has increased the range of applicability of session-typed programming from a purely linear setting to one supporting shared resources. As opposed to persistent servers available through the exponential modality in linear session types, which have a copying semantics, shared resources have a sharing semantics and thus can accommodate server resources, such as shared data bases or shared output devices. To uphold the benefits of linear session-typed programming, manifest sharing integrates linear session types and shared session types using adjoint modalities. Semantically, the modalities give rise to an acquire-release discipline, where an acquire yields exclusive access to a shared process, if the process is available, and a release relinquishes exclusive access. 
In this tutorial, we review linear session types and their logical foundation, based on the existence of a Curry-Howard isomorphism between linear logic and the session-typed π-calculus. We then focus on manifest sharing, explore its logical foundation, and discuss its resulting gain in program expressiveness, which is witnessed by an encoding of the untyped asynchronous π-calculus into shared session types. The encoding crucially depends on the existence of shared channels, which are key to introducing observable non-determinism in the resulting language. Various program examples are used throughout the tutorial for illustration purposes.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Stephanie</first_name>
          <last_name>Balzer</last_name>
          <affiliation>Carnegie Mellon University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~balzers/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/stephaniebalzer/f9d2b097-d049-4f71-b0d4-d7870c219338/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f11639b4-3fab-49ef-a24e-3090a81b170f</subevent_id>
    <title>POPL TutorialFest: Engineering Distributed Systems via Protocols and Commitments II</title>
    <timeslot>
      <slot_id>689ea4db-10bd-4644-8c7d-5547d4da72c1</slot_id>
      <title>Session: POPL TutorialFest - Engineering Distributed Systems via Protocols and Commitments II</title>
      <room>Hotel Cascais Miragem | Sala VIII</room>
      <date>2019/01/14</date>
      <start_time>11:00</start_time>
      <end_time>12:30</end_time>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VIII</room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>261b48e3-af3b-4cdb-88dd-a9a3943e20e5</slot_id>
      <title>[T2] Engineering Distributed Systems via Protocols and Commitments</title>
      <room>Hotel Cascais Miragem | Sala VIII</room>
      <date>2019/01/14</date>
      <start_time>11:00</start_time>
      <end_time>12:30</end_time>
      <description>Many applications in domains such as finance, health, and e-commerce are conceptually decentralized in that they involve multiple autonomous parties. Protocol specification for such decentralized settings represents an exciting and growing area of research in the programming language community (PL). Witness the surge in interest around session types and related formalisms. 
This tutorial dwells upon the theoretical foundations of multiparty protocols. We motivate information causality and information integrity as fundamental aspects of protocol specifications. Causality characterizes the knowledge needed to send a communication; integrity characterizes the consistency of communications. We show how causality and integrity yield elegant characterization of progress and safety of protocols. We present a declarative language, BSPL, that is based upon these ideas. 
A fundamental challenge in protocol specification is supporting flexible concurrent enactments over a shared- nothing asynchronous infrastructure. We compare BSPL with PL approaches. Our analysis shows that the PL approaches demand more from the infrastructure (e.g., FIFO channels) but yet are unable to specify elementary real-world scenarios. BSPL would benefit from the theoretical treatments developed in the PL approaches. 
Ultimately, what is of important to the parties are the social meanings of information communicated in protocol enactments. Social meanings include business contracts, which too are of interest to the PL community and which have applications for distributed ledger settings. We present the theoretical foundations for commitments (elemental business contracts) and a declarative language, Cupid, for specifying them. We show how commitments may be computed in a decentralized manner over BSPL protocols. We compare Cupid+BSPL with approaches developed in PL. 
Both BSPL and Cupid stem from research done in the multiagent systems community (MAS). Despite a broad overlap of concerns, PL and MAS have largely worked in isolation from each other. This tutorial presents an opportunity for the cross fertilization of ideas.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Amit</first_name>
          <last_name>Chopra</last_name>
          <affiliation>Lancaster University, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.lancaster.ac.uk/staff/chopraak/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Munindar</first_name>
          <last_name>P. Singh</last_name>
          <affiliation>North Carolina State University</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>3742400a-abb0-4ca5-9393-a3c9a1b20b4d</subevent_id>
    <title>POPL TutorialFest: Programming Cyber-Physical Systems With Logic I</title>
    <timeslot>
      <slot_id>1f6aadd3-2537-4643-bb95-cb3d114417be</slot_id>
      <title>Session: POPL TutorialFest - Programming Cyber-Physical Systems With Logic I</title>
      <room>Hotel Cascais Miragem | Sala IX</room>
      <date>2019/01/14</date>
      <start_time>09:00</start_time>
      <end_time>10:30</end_time>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala IX</room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>4b7b014f-e953-47d9-aca0-a90af3acd4d3</slot_id>
      <title>[T4] Programming Cyber-Physical Systems With Logic</title>
      <room>Hotel Cascais Miragem | Sala IX</room>
      <date>2019/01/14</date>
      <start_time>09:00</start_time>
      <end_time>10:30</end_time>
      <description>Conventional digital computers are not the only devices that need to be programmed. This tutorial studies the programming language principles of cyber-physical systems (CPS), which are those that combine cyber aspects such as communication and computer control with physical aspects such as movement in space. CPSs have many important applications, e.g., in robotics, aerospace, and automotive domains, but require careful designs to meet stringent safety demands and have many surprises in store for the uninitiated. 
In order to do justice to the rich behaviors of a CPS, their mathematical programming models need to handle multi-dynamical systems, including, at least, the discrete dynamics of stepwise controller computations and the continuous dynamics of their differential equations. This tutorial explains how differential dynamic logic (dL) can be used to recover from those radical changes to the very essence of computation. We will show how to use dL and its implementation in the KeYmaera X theorem prover to design, specify, and verify the safety of CPS programs in an instructive chain of examples. More detail about the presented approach can also be found in the recent textbook on Logical Foundations of Cyber-Physical Systems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>André</first_name>
          <last_name>Platzer</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>André Platzer is an Associate Professor of Computer Science at Carnegie Mellon University. He develops the logical foundations of cyber-physical systems to characterize their fundamental principles and to answer the question how we can trust a computer to control physical processes. 
André Platzer has a Ph.D. from the University of Oldenburg, Germany, received an ACM Doctoral Dissertation Honorable Mention and NSF CAREER Award, and was named one of the Brilliant 10 Young Scientists by the Popular Science magazine and one of the AI’s 10 to Watch by the IEEE Intelligent Systems Magazine.</bio>
          <homepage_url>http://www.cs.cmu.edu/~aplatzer/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/andreplatzer/51df19ff-8446-4bd2-8988-01edaa16ee24/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0b94be10-fb23-44db-a55c-043b1bec5ac6</subevent_id>
    <title>POPL TutorialFest: Linear and Graded Modal Types for Fine-Grained Program Reasoning II</title>
    <timeslot>
      <slot_id>0c2298d3-f1c3-4dd6-adf8-f2942f641c41</slot_id>
      <title>Session: POPL TutorialFest - Linear and Graded Modal Types for Fine-Grained Program Reasoning II</title>
      <room>Hotel Cascais Miragem | Sala VI</room>
      <date>2019/01/14</date>
      <start_time>11:00</start_time>
      <end_time>12:30</end_time>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala VI</room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>cfe18c1a-59fb-4021-954f-cabb0bcdd33b</slot_id>
      <title>[T3] Linear and Graded Modal Types for Fine-Grained Program Reasoning</title>
      <room>Hotel Cascais Miragem | Sala VI</room>
      <date>2019/01/14</date>
      <start_time>11:00</start_time>
      <end_time>12:30</end_time>
      <description>Linear types have long been heralded as a mechanism for enforcing strict adherence to resource-based protocols, e.g., file handles, operation system APIs, and communication protocols in concurrency. Recent work has seen linear types become an increasingly popular topic in our community, with the rise in the work on session types, with new proposed extensions to Haskell for linear types, and with languages such as Rust and ATS. This tutorial provides an introduction to linear types and a look at the state-of-the-art in type systems extending linear types with graded modal types as a basis for more fine-grained program reasoning as embodied by the Granule programming language. Granule combines linear types with lightweight dependent types and graded modal types, providing a rich type system for enforcing fine-grained resource constraints on top of a functional language in the style of Haskell/ML. This tutorial will cover both the theoretical and practical aspects of linear and graded modal types, with an opportunity to try Granule via exercises as well an introduction to the research context and recent work in the literature.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dominic</first_name>
          <last_name>Orchard</last_name>
          <affiliation>University of Kent, UK</affiliation>
          <bio>Dr Dominic Orchard is a Lecturer in the School of Computing at the University of Kent, UK and he is a fellow of the SSI. His research interests are programming language design and semantics, mathematically structured programming, effect and coeffect systems, embedded domain-specific languages (esp. for parallelisation), and applying programming language research to computational science.</bio>
          <homepage_url>http://dorchard.co.uk</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/dominicorchard/f448aa26-a342-457c-91a6-3f9525a759a3/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Harley D.</first_name>
          <last_name>Eades III</last_name>
          <affiliation>Augusta University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://metatheorem.org/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/harleydeadesiii/f905a133-193a-43a2-a974-2a9e8c8383b6/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Vilem-Benjamin</first_name>
          <last_name>Liepelt</last_name>
          <affiliation>University of Kent, UK</affiliation>
          <bio>Research 
PhD at School of Computing, University of Kent (ongoing) 
I am collaborating with my supervisor Dominic Orchard (Kent, UK) and Harley Eades III (Augusta, GA) on Granule, a linear functional language with graded modal types. This is a continuation of research I started during my undergraduate degree. I was awarded a funded research PhD position to continue work in the area of linearity and graded modal types from September 2018. 
 
 I co-authored an extended abstract and gave a joint talk at SREPLS 7 about this work. 
 I completed a final year research project about adding (G)ADTs to Granule, along with a working (prototype) Haskell implementation. 
 
Internship at School of Computing, University of Kent (2017) 
In the context of CamFort, a static analyser for Fortran source code written in Haskell, I evaluated the possibility of discharging units-of-measure checking and inference to an off-the-shelf SMT solver (Z3). This was my first time both working on a serious Haskell codebase and using SMT solvers. 
 
Industry work 
Internship at Google, London (2017) 
I worked on extending email preferences for customers of a major Google product. My project involved using Java 8 streams within Google’s infrastructure. 
Internship at Adjoint, London (2018) 
In the context of a distributed ledger infrastructure built using Haskell, I worked on adding permissions and statically checking absence of concurrency bugs for concurrent, multi-party workflows.</bio>
          <homepage_url>https://www.cs.kent.ac.uk/people/rpg/vl200/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/vilembenjaminliepelt/fd5dce5e-b08a-44aa-853f-d27c221e3692/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6450a860-eb66-4a17-b602-1b51ecbcbe17</subevent_id>
    <title>POPL TutorialFest: Building Your Own Modular Static Analyser with Infer II</title>
    <timeslot>
      <slot_id>26ff8e8d-f3db-4046-a792-c38db16a5625</slot_id>
      <title>Session: POPL TutorialFest - Building Your Own Modular Static Analyser with Infer II</title>
      <room>Hotel Cascais Miragem | Sala IX</room>
      <date>2019/01/14</date>
      <start_time>16:00</start_time>
      <end_time>17:30</end_time>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala IX</room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-TutorialFest</url>
    <url_link_display>TutorialFest</url_link_display>
    <tracks>
      <track>TutorialFest</track>
    </tracks>
    <timeslot>
      <slot_id>99c3269c-7fa3-4834-a408-c20826ba87bb</slot_id>
      <title>[T7] Higher-Order Probabilistic Programming</title>
      <room>Hotel Cascais Miragem | Sala IX</room>
      <date>2019/01/14</date>
      <start_time>16:00</start_time>
      <end_time>17:30</end_time>
      <description>This tutorial is meant to be an introduction to the principles of randomized and bayesian higher-order programming languages. We will start by giving some simple examples of probabilistic higher-order programs, written in generic or domain specific functional programming languages. Particular attention will be given in highlighting why sampling and conditioning can be useful in programming, and how the metatheory of higher-order probabilistic programming differs from the one of its deterministic sibling.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ugo</first_name>
          <last_name>Dal Lago</last_name>
          <affiliation>University of Bologna, Italy / Inria, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.unibo.it/~dallago/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/ugodallago/446eb4fe-dc38-4ed0-85ba-5f746abe1550/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>TutorialFest</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a9a9804b-71fa-421a-a1b8-070762052c67</subevent_id>
    <title>POPL Research Papers: Facebook Reception</title>
    <timeslot>
      <slot_id>6867cfca-dcc5-4264-94a3-d631455c76cb</slot_id>
      <title>Session: POPL Research Papers - Facebook Reception</title>
      <room>Hotel Cascais Miragem | Galeria</room>
      <date>2019/01/17</date>
      <start_time>18:00</start_time>
      <end_time>19:00</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Galeria</room>
    <date>2019/01/17</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>2bb722eb-7750-476a-8fc3-2a37baa60662</slot_id>
      <title>Facebook Reception</title>
      <room>Hotel Cascais Miragem | Galeria</room>
      <date>2019/01/17</date>
      <start_time>18:00</start_time>
      <end_time>19:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8150ff81-2d70-4428-b7af-b8c146f3c158</subevent_id>
    <title>POPL Research Papers: Session Types II</title>
    <timeslot>
      <slot_id>0d4da2d3-e24e-40d9-9df3-378ea6573a2e</slot_id>
      <title>Session: POPL Research Papers - Session Types II</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/16</date>
      <start_time>16:37</start_time>
      <end_time>17:43</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala II</room>
    <date>2019/01/16</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>1cf7cda0-6a59-4b0b-8426-5cbb5280c961</slot_id>
      <title>Less is More: Multiparty Session Types Revisited</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/16</date>
      <start_time>17:21</start_time>
      <end_time>17:43</end_time>
      <description>Multiparty Session Types (MPST) are a typing discipline ensuring that a message-passing process implements a given multiparty session protocol, without errors. In this paper, we propose a new, generalised MPST theory. 
Our contribution is fourfold. 
 
  We demonstrate that a revision of the theoretical foundations of MPST is necessary: classic MPST have a limited subject reduction property, with inherent restrictions that are easily overlooked, and in previous work have led to flawed type safety proofs; our new theory removes such restrictions and fixes such flaws.  
  We contribute a new MPST theory that is less complicated, and yet more general, than the classic one: it does not require global multiparty session types nor binary session type duality — instead, it is grounded on general behavioural type-level properties, and proves type safety of many more protocols and processes.  
  We produce a detailed analysis of type-level properties, showing how, in our new theory, they allow to ensure decidability of type checking, and statically guarantee that processes enjoy, e.g., deadlock-freedom and liveness at run-time.  
  We show how our new theory can integrate type and model checking: type-level properties can be expressed in modal μ-calculus, and verified with well-established tools.  
</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alceste</first_name>
          <last_name>Scalas</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~ascalas/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/alcestescalas/a32ab3bc-89ad-4ae7-9121-b8407bb836bf/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>64b27317-365e-4dbc-82b2-88d0c39c6802</slot_id>
      <title>Interconnectability of Session-Based Logical Processes</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/16</date>
      <start_time>16:37</start_time>
      <end_time>16:59</end_time>
      <description>In multiparty session types, interconnection networks identify which roles in a session engage in communica- tion (i.e. two roles are connected if they exchange a message). In session-based interpretations of linear logic the analogue notion corresponds to determining which processes are composed, or cut, using compatible channels typed by linear propositions. In this work we show that well-formed interactions represented in a session-based interpretation of classical linear logic (CLL) form strictly less expressive interconnection networks than those of a multiparty session calculus. To achieve this result we introduce a new compositional synthesis property dubbed partial multiparty compatibility (PMC), enabling us to build a global type denoting the interactions obtained by iterated composition of well-typed CLL threads. We then show that CLL compo- sition induces PMC global types without circular interconnections between three (or more) participants. PMC is then used to de ne a new CLL composition rule which can form circular interconnections but preserves the deadlock-freedom of CLL.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Bernardo</first_name>
          <last_name>Toninho</last_name>
          <affiliation>NOVA-LINCS, FCT/UNL</affiliation>
          <bio>I am interested in the application of language-based techniques to the development of more robust and safer concurrent and distributed systems. More specifically, I work within the realm of (substructural) type theory, such as those based on Linear Logic and Session Types, and their applications to concurrent programming. I am also interested in using type and logic-based techniques to verify concurrent programs in real languages such as Go, Rust and Scala.</bio>
          <homepage_url>http://ctp.di.fct.unl.pt/~btoninho/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/bernardotoninho1/1125bc54-0549-4ee4-bf19-394d89568c34/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c2e97b79-ba87-44ba-bcca-94c1d9760ffe</slot_id>
      <title>Distributed Programming using Role-Parametric Session Types in Go</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/16</date>
      <start_time>16:59</start_time>
      <end_time>17:21</end_time>
      <description>This paper presents a framework for the static specification and safe programming of message passing protocols where the number and kinds of participants are dynamically instantiated. We develop the first theory of distributed multiparty session types (MPST) to support parameterised protocols with indexed roles—our framework statically infers the different kinds of participants induced by a protocol definition as role variants, and produces decoupled endpoint projections of the protocol onto each variant. This enables safe MPST-based programming of the parameterised endpoints in distributed settings: each endpoint can be implemented separately by different programmers, using different techniques (or languages). We prove the decidability of role variant inference and well-formedness checking, and the correctness of projection. 
We implement our theory as a toolchain for programming such role-parametric MPST protocols in Go. Our approach is to generate API families of lightweight, protocol- and variant-specific type wrappers for I/O. The APIs ensure a well-typed Go endpoint program (by native Go type checking) will perform only compliant I/O actions w.r.t. the source protocol. We leverage the abstractions of MPST to support the specification and implementation of Go applications involving multiple channels, possibly over mixed transports (e.g., Go channels, TCP), and channel passing via a unified programming interface. We evaluate the applicability and run-time performance of our generated APIs using microbenchmarks and real-world applications.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>David</first_name>
          <last_name>Castro</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Raymond</first_name>
          <last_name>Hu</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sung-Shik</first_name>
          <last_name>Jongmans</last_name>
          <affiliation>Open University of the Netherlands</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Nicholas</first_name>
          <last_name>Ng</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>I apply theoretical understanding of concurrency to analysis of programming language and systems, in particular, Go ʕ◉ϖ◉ʔ</bio>
          <homepage_url>https://nickng.io</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/nicholasng/0b7160b3-c00d-425d-8713-a7048f3fd4c0/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>3a392b1b-8f9d-45db-a572-1e959d5457a4</subevent_id>
    <title>POPL Research Papers: Tuesday Lunch</title>
    <timeslot>
      <slot_id>92081979-0b0c-43d3-be7e-14d66503881e</slot_id>
      <title>Session: POPL Research Papers - Tuesday Lunch</title>
      <room>Hotel Cascais Miragem | Lunch Room</room>
      <date>2019/01/15</date>
      <start_time>12:30</start_time>
      <end_time>14:00</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Lunch Room</room>
    <date>2019/01/15</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>61f20e4c-beff-40c3-857a-e564e6d3f961</slot_id>
      <title>Lunch</title>
      <room>Hotel Cascais Miragem | Lunch Room</room>
      <date>2019/01/15</date>
      <start_time>12:30</start_time>
      <end_time>14:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>7d554c72-a343-48ff-a045-0bbc6c229e55</subevent_id>
    <title>POPL Research Papers: Quantum Programming</title>
    <timeslot>
      <slot_id>4c649868-d93a-4f26-8148-662081c1caa2</slot_id>
      <title>Session: POPL Research Papers - Quantum Programming</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/16</date>
      <start_time>16:37</start_time>
      <end_time>17:43</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala I</room>
    <date>2019/01/16</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>5c60086e-2f59-4c3b-8def-3edffad490dd</slot_id>
      <title>Quantitative Robustness Analysis of Quantum Programs</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/16</date>
      <start_time>16:37</start_time>
      <end_time>16:59</end_time>
      <description>Quantum computation is a topic of significant recent interest, with practical advances coming from both research and industry. A major challenge in quantum programming is dealing with errors (quantum noise) during execution. Because quantum resources (e.g., qubits) are scarce, classical error correction techniques applied at the level of the architecture are currently cost-prohibitive. But while this reality means that quantum programs are almost certain to have errors, there as yet exists no principled means to reason about erroneous behavior. This paper attempts to fill this gap by developing a semantics for erroneous quantum while-programs, as well as a logic for reasoning about them. This logic permits proving a property we have identified, called $\epsilon$-robustness, which characterizes possible ``distance'' between an ideal program and an erroneous one. We have proved the logic sound, and showed its utility on several case studies, notably: (1) analyzing the robustness of noisy versions of the quantum Bernoulli factory (QBF) and quantum walk (QW); (2) demonstrating the (in)effectiveness of different error correction schemes on single-qubit errors; and (3) analyzing the robustness of a fault-tolerant version of QBF.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Shih-Han</first_name>
          <last_name>Hung</last_name>
          <affiliation>University of Maryland</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Kesha</first_name>
          <last_name>Hietala</last_name>
          <affiliation>University of Maryland</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Shaopeng</first_name>
          <last_name>Zhu</last_name>
          <affiliation>University of Maryland</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Mingsheng</first_name>
          <last_name>Ying</last_name>
          <affiliation>University of Technology Sydney</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://quantum-lab.org/mingsheng/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/mingshengying/955ed532-f014-4273-965a-4906017b4b8d/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Michael</first_name>
          <last_name>Hicks</last_name>
          <affiliation>University of Maryland, College Park</affiliation>
          <bio>Michael Hicks is a Professor in the Computer Science department and UMIACS at the University of Maryland, where he co-directs the laboratory for Programming Languages research (PLUM); he is the former Director of the Maryland Cybersecurity Center (MC2). 
His research focuses on using programming languages and analyses to improve the security, reliability, and availability of software. He is perhaps best known for his work exploring dynamic software updating, which is a technique by which software can be updated without shutting it down. He has explored the design of new programming languages and analysis tools for helping programmers find bugs and software vulnerabilities, and for identifying suspicious or incorrect program executions. 
His recent work has combined ideas from PL and cryptography, e.g., to ensure privacy preserving computations. He also leads the development of a new security-oriented programming contest, “build-it, break-it, fix-it,” which has been offered to the public and to students in his Coursera class on software security. He is the co-editor of the Programming Languages Enthusiast blog and Tweets at @michael_w_hicks.</bio>
          <homepage_url>http://www.cs.umd.edu/~mwh/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/michaelhicks/aa64e3c6-3516-4e13-affe-77bc32c40565/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Xiaodi</first_name>
          <last_name>Wu</last_name>
          <affiliation>University of Oregon, USA</affiliation>
          <bio>I am an Assistant Professor in the Computer and Information Science Department at the University of Oregon. I am also an affiliated faculty at Center for Cyber Security and Privacy, University of Oregon. 
I received my Phd in theoretical computer science in 2013 (advisor: Yaoyun Shi) from the University of Michigan, Ann Arbor. I received my B.S. degree in mathematics and physics in 2008 from the Academic Talent Program, Tsinghua University. 
Before coming to Oregon, I was a Postdoctoral Associate at Massachusetts Institute of Technology from 2013 to 2015 (advisor: Aram Harrow, Scott Aaronson, Edward Farhi and Peter Shor). I was also a Simons Research Fellow at the Simons Institute for the Theory of Computing at Berkeley, for the program of Quantum Hamiltonian Complexity in Spring 2014 (advisor: Umesh Vazirani). I also spent two summers at Institute for Quantum Computing, University of Waterloo as a student intern (advisor: John Watrous).</bio>
          <homepage_url>https://ix.cs.uoregon.edu/~xiaodiwu/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/xiaodiwu/73e0026d-f95f-42e1-a7cf-e7443e83c0ef/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bfa1c4ea-d7d0-4368-a060-38bf283e2d1c</slot_id>
      <title>Game Semantics for Quantum Programming</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/16</date>
      <start_time>16:59</start_time>
      <end_time>17:21</end_time>
      <description>Quantum programming languages permit a hardware independent, high-level description of quantum algorithms. In particular, the quantum lambda-calculus is a higher-order programming language with quantum primitives, mixing quantum data and classical control. Giving satisfactory denotational semantics to the quantum lambda-calculus is a challenging problem that has attracted significant interest in the past few years. Several models have been proposed but for those that address the whole quantum lambda-calculus, they either do not represent the dynamics of computation, or they lack the compositionality one often expects from denotational models. 
In this paper, we give the first compositional and interactive model of the full quantum lambda-calculus, based on game semantics. To achieve this we introduce a model of quantum games and strategies, combining quantum data with a representation of the dynamics of computation inspired from causal models of concurrent systems. In this category we first give a computationally adequate interpretation of the affine fragment. Then, we extend the model with a notion of symmetry, allowing us to deal with replication. In this refined setting, we interpret and prove adequacy for the full quantum lambda-calculus. We do this both from a sequential and a parallel interpretation, the latter representing faithfully the causal independence between sub-computations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Pierre</first_name>
          <last_name>Clairambault</last_name>
          <affiliation>CNRS &amp; ENS Lyon</affiliation>
          <bio>Researcher at the CNRS, member of the Plume team in the LIP laboratory, in the ENS de Lyon, France. 
I did my PhD thesis in the PPS laboratory in Paris (now IRIF), under the supervision of Russ Harmer and Pierre-Louis Curien. After that, I did a postdoc in the Department of Computer Science of the University of Bath with Jim Laird, then a postdoc in the Computer Laboratory of the University of Cambridge, with Glynn Winskel.</bio>
          <homepage_url>http://perso.ens-lyon.fr/pierre.clairambault</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/pierreclairambault/14e507b0-357d-435f-88fc-830da0fd87fd/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marc</first_name>
          <last_name>De Visme</last_name>
          <affiliation>ENS Lyon</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Glynn</first_name>
          <last_name>Winskel</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cff233fa-c914-41b7-a56e-ee5d0ebea18b</slot_id>
      <title>Quantum Relational Hoare Logic</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/16</date>
      <start_time>17:21</start_time>
      <end_time>17:43</end_time>
      <description>We present a logic for reasoning about pairs of interactive quantum programs – quantum relational Hoare logic (qRHL). This logic follows the spirit of probabilistic relational Hoare logic (Barthe et al. 2009) and allows us to formulate how the outputs of two quantum programs relate given the relationship of their inputs. Probabilistic RHL was used extensively for computer-verified security proofs of classical cryptographic protocols. Since pRHL is not suitable for analyzing quantum cryptography, we present qRHL as a replacement, suitable for the security analysis of post-quantum cryptography and quantum protocols. The design of qRHL poses some challenges unique to the quantum setting, e.g., the definition of equality on quantum registers. Finally, we implemented a tool for verifying proofs in qRHL and developed several example security proofs in it.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dominique</first_name>
          <last_name>Unruh</last_name>
          <affiliation>University of Tartu</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/dominiqueunruh/bf1b4eab-28b8-4853-b09f-c899ed12bf89/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>66181d09-05b4-43a1-b4e4-3599a73ffbfb</subevent_id>
    <title>POPL Research Papers: Synthesis</title>
    <timeslot>
      <slot_id>03541292-0e0e-451e-a967-10a50655c661</slot_id>
      <title>Session: POPL Research Papers - Synthesis</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/17</date>
      <start_time>09:00</start_time>
      <end_time>10:06</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala II</room>
    <date>2019/01/17</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>3c35a729-4d4f-42d5-98a5-447d5a74417e</slot_id>
      <title>Structuring the Synthesis of Heap-Manipulating Programs</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/17</date>
      <start_time>09:00</start_time>
      <end_time>09:22</end_time>
      <description>This paper describes a deductive approach to synthesizing imperative programs with pointers from declarative specifications expressed in Separation Logic. Our synthesis algorithm takes as input a pair of assertions—a pre- and a postcondition— which describe two states of the symbolic heap, and derives a program that transforms one state into the other, guided by the shape of the heap. Our approach to program synthesis is grounded in proof theory: we introduce the novel framework of Synthetic Separation Logic (SSL), which generalises the classical notion of heap entailment $P \vdash Q$ to incorporate a possibility of transforming a heap satisfying an assertion $P$ into a heap satisfying an assertion $Q$. A synthesized program represents a proof term for a transforming entailment statement $P \leadsto Q$, and the synthesis procedure corresponds to a proof search. The derived programs are, thus, correct by construction, in the sense that they satisfy the ascribed pre/postconditions, and are accompanied by complete proof derivations, which can be checked independently. 
We have implemented a proof search engine for SSL in a form of the program synthesizer called SuSLik. For efficiency, the engine exploits properties of SSL rules, such as invertibility and commutativity of rule applications on separate heaps, to prune the space of derivations it has to consider. We explain and showcase the use of SSL on characteristic examples, describe the design of SuSLik, and report on our experience of using it to synthesize a series of benchmark programs manipulating heap-based linked data structures.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nadia</first_name>
          <last_name>Polikarpova</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>Nadia Polikarpova is an Assistant Professor in the Computer Science and Engineering Department at the University of California, San Diego. She completed her PhD in 2014 at ETH Zurich (Switzerland) under the supervision of Bertrand Meyer. After that, she spent almost three years as a postdoc at MIT CSAIL, working with Armando Solar-Lezama. Her research interests span the areas of programming languages and formal methods; in particular, she is interested in building practical tools and techniques that make it easier for programmers to construct secure and reliable software.</bio>
          <homepage_url>https://cseweb.ucsd.edu/~npolikarpova/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/nadiapolikarpova/1ca23575-2891-4776-a8b4-c4216af887f3/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ilya</first_name>
          <last_name>Sergey</last_name>
          <affiliation>Yale-NUS College</affiliation>
          <bio>I am a tenure-track Associate Professor at Yale-NUS College and NUS School of Computing (Singapore). 
Prior to joining Yale-NUS, I was a faculty at University College London. Before then, I was a postdoctoral researcher at IMDEA Software Institute (Madrid, Spain). I defended my PhD in 2012 in the DistriNet research group at the Department of Computer Sciences of KU Leuven (Belgium). Before that I received my MSc degree in Mathematics and Computer Science from Saint Petersburg State University (Russia) in 2008. 
My research interests dwell in the area of the design and implementation of programming languages, including but not limited to program semantics, certified programming, concurrency and abstract interpretation. I am particularly interested in developing verification techniques and static analyses for higher-order and concurrent programs.</bio>
          <homepage_url>http://ilyasergey.net</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/ilyasergey/b2941c89-4843-4194-852a-81c8a30814fa/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9d320207-ff28-4ac8-8255-78d0fd3853aa</slot_id>
      <title>Hamsaz: Replication Coordination Analysis and Synthesis</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/17</date>
      <start_time>09:44</start_time>
      <end_time>10:06</end_time>
      <description>Distributed system replication is widely used as a means of fault-tolerance and scalability. However, it provides a spectrum of consistency choices that impose a dilemma for clients between correctness, responsiveness and availability. Given a sequential object and its integrity properties, we automatically synthesize a replicated object that guarantees state integrity and convergence and avoids unnecessary coordination. Our approach is based on a novel sufficient condition for integrity and convergence called well-coordination that requires certain orders between conflicting and dependent operations. We statically analyze the given sequential object to decide its conflicting and dependent methods and use this information to avoid coordination. We present novel coordination protocols that are parametric in terms of the analysis results and provide the well-coordination requirements. We implemented a tool that can automatically analyze the given object, instantiate the protocols and synthesize replicated objects. We have applied the tool to a suite of use-cases and synthesized replicated objects that are significantly more responsive than the strongly consistent baseline.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Farzin</first_name>
          <last_name>Houshmand</last_name>
          <affiliation>University of California, Riverside</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/farzinhoushmand/a157d6ef-2c5e-434d-9061-a462fd833e26/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Mohsen</first_name>
          <last_name>Lesani</last_name>
          <affiliation>University of California, Riverside</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ucr.edu/~lesani/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/mohsenlesani/9891c046-f676-41fd-a333-3603988b9484/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cba85c85-82ae-400c-be2a-73c45732c4fa</slot_id>
      <title>FrAngel: Component-Based Synthesis with Control Structures</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/17</date>
      <start_time>09:22</start_time>
      <end_time>09:44</end_time>
      <description>In component-based program synthesis, the synthesizer generates a program given a library of components (functions). Existing component-based synthesizers have difficulty synthesizing loops and other control structures, and they often require formal specifications of the components, which can be expensive to generate. We present FrAngel, a new approach to component-based synthesis that can synthesize short Java functions with control structures when given a desired signature, a set of input-output examples, and a collection of libraries (without formal specifications). FrAngel aims to discover programs with many distinct behaviors by combining two main ideas. First, it mines code fragments from partially-successful programs that only pass some of the examples. These extracted fragments are often useful for synthesis due to a property that we call special-case similarity. Second, FrAngel uses angelic conditions as placeholders for control structure conditions and optimistically evaluates the resulting program sketches. Angelic conditions decompose the synthesis process: FrAngel first finds promising partial programs and later fills in their missing conditions. We demonstrate that FrAngel can synthesize a variety of interesting programs with combinations of control structures within seconds, significantly outperforming prior state-of-the-art.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kensen</first_name>
          <last_name>Shi</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jacob</first_name>
          <last_name>Steinhardt</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Percy</first_name>
          <last_name>Liang</last_name>
          <affiliation>Stanford University</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b47ef65d-1cfa-4cc3-8a7a-57861a354703</subevent_id>
    <title>POPL Research Papers: Time</title>
    <timeslot>
      <slot_id>4a63a802-3e08-42bc-8887-ce28ebe3c5ba</slot_id>
      <title>Session: POPL Research Papers - Time</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/17</date>
      <start_time>15:21</start_time>
      <end_time>16:49</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala II</room>
    <date>2019/01/17</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>0ee2cf90-b1c9-407c-ad40-4b49f093c9c1</slot_id>
      <title>Modular Quantitative Monitoring</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/17</date>
      <start_time>16:05</start_time>
      <end_time>16:27</end_time>
      <description>In real-time decision making and runtime monitoring applications, declarative languages are commonly used as they facilitate modular high-level specifications with the compiler guaranteeing evaluation over data streams in an efficient and incremental manner. We introduce the model of Data Transducers to allow modular compilation of queries over streaming data. A data transducer maintains a finite set of data variables and processes a sequence of tagged data values by updating its variables using an allowed set of operations. The model allows unambiguous nondeterminism, exponentially succinct control, and combining values from parallel threads of computation. The semantics of the model immediately suggests an efficient streaming algorithm for evaluation. The expressiveness of data transducers coincides with “streamable regular functions”, a robust and streamable class of functions characterized by MSO-definable string-to-DAG transformations with no backward edges. We show that the novel features of data transducers, unlike previously studied transducers, make them as succinct as traditional imperative code for processing data streams, but the structuring of the transition function permits modular compilation. In particular, we show that operations such as parallel composition, union, prefix-sum, and quantitative analogs of combinators for unambiguous parsing, can be implemented by natural and succinct constructions on data transducers. To illustrate the benefits of such modularity in compilation, we define a new language for quantitative monitoring, QRE-Past, that integrates features of past-time temporal logic and quantitative regular expressions. While this combination allows a natural specification of a cardiac arrhythmia detection algorithm in QRE-Past, compilation of QRE-Past specifications into efficient monitors comes for free thanks to succinct constructions on data transducers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Rajeev</first_name>
          <last_name>Alur</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cis.upenn.edu/~alur/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/rajeevalur/3b3a4dca-8d4b-4db9-9986-376b2352a264/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Konstantinos</first_name>
          <last_name>Mamouras</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Caleb</first_name>
          <last_name>Stanford</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cis.upenn.edu/~castan/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/calebstanford/ecc7c13b-42ab-49e9-a867-dd26542ae449/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6fc5949f-6d90-4be8-88c6-b9b1686ac082</slot_id>
      <title>Type-Guided Worst-Case Input Generation</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/17</date>
      <start_time>15:21</start_time>
      <end_time>15:43</end_time>
      <description>This paper presents a novel technique for type-guided worst-case input generation for functional programs. The technique builds on automatic amortized resource analysis (AARA), a type-based technique for deriving symbolic bounds on the resource usage of functions. Worst-case input generation is performed by an algorithm that takes as input a function, its resource-annotated type derivation in AARA, and a skeleton that describes the shape and size of the input that is to be generated. If successful, the algorithm fills in integers, booleans, and data structures to produce a value of the shape given by the skeleton. The soundness theorem states that the generated value exhibits the highest cost among all arguments of the functions that have the shape of the skeleton. This cost corresponds exactly to the worst-case bound that is established by the type derivation. In this way, a successful completion of the algorithm proves that the bound is tight for inputs of the given shape. Correspondingly, a relative completeness theorem is proved to show that the algorithm succeeds if and only if the derived worst-case bound is tight. The theorem is relative because it depends on a decision procedure for constraint solving. The technical development is presented for a simple first-order language with linear resource bounds. However, the technique scales to and has been implemented for Resource Aware ML, an implementation of AARA for a fragment of OCaml with higher-order functions, user-defined data types, and types for polynomial bounds. Experiments demonstrate that the technique works effectively and can derive worst-case inputs with hundreds of integers for sorting algorithms, operations on search trees, and insertions into hash tables.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Di</first_name>
          <last_name>Wang</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>I am a second-year doctoral student in computer science at Carnegie Mellon University. I am advised by Prof. Jan Hoffmann. I am broadly interested in programming languages and software engineering, especially probabilistic programming, quantitative program analysis, higher type theory, and program synthesis. 
I completed my undergraduate at Peking University, China where I worked with Prof. Yingfei Xiong on summarization techniques to analyze programs sharing big libraries.</bio>
          <homepage_url>https://www.cs.cmu.edu/~diw3/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/diwang1/330fb21e-1e33-4c42-9a34-9bd369f62eb9/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jan</first_name>
          <last_name>Hoffmann</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>I am a Tenure-Track Assistant Professor at Carnegie Mellon’s Computer Science Department, and a member of the Principles of Programming (PoP) group. 
My research areas are programming languages and formal methods. I am specifically interested in quantitative verification, type systems, static resource analysis of programs, proof assistants, and system verification. 
Before joining Carnegie Mellon, I was an Associate Research Scientist in the Department of Computer Science at Yale. Before that, I was a PhD student at LMU Munich.</bio>
          <homepage_url>http://www.cs.cmu.edu/~janh/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/janhoffmann/9adae976-6941-4521-9b57-733202e412fd/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7a2ca0b5-a37a-41c5-bc32-b7a038ec16e7</slot_id>
      <title>CSS Minification via Constraint Solving</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/17</date>
      <start_time>16:27</start_time>
      <end_time>16:49</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Hague</last_name>
          <affiliation>Royal Holloway, University of London</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Anthony Widjaja</first_name>
          <last_name>Lin</last_name>
          <affiliation>Oxford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://anthonywlin.github.io/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/anthonywidjajalin/de8e94c9-268b-45b3-9436-54dcca280b28/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Chih-Duo</first_name>
          <last_name>Hong</last_name>
          <affiliation>University of Oxford</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d0978b71-d9c6-4ef1-9d44-9d6350fa0ace</slot_id>
      <title>CT-Wasm: Type-Driven Secure Cryptography for the Web Ecosystem</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/17</date>
      <start_time>15:43</start_time>
      <end_time>16:05</end_time>
      <description>A significant amount of both client and server-side cryptography is implemented in JavaScript. Despite widespread concerns about its security, no other language has been able to match the convenience that comes from its ubiquitous support on the “web ecosystem” - the wide variety of technologies that collectively underpins the modern World Wide Web. With the introduction of the new WebAssembly bytecode language (Wasm) into the web ecosystem, we have a unique opportunity to advance a principled alternative to existing JavaScript cryptography use cases which does not compromise this convenience. 
We present Constant-Time WebAssembly (CT-Wasm), a type-driven, strict extension to WebAssembly which facilitates the verifiably secure implementation of cryptographic algorithms. CT-Wasm’s type system ensures that code written in CT-Wasm is both information flow secure and resistant to timing side channel attacks; like base Wasm, these guarantees are verifiable in linear time. Building on an existing Wasm mechanization, we mechanize the full CT-Wasm specification, prove soundness of the extended type system, implement a verified type checker, and give several proofs of the language’s security properties. 
We provide two implementations of CT-Wasm: an OCaml reference interpreter and a native implementation for Node.js and Chromium that extends Google’s V8 engine. We also implement a CT-Wasm to Wasm rewrite tool that allows developers to reap the benefits of CT-Wasm’s type system today, while developing cryptographic algorithms for base Wasm environments. We evaluate the language, our implementations, and supporting tools by porting several cryptographic primitives - Salsa20, SHA-256, and TEA - and the full TweetNaCl library. We find that CT-Wasm is fast, expressive, and generates code that we experimentally measure to be constant-time.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Conrad</first_name>
          <last_name>Watt</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/conradwatt/d6df970c-7c11-418a-adb0-789ef78042eb/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>John</first_name>
          <last_name>Renner</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/johnrenner/ee473e3c-537b-4d92-afc9-8cb18e611337/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Natalie</first_name>
          <last_name>Popescu</last_name>
          <affiliation>University of California San Diego</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Sunjay</first_name>
          <last_name>Cauligi</last_name>
          <affiliation>UCSD</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Deian</first_name>
          <last_name>Stefan</last_name>
          <affiliation>University of California San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cseweb.ucsd.edu/~dstefan/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/deianstefan/55e73d29-9671-4740-9ef2-3b45f485fc24/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>18f7cc38-0fbc-4a29-a7ff-c21dd4163b1e</subevent_id>
    <title>POPL Research Papers: Abstract Interpretation</title>
    <timeslot>
      <slot_id>22846c4e-8df4-4dfb-8f71-97494826b4f3</slot_id>
      <title>Session: POPL Research Papers - Abstract Interpretation</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/18</date>
      <start_time>10:35</start_time>
      <end_time>12:03</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala II</room>
    <date>2019/01/18</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>259b5305-92f7-4ce3-b474-c07e8b88f3c0</slot_id>
      <title>Refinement of Path Expressions for Static Analysis</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/18</date>
      <start_time>11:41</start_time>
      <end_time>12:03</end_time>
      <description>Algebraic program analyses compute information about a program’s behavior by first (a) computing a valid path expression—i.e., a regular expression that recognizes all feasible execution paths (and usually more)—and then (b) interpreting the path expression in a semantic algebra that defines the analysis. There are an infinite number of different regular expressions that qualify as valid path expressions, which raises the question “Which ones should we choose?” While any choice yields a sound result, for many analyses the choice can have a drastic effect on the precision of the results obtained. This paper investigates the following two questions: (1) What does it mean for one valid path expression to be “better” than another? (2) Can we compute a valid path expression that is “best,” and if so, how? We show that it is not satisfactory to compare two path expressions $E_1$ and $E_2$ solely by means of the languages that they generate. Counter to one’s intuition, it is possible for $L(E_2) \subsetneq L(E_1)$, yet for $E_2$ to produce a less-precise analysis result than $E_1$—and thus we would not want to perform the transformation $E_1 \rightarrow E_2$. However, the exclusion of paths so as to analyze a smaller language of paths is exactly the refinement criterion used by some prior methods. 
In this paper, we develop an algorithm that takes as input a valid path expression $E$, and returns a valid path expression $E’$ that is guaranteed to yield analysis results that are at least as good as those obtained using $E$. While the algorithm sometimes returns $E$ itself, it typically does not: (i) we prove a a no-degradation result for the algorithm’s base case—for transforming a leaf loop (i.e., a most-deeply-nested loop); (ii) at a non-leaf loop $L$, the algorithm treats each loop $L’$ in the body of $L$ as an indivisible atom, and applies the leaf-loop algorithm to $L$; the no-degradation result carries over to (ii) as well. Our experiments show that the technique has a substantial impact: the loop-refinement algorithm allows the implementation of Compositional Recurrence Analysis to prove over 25% more assertions for a collection of challenging loop micro-benchmarks. 
The algorithm can be used to improve the precision of essentially any algebraic program analysis. Moreover, thanks to recent work that extends algebraic program analysis to interprocedural problems, our approach also applies to programs with recursive procedure calls (albeit this feature is not yet supported in our implementation).</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>John</first_name>
          <last_name>Cyphert</last_name>
          <affiliation>University of Wisconsin - Madison</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jason</first_name>
          <last_name>Breck</last_name>
          <affiliation>University of Wisconsin - Madison</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zachary</first_name>
          <last_name>Kincaid</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.princeton.edu/~zkincaid</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/zacharykincaid/a26b486e-94a5-45f1-a8b3-9a2221495ff7/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Reps</last_name>
          <affiliation>University of Wisconsin - Madison and GrammaTech, Inc.</affiliation>
          <bio>Thomas W. Reps is the J. Barkley Rosser Professor &amp;amp; Rajiv and Ritu Batra Chair in the Computer Sciences Department of the University of Wisconsin, which he joined in 1985. Reps is the author or co-author of four books and more than one hundred seventy-five papers describing his research (see http://pages.cs.wisc.edu/~reps/). His work has concerned a wide variety of topics, including program slicing, dataflow analysis, pointer analysis, model checking, computer security, code instrumentation, language-based program-development environments, the use of program profiling in software testing, software renovation, incremental algorithms, and attribute grammars. 
His collaboration with Professor Tim Teitelbaum at Cornell University from 1978 to 1985 led to the creation of two systems—the Cornell Program Synthesizer and the Synthesizer Generator—that explored how to build interactive programming tools that incorporate knowledge about the programming language being supported. The systems that they created were similar to modern program-development environments, such as Microsoft Visual Studio and Eclipse, but pre-dated them by more than two decades. Reps is President of GrammaTech, Inc., which he and Teitelbaum founded in 1988 to commercialize this work. 
At Wisconsin, Professor Reps and collaborator Professor Susan Horwitz carried out many investigations of program slicing and its applications in software engineering. Reps’s most recent work concerns program analysis, computer security, and software model checking. 
In 1996, Reps served as a consultant to DARPA to help them plan a project aimed at reducing the impact of the Year 2000 Problem on the U.S. Department of Defense. In 2003, he served on the F/A-22 Avionics Advisory Team, which provided advice to the U.S. Department of Defense about problems uncovered during integration testing of the plane’s avionics software. 
Professor Reps received his Ph.D. in Computer Science from Cornell University in 1982. His Ph.D. dissertation won the 1983 ACM Doctoral Dissertation Award. 
Reps’s 1988 paper on interprocedural slicing, with Susan Horwitz and his then-student David Binkley, was selected as one of the 50 most influential papers from the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), 1979-99. According to Google Scholar, the 1988 paper and the subsequent journal version have received over 1,780 citations. 
His 2004 paper about analysis of assembly code, with his student Gogul Balakrishnan, received the ETAPS Best-Paper Award for 2004 from the European Association for Programming Languages and Systems (EAPLS). His 2008 paper about a system for generating static analyzers for machine instructions, with his student Junghee Lim, received the ETAPS Best-Paper Award for 2008 from EAPLS. In 2010, his 1984 paper “The Synthesizer Generator,” with Tim Teitelbaum, received an ACM SIGSOFT Retrospective Impact Paper Award. In 2011, his 1994 paper “Speeding up slicing,” with Susan Horwitz, Mooly Sagiv, and Genevieve Rosay, also received an ACM SIGSOFT Retrospective Impact Paper Award. 
Four of his students, Gogul Balakrishnan, Akash Lal, Junghee Lim, and Aditya Thakur, have been recipients of the Outstanding Graduate Student Research Award given by the University of Wisconsin Computer Sciences Department. Akash Lal was also a co-recipient of the 2009 SIGPLAN Outstanding Doctoral Dissertation Award, and he was named as one of the 18 awardees selected for the 2011 India TR-35 list (top innovators under 35). 
Reps has also been the recipient of an NSF Presidential Young Investigator Award (1986), a Packard Fellowship (1988), a Humboldt Research Award (2000), and a Guggenheim Fellowship (2000). He is also an ACM Fellow (2005). In 2013, Reps was elected a foreign member of Academia Europaea. 
Reps has held visiting positions at the Institut National de Recherche en Informatique et en Automatique (INRIA) in Rocquencourt, France (1982-83), the University of Copenhagen, Denmark (1993-94), the Consiglio Nazionale delle Ricerche in Pisa, Italy (2000-2001), and the University Paris Diderot—Paris 7 (2007-2008).</bio>
          <homepage_url>http://pages.cs.wisc.edu/~reps/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/thomasreps/bc5323a6-d318-42c9-a136-d3252ecda280/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5232d66b-13e9-454c-8c01-bca4cd024bc2</slot_id>
      <title>Skeletal Semantics and their Interpretations</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/18</date>
      <start_time>11:19</start_time>
      <end_time>11:41</end_time>
      <description>Many meta-languages have been proposed for writing rule-based operational semantics, in order to provide general interpreters and analysis tools. We take a different approach. We develop a meta-language for a skeletal semantics of a language, where each skeleton describes the complete semantic behaviour of a language construct. We define a general notion of interpretation, which provides a systematic and language-independent way of deriving semantic judgements from the skeletal semantics. We provide four generic interpretations of our skeletal semantics to yield: a simple well-formedness interpretation; a concrete interpretation; an abstract interpretation; and a constraint generator for flow-sensitive analysis. We prove general consistency results, establishing that the concrete and abstract interpretations are consistent and that any solution to the constraints generated by the constraint generator must be a correct abstract semantics.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Martin</first_name>
          <last_name>Bodin</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cmm.uchile.cl/~mbodin/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/martinbodin/712ff297-d09b-4533-977a-64732ee314b7/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Philippa</first_name>
          <last_name>Gardner</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~pg/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Thomas P.</first_name>
          <last_name>Jensen</last_name>
          <affiliation>INRIA Rennes</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.irisa.fr/celtique/jensen/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/thomaspjensen/88563f7d-114a-474a-aa4d-4eb39db60f73/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Alan</first_name>
          <last_name>Schmitt</last_name>
          <affiliation>Inria</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>8402bbeb-b40c-4545-a7a3-be9879e1e784</slot_id>
      <title>Concerto: A Framework for Combined Concrete and Abstract Interpretation</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/18</date>
      <start_time>10:57</start_time>
      <end_time>11:19</end_time>
      <description>Abstract interpretation promises sound but computable static summarization of program behavior. However, modern software engineering practices pose significant challenges to this vision, specifically the extensive use of frameworks and complex libraries. Frameworks heavily use reflection, metaprogramming, and multiple layers of abstraction, all of which confound even state-of-the-art abstract interpreters. Sound but conservative analysis of frameworks is impractically imprecise, and unsoundly ignoring reflection and metaprogramming is untenable given the prevalence of these features. Manually modeling framework behaviors offers excellent precision, at the cost of immense effort by the tool designer. 
To overcome the above difficulties, we present Concerto, a system for analyzing framework-based applications by soundly combining concrete and abstract interpretation. Concerto analyzes framework implementations using concrete interpretation, and application code using abstract interpretation. This technique is possible in practice as framework implementations typically follow a single path of execution when provided a concrete, application-specific configuration file which is often available at analysis time. Concerto exploits this configuration information to precisely resolve reflection and other metaprogramming idioms during concrete execution. In contrast, application code may have infinitely many paths of execution, so Concerto switches to abstract interpretation to analyze application code. Concerto is an analysis framework, and can be instantiated with any abstract interpretation that satisfies a small set of preconditions. In addition, unlike manual modeling, Concerto is not specialized to any specific framework implementation. We have formalized our approach and proved several important properties including soundness and termination. In addition, we have implemented an initial proof of concept prototype of Concerto for a subset of Java, and found that our combined interpretation significantly improves analysis precision and performance.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>John</first_name>
          <last_name>Toman</last_name>
          <affiliation>University of Washington, Seattle</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homes.cs.washington.edu/~jtoman/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/johntoman/b96b7e33-0284-497c-929f-685641104e39/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dan</first_name>
          <last_name>Grossman</last_name>
          <affiliation>University of Washington</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homes.cs.washington.edu/~djg/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/dangrossman/941e0321-e962-4f03-9027-ba9f0448e7df/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b0865be3-e5e8-476c-be08-2d4f10031247</slot_id>
      <title>A$^2$I: Abstract$^2$ Interpretation</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/18</date>
      <start_time>10:35</start_time>
      <end_time>10:57</end_time>
      <description>The fundamental idea of Abstract$^2$ Interpretation (A$^2$I), also called meta-abstract interpretation, is to apply abstract interpretation to abstract inter-pre-ta-tion-based static program analyses. A$^2$I is generally meant to use abstract interpretation to analyse properties of program analysers. A$^2$I can be either offline or online. Offline A$^2$I is performed either before the program analysis, such as variable packing used by the Astrée program analyser, or after the program analysis, such as in alarm diagnosis. Online A$^2$I is performed during the program analysis, such as Venet’s cofibred domains or Halbwachs et al.’s and Singh et al.’s variable partitioning techniques for fast polyhedra/numerical abstract domains. We formalize offline and online meta-abstract interpretation and illustrate this notion with the design of widenings and the decomposition of relational abstract domains to speed-up program analyses. This shows how novel static analyses can be extracted as meta-abstract interpretations to design efficient and precise program analysis algorithms.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Patrick</first_name>
          <last_name>Cousot</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/patrickcousot/50da3bbd-9abd-43af-a7cf-4143b412f4f3/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Roberto</first_name>
          <last_name>Giacobazzi</last_name>
          <affiliation>University of Verona and IMDEA Software Institute</affiliation>
          <bio>Roberto Giacobazzi received the Laurea degree in Computer Science in 1988 from the University of Pisa, and in 1993 he received the Ph.D. in Computer Science from the same university, with a Ph.D. thesis on Semantic aspects of logic program analysis, under the supervision of Prof. Giorgio Levi. From 1993 to 1995 he had a Post Doctoral Research position at Laboratoire d’Informatique (LIX), Ecole Polytechnique (Paris) in the equipe Cousot. From 1995 to 1998 he was (tenured) Assistant Professor in Computer Science at the University of Pisa. From May 2000 until now he is Full Professor in Computer Science at the University of Verona. The research interests of Roberto Giacobazzi include abstract interpretation, static program analysis, semantics of programming languages, program verification, abstract model-checking, program transformation and optimization, digital asset protection, code obfuscation, malware detection, software watermarking, computability and lattice theory. He has been Program Chair of SAS, VMCAI, of workshops in programming languages and language based security, and General Chair of ACM POPL2013. From 2006 to 2012 he has been Dean of the College of Science of the University of Verona. He works at the University of Verona and at IMDEA Software Institute.</bio>
          <homepage_url>http://profs.sci.univr.it/~giaco/index.html</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/robertogiacobazzi/3a292abe-6f69-4d5d-bfa3-305417b39cba/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Francesco</first_name>
          <last_name>Ranzato</last_name>
          <affiliation>University of Padova</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.math.unipd.it/~ranzato/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/francescoranzato/319b8e10-9d08-4060-889f-c55067c7ffed/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8a629dc0-5ed5-413b-bcdd-79a8da542258</subevent_id>
    <title>POPL Research Papers: Monday Lunch</title>
    <timeslot>
      <slot_id>13372569-c6e5-42b0-9eb9-0f1c2de3e573</slot_id>
      <title>Session: POPL Research Papers - Monday Lunch</title>
      <room>Hotel Cascais Miragem | Lunch Room</room>
      <date>2019/01/14</date>
      <start_time>12:30</start_time>
      <end_time>14:00</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Lunch Room</room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>d5043426-2863-463b-a396-9a17f182a413</slot_id>
      <title>Lunch</title>
      <room>Hotel Cascais Miragem | Lunch Room</room>
      <date>2019/01/14</date>
      <start_time>12:30</start_time>
      <end_time>14:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>cc396344-4b11-43a7-b315-0e93b085c06c</subevent_id>
    <title>POPL Research Papers: Probabilistic Programming and Semantics</title>
    <timeslot>
      <slot_id>6c8e225a-60bc-495d-b13f-7b570fe682ff</slot_id>
      <title>Session: POPL Research Papers - Probabilistic Programming and Semantics</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/16</date>
      <start_time>13:45</start_time>
      <end_time>14:51</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala I</room>
    <date>2019/01/16</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>273f6003-f12e-4cff-b0f9-69be288a9d90</slot_id>
      <title>Probabilistic Programming with Densities in SlicStan: Efficient, Flexible and Deterministic</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/16</date>
      <start_time>13:45</start_time>
      <end_time>14:07</end_time>
      <description>Stan is a probabilistic programming language that has been increasingly used for real-world scalable projects. However, to make practical inference possible, the language sacrifices some of its usability by adopting a block syntax, which lacks compositionality and flexible user-defined functions. Moreover, the semantics of the language has been mainly given in terms of intuition about implementation, and has not been formalised. 
This paper provides a formal treatment of the Stan language, and introduces the probabilistic programming language SlicStan — a compositional, self-optimising version of Stan. Our main contributions are: (1) the formalisation of a core subset of Stan through an operational density-based semantics; (2) the design and semantics of the Stan-like language SlicStan, which facilities better code reuse and abstraction through its compositional syntax, more flexible functions, and information-flow type system; and (3) a formal, semantic-preserving procedure for translating SlicStan to Stan.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Maria I.</first_name>
          <last_name>Gorinova</last_name>
          <affiliation>The University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/s1207807/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andrew D.</first_name>
          <last_name>Gordon</last_name>
          <affiliation>Microsoft Research and University of Edinburgh</affiliation>
          <bio>I am a Principal Researcher at Microsoft Research, Cambridge, where I manage Programming Principles and Tools. As a part-time position, I also hold the Chair in Computer Security and am a member of the Laboratory for Foundations of Computer Science and the Security and Privacy group in the School of Informatics in the University of Edinburgh. I convene the University of Edinburgh Microsoft Research Joint Initiative in Informatics. I participate in the Data Science PhD programme. My current research is on probabilistic programming for machine learning.</bio>
          <homepage_url>https://www.microsoft.com/en-us/research/people/adg/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/andrewdgordon/6a7c06a4-cf70-4529-ad02-55b979e93f82/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Charles</first_name>
          <last_name>Sutton</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>Charles Sutton is a Reader (equivalent to Associate Professor: http://bit.ly/1W9UhqT) in Machine Learning at the University of Edinburgh. He is interested in a broad range of applications of probabilistic machine learning, including NLP, analysis of computer systems, software engineering, sustainable energy, and exploratory data analysis. His work in software engineering has won an ACM Distinguished Paper Award. His PhD is from the University of Massachusetts Amherst, and he has done postdoctoral work at the University of California Berkeley. He is currently Director of the EPSRC Centre for Doctoral Training in Data Science at the University of Edinburgh, and a Faculty Fellow of the Alan Turing Institute.</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/csutton/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/charlessutton/989c5bc2-7291-4058-9b50-518b6e04d87b/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4c72148c-e710-4b6e-ac01-3a79a05fe090</slot_id>
      <title>Bayesian Synthesis of Probabilistic Programs for Automatic Data Modeling</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/16</date>
      <start_time>14:29</start_time>
      <end_time>14:51</end_time>
      <description>We present new techniques for automatically constructing probabilistic programs for data analysis, interpretation, and prediction. These techniques work with probabilistic domain-specific data modeling languages that capture key properties of a broad class of data generating processes, using Bayesian inference to synthesize probabilistic programs in these modeling languages given observed data. We provide a precise formulation of Bayesian synthesis for automatic data modeling that identifies sufficient conditions for the resulting synthesis procedure to be sound. We also derive a general class of synthesis algorithms for domain-specific languages specified by probabilistic context-free grammars and establish the soundness of our approach for these languages. We apply the techniques to automatically synthesize probabilistic programs for time series data and multivariate tabular data. We show how to analyze the structure of the synthesized programs to compute, for key qualitative properties of interest, the probability that the underlying data generating process exhibits each of these properties. Second, we translate probabilistic programs in the domain-specific language into probabilistic programs in Venture, a general-purpose probabilistic programming system. The translated Venture programs are then executed to obtain predictions of new time series data and new multivariate data records. Experimental results show that our techniques can accurately infer qualitative structure in multiple real-world data sets and outperform standard data analysis methods in forecasting and predicting new data.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Feras</first_name>
          <last_name>Saad</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://fsaad.mit.edu</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/ferassaad/b74984fe-f070-4ab4-a808-a34ad2982d6f/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marco</first_name>
          <last_name>Cusumano-Towner</last_name>
          <affiliation>MIT-CSAIL</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/marcocusumanotowner/3b4efb1b-50ef-4c96-8fce-6b0ca3a032c6/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ulrich</first_name>
          <last_name>Schaechtle</last_name>
          <affiliation>Massachusetts Institute of Technology, USA</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Martin</first_name>
          <last_name>Rinard</last_name>
          <affiliation>Massachusetts Institute of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://people.csail.mit.edu/rinard/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/martinrinard/cc4278df-192e-490f-87e5-a0649c420584/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Vikash</first_name>
          <last_name>Mansingkha</last_name>
          <affiliation>MIT</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c2772fe8-1d2c-4241-8d5f-546d58e6539a</slot_id>
      <title>A Domain Theory for Statistical Probabilistic Programming</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/16</date>
      <start_time>14:07</start_time>
      <end_time>14:29</end_time>
      <description>We give an adequate denotational semantics for languages with recursive higher-order types, continuous probability distributions, and soft constraints. These are expressive languages for building Bayesian models of the kinds used in computational statistics and machine learning. Among them are untyped languages, similar to Church and WebPPL, because our semantics allows recursive mixed-variance datatypes. Our semantics justifies important program equivalences including commutativity. 
Our new semantic model is based on `quasi-Borel predomains’. These are a mixture of chain-complete partial orders (cpos) and quasi-Borel spaces. Quasi-Borel spaces are a recent model of probability theory that focuses on sets of admissible random elements. Probability is traditionally treated in cpo models using probabilistic powerdomains, but these are not known to be commutative on any class of cpos with higher order functions. By contrast, quasi-Borel predomains do support both a commutative probabilistic powerdomain and higher-order functions. As we show, quasi-Borel predomains form both a model of Fiore’s axiomatic domain theory and a model of Kock’s synthetic measure theory.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matthijs</first_name>
          <last_name>Vákár</last_name>
          <affiliation>University of Oxford</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/matthijsvakar/41a8f9d6-0c06-4001-99a9-fb316abcf3ac/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ohad</first_name>
          <last_name>Kammar</last_name>
          <affiliation>University of Oxford</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ox.ac.uk/people/ohad.kammar/main.html</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/ohadkammar/1336a5cb-4d72-49de-898d-ce768d425a55/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Sam</first_name>
          <last_name>Staton</last_name>
          <affiliation>University of Oxford</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ox.ac.uk/people/samuel.staton/main.html</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f6ac9158-99ef-4b9d-a788-7f3ae056a379</subevent_id>
    <title>POPL Research Papers: Semantics</title>
    <timeslot>
      <slot_id>1836976f-f24b-4b42-a9b3-ad6e5d472781</slot_id>
      <title>Session: POPL Research Papers - Semantics</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/18</date>
      <start_time>13:45</start_time>
      <end_time>14:51</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala I</room>
    <date>2019/01/18</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>16bd72b8-3b0a-4ab9-888a-a25bff11fa9a</slot_id>
      <title>Fixpoint Games on Continuous Lattices</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/18</date>
      <start_time>14:29</start_time>
      <end_time>14:51</end_time>
      <description>Many analysis and verifications tasks, such as static program analyses and model-checking for temporal logics, reduce to the solution of systems of equations over suitable lattices. Inspired by recent work on lattice-theoretic progress measures, we develop a game-theoretical approach to the solution of systems of monotone equations over lattices, where for each single equation either the least or greatest solution is taken. A simple parity game, referred to as fixpoint game, is defined that provides a correct and complete characterisation of the solution of systems of equations over continuous lattices, a quite general class of lattices widely used in semantics. For powerset lattices the fixpoint game is intimately connected with classical parity games for $\mu$-calculus model-checking, whose solution can exploit as a key tool Jurdziński’s small progress measures. We show how the notion of progress measure can be naturally generalised to fixpoint games over continuous lattices and we prove the existence of small progress measures. Our results lead to a constructive formulation of progress measures as (least) fixpoints. We refine this characterisation by introducing the notion of selection that allows one to constrain the plays in the parity game, enabling an effective (and possibly efficient) solution of the game, and thus of the associated verification problem. We also propose a logic for specifying the moves of the existential player that can be used to systematically derive simplified equations for efficiently computing progress measures. We discuss potential applications to the model-checking of latticed $\mu$-calculi.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Paolo</first_name>
          <last_name>Baldan</last_name>
          <affiliation>University of Padova</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.math.unipd.it/~baldan</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/paolobaldan/74ce6038-7d9f-47e9-bd84-724fc0253f29/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Barbara</first_name>
          <last_name>Koenig</last_name>
          <affiliation>University of Duisburg-Essen</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Christina</first_name>
          <last_name>Mika-Michalski</last_name>
          <affiliation>University of Duisburg-Essen</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tommaso</first_name>
          <last_name>Padoan</last_name>
          <affiliation>University of Padova</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>894fe3ab-989a-4f60-b579-4de7617d0611</slot_id>
      <title>Diagrammatic Algebra: From Linear to Concurrent Systems</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/18</date>
      <start_time>14:07</start_time>
      <end_time>14:29</end_time>
      <description>We introduce the resource calculus, a string diagrammatic language for concurrent systems. Significantly, it uses the same syntax and operational semantics as the signal flow calculus — an algebraic formalism for signal flow graphs, which is a combinatorial model of computation of interest in control theory. Indeed, our approach stems from the simple but fruitful realisation that, by replacing real numbers (modelling signals) with natural numbers (modelling resources) in the operational semantics, concurrent behaviour patterns emerge. 
The resource calculus is canonical: we equip it and its stateful extension with equational theories that characterise the underlying space of definable behaviours—a convex algebraic universe of additive relations— via isomorphisms of categories. Finally, we demonstrate that our calculus is sufficiently expressive to capture behaviour definable by classical Petri nets.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Filippo</first_name>
          <last_name>Bonchi</last_name>
          <affiliation>University of Pisa</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Holland</last_name>
          <affiliation>University of Southampton</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Robin</first_name>
          <last_name>Piedeleu</last_name>
          <affiliation>University of Oxford</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Pawel</first_name>
          <last_name>Sobocinski</last_name>
          <affiliation>University of Southampton</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Fabio</first_name>
          <last_name>Zanasi</last_name>
          <affiliation>University College London</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a5ede2c7-b5c8-4657-b44a-0fe6c0dc9868</slot_id>
      <title>Better Late Than Never: A Fully Abstract Semantics for Classical Processes</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/18</date>
      <start_time>13:45</start_time>
      <end_time>14:07</end_time>
      <description>We present Hypersequent Classical Processes (HCP), a revised interpretation of the “Proofs as Processes” correspondence between linear logic and the π-calculus initially proposed by Abramsky [1994], and later developed by Bellin and Scott [1994], Caires and Pfenning [2010], and Wadler [2014], among others. HCP mends the discrepancies between linear logic and the syntax and observable semantics of parallel composition in the π-calculus, by conservatively extending linear logic to hyperenvironments (collections of environments, inspired by the hypersequents by Avron [1991]). Separation of environments in hyperenvironments is internalised by ⊗ and corresponds to parallel process behaviour. Thanks to this property, for the first time we are able to extract a labelled transition system (lts) semantics from proof rewritings. Leveraging the information on parallelism at the level of types, we obtain a logical reconstruction of the delayed actions that Merro and Sangiorgi [2004] formulated to model non-blocking I/O in the π-calculus. We define a denotational semantics for processes based on Brzozowski derivatives, and uncover that non-interference in HCP corresponds to Fubini’s theorem of double antiderivation. Having an lts allows us to validate HCP using the standard toolbox of behavioural theory. We instantiate bisimilarity and barbed congruence for HCP, and obtain a full abstraction result: bisimilarity, denotational equivalence, and barbed congruence coincide.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Wen</first_name>
          <last_name>Kokke</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://wenkokke.github.io/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/wenkokke/756e11ff-851e-4355-865b-0b5ce896d4af/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Fabrizio</first_name>
          <last_name>Montesi</last_name>
          <affiliation>University of Southern Denmark</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.fabriziomontesi.com/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/fabriziomontesi/34014925-283c-4ab8-8911-dffe711259c5/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Marco</first_name>
          <last_name>Peressotti</last_name>
          <affiliation>University of Southern Denmark</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/marcoperessotti/458312a8-da11-44ef-bb09-290c5209a93c/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2ff25d40-9738-4e10-9c1f-37cdd447ca9a</subevent_id>
    <title>POPL Research Papers: Type Abstraction and Effects</title>
    <timeslot>
      <slot_id>ba3a2e51-a7b0-4d90-8c34-7b1708df3be6</slot_id>
      <title>Session: POPL Research Papers - Type Abstraction and Effects</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/17</date>
      <start_time>09:00</start_time>
      <end_time>10:06</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala I</room>
    <date>2019/01/17</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>2f6b5088-60c0-4287-acb1-51937b2371b2</slot_id>
      <title>Abstracting Algebraic Effects</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/17</date>
      <start_time>09:22</start_time>
      <end_time>09:44</end_time>
      <description>Proposed originally by Plotkin and Pretnar, algebraic effects and their handlers are a leading-edge approach to computational effects: exceptions, mutable state, nondeterminism, and such. Appreciated for their elegance and expressiveness, they are now progressing into mainstream functional programming languages. In this paper, we introduce and examine programming language constructs that back adoption of programming with algebraic effects on a larger scale in a modular fashion by providing mechanisms for abstraction. We propose two such mechanisms: existential effects (which hide the details of a particular effect from the user) and local effects (which guarantee that no code coming from the outside can interfere with a given effect). The main technical difficulty arises from the dynamic nature of coupling an effectful operation with the right handler during execution, but, as we show in this paper, a carefully designed type system can ensure that this will not break the abstraction. Our main contribution is a novel calculus for algebraic effects and handlers, called $\lambda^{\textsf{HEL}}$, equipped with local and existential algebraic effects, in which the dynamic nature of handlers is kept in check by typed runtime coercions. As a proof of concept, we present an experimental programming language based on our calculus, which provides strong abstraction mechanisms via an ML-style module system.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Dariusz</first_name>
          <last_name>Biernacki</last_name>
          <affiliation>University of Wrocław</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Maciej</first_name>
          <last_name>Piróg</last_name>
          <affiliation>University of Wrocław</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ii.uni.wroc.pl/~mpirog/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/maciejpirog/6d35caec-bf73-4a63-b16b-9ee7f05d2a71/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Piotr</first_name>
          <last_name>Polesiuk</last_name>
          <affiliation>University of Wrocław</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Filip</first_name>
          <last_name>Sieczkowski</last_name>
          <affiliation>University of Wrocław</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/filipsieczkowski/798bba62-e2ef-466f-8548-ab13f479cd83/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>7b0e470a-8a87-4933-97f0-868f2af085b3</slot_id>
      <title>Fully Abstract Module Compilation</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/17</date>
      <start_time>09:44</start_time>
      <end_time>10:06</end_time>
      <description>We give a translation suitable for compilation of modern module calculi supporting sealing, generativity, translucent signatures, applicative functors, higher-order functors and/or first-class modules. Ours is the first module-compilation translation with a dynamic correctness theorem. The theorem states that the translation produces target terms that are contextually equivalent to the source, in an appropriate sense. A corollary of the theorem is that the translation is fully abstract. Consequently, the translation preserves all abstraction present in the source. In passing, we also show that modules are a definitional extension of the underlying core language. All of our proofs are formalized in Coq.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Karl</first_name>
          <last_name>Crary</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a8f5a342-a0ba-430e-a718-b11f426b1a16</slot_id>
      <title>Abstraction-Safe Effect Handlers via Tunneling</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/17</date>
      <start_time>09:00</start_time>
      <end_time>09:22</end_time>
      <description>Algebraic effect handlers offer a unified approach to expressing control-flow transfer idioms such as exceptions, iteration, and async/await. Unfortunately, previous attempts to make these handlers type-safe have failed to support the fundamental principle of modular reasoning for higher-order abstractions. We demonstrate that abstraction-safe algebraic effect handlers are possible by giving them a new semantics. The key insight is that code should only handle effects it is aware of. In our approach, the type system guarantees all effects are handled, but it is impossible for higher-order, effect-polymorphic code to accidentally handle effects raised by functions passed in; such effects tunnel through the higher-order, calling procedures polymorphic to them. By contrast, the possibility of accidental handling threatens previous designs for algebraic effect handlers. We prove that our design is not only type-safe, but also abstraction-safe. Using a logical-relations model that we prove sound with respect to contextual equivalence, we derive previously unattainable program equivalence results. Our mechanism offers a viable approach for future language designs aiming for effect handlers with strong abstraction guarantees.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yizhou</first_name>
          <last_name>Zhang</last_name>
          <affiliation>Cornell University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cornell.edu/~yizhou/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/yizhouzhang/0629b9fd-c9c0-44e9-ac08-6760a0b35950/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Andrew</first_name>
          <last_name>Myers</last_name>
          <affiliation>Cornell University</affiliation>
          <bio>Andrew Myers is a Professor in the Department of Computer Science at Cornell University in Ithaca, NY. His research interests include programming languages, computer security, and distributed and persistent programming systems. Myers is an ACM Fellow. He has received awards for papers appearing in POPL’99, SOSP’01, SOSP’07, CIDR’13, PLDI’13, and PLDI’15. Myers is currently the Editor-in-Chief for ACM Transactions on Programming Languages and Systems (TOPLAS). He has also served as program chair or co-chair for a few conferences: ACM POPL 2018, ACM CCS 2016, POST 2014, IEEE CSF 2010, and IEEE S&amp;amp;P 2009.</bio>
          <homepage_url>http://www.cs.cornell.edu/andru</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/andrewmyers/88baadd2-5ed8-4687-b205-3cbbe8b1a848/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9364437e-3b63-4a4e-a361-b2669413b5bf</subevent_id>
    <title>POPL Research Papers: Security and Information Flow</title>
    <timeslot>
      <slot_id>1cd8b349-5ca7-4f0c-aeea-f6373b961120</slot_id>
      <title>Session: POPL Research Papers - Security and Information Flow</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/18</date>
      <start_time>15:21</start_time>
      <end_time>16:27</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala I</room>
    <date>2019/01/18</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>1a507feb-1c03-4768-9f17-9f3a6931e2b6</slot_id>
      <title>From Fine- to Coarse-Grained Dynamic Information Flow Control and Back</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/18</date>
      <start_time>15:43</start_time>
      <end_time>16:05</end_time>
      <description>We show that fine-grained and coarse-grained dynamic information-flow control (IFC) systems are equally expressive. To this end, we mechanize two mostly standard languages, one with a fine-grained dynamic IFC system and the other with a coarse-grained dynamic IFC system, and prove a semantics-preserving translation from each language to the other. In addition, we derive the standard security property of non-interference of each language from that of the other, via our verified translation. This result addresses a longstanding open problem in IFC: whether coarse-grained dynamic IFC techniques are less expressive than fine-grained dynamic IFC techniques (they are not!). The translations also stand to have important implications on the usability of IFC approaches. The coarse- to fine-grained direction can be used to remove the label annotation burden that fine-grained systems impose on developers, while the fine- to coarse-grained translation shows that coarse-grained systems—which are easier to design and implement—can track information as precisely as fine-grained systems and provides an algorithm for automatically retrofitting legacy applications to run on existing coarse-grained systems.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Marco</first_name>
          <last_name>Vassena</last_name>
          <affiliation>Chalmers University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.chalmers.se/~vassena/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/marcovassena/1b41c477-ee4e-430f-a5d4-dadc8bef377f/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alejandro</first_name>
          <last_name>Russo</last_name>
          <affiliation>Chalmers University of Technology, Sweden</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cse.chalmers.se/~russo/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/alejandrorusso/4304fb98-9fc5-4dd8-95c1-8fa2ca83765d/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Deepak</first_name>
          <last_name>Garg</last_name>
          <affiliation>Max Planck Institute for Software Systems</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-sws.org/~dg</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/deepakgarg/2a70fd29-76c7-4771-98ce-7d8c591f4e69/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Vineet</first_name>
          <last_name>Rajani</last_name>
          <affiliation>MPI-SWS</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Deian</first_name>
          <last_name>Stefan</last_name>
          <affiliation>University of California San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cseweb.ucsd.edu/~dstefan/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/deianstefan/55e73d29-9671-4740-9ef2-3b45f485fc24/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>912aac3d-2df6-4c08-b057-81865ff03402</slot_id>
      <title>LWeb: Information Flow Security for Multi-Tier Web Applications</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/18</date>
      <start_time>15:21</start_time>
      <end_time>15:43</end_time>
      <description>This paper presents LWeb, a framework for enforcing label-based, information flow policies in database-using web applications. In a nutshell, LWeb marries the LIO Haskell IFC enforcement library with the Yesod web programming framework. The implementation has two parts. First, we extract the core of LIO into a monad transformer (LMonad) and then apply it to Yesod’s core monad. Second, we extend Yesod’s table definition DSL and query functionality to permit defining and enforcing label-based policies on tables and enforcing them during query processing. LWeb’s policy language is expressive, permitting dynamic per-table and per-row policies. We formalize the essence of LWeb in the $\lambda_{\mathit{LWeb}}$ calculus and mechanize the proof of noninterference in Liquid Haskell. This mechanization constitutes the first metatheoretic proof carried out in Liquid Haskell. We also used LWeb to build a substantial web site hosting the Build it, Break it, Fix it security-oriented programming contest. The site involves 40 data tables and sophisticated policies. Compared to manually checking security policies, LWeb imposes a modest runtime overhead of between 2% to 21%. It reduces the trusted code base from the whole application to just 1% of the application code, and 21% of the code overall (when counting LWeb too).</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>James</first_name>
          <last_name>Parker</last_name>
          <affiliation>University of Maryland</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Niki</first_name>
          <last_name>Vazou</last_name>
          <affiliation>IMDEA Software Institute</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://nikivazou.github.io/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/nikivazou/8cc6ddec-154b-47e9-b40d-c66e78476391/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Michael</first_name>
          <last_name>Hicks</last_name>
          <affiliation>University of Maryland, College Park</affiliation>
          <bio>Michael Hicks is a Professor in the Computer Science department and UMIACS at the University of Maryland, where he co-directs the laboratory for Programming Languages research (PLUM); he is the former Director of the Maryland Cybersecurity Center (MC2). 
His research focuses on using programming languages and analyses to improve the security, reliability, and availability of software. He is perhaps best known for his work exploring dynamic software updating, which is a technique by which software can be updated without shutting it down. He has explored the design of new programming languages and analysis tools for helping programmers find bugs and software vulnerabilities, and for identifying suspicious or incorrect program executions. 
His recent work has combined ideas from PL and cryptography, e.g., to ensure privacy preserving computations. He also leads the development of a new security-oriented programming contest, “build-it, break-it, fix-it,” which has been offered to the public and to students in his Coursera class on software security. He is the co-editor of the Programming Languages Enthusiast blog and Tweets at @michael_w_hicks.</bio>
          <homepage_url>http://www.cs.umd.edu/~mwh/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/michaelhicks/aa64e3c6-3516-4e13-affe-77bc32c40565/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>affd3032-1ecb-402f-b987-7f30cae133aa</slot_id>
      <title>Modalities, Cohesion, and Information Flow</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/18</date>
      <start_time>16:05</start_time>
      <end_time>16:27</end_time>
      <description>It is informally understood that the purpose of modal type constructors in programming calculi is to control the flow of information between types. In order to lend rigorous support to this idea, we study the category of classified sets, a variant of a denotational semantics for information flow proposed by Abadi et al. We use classified sets to prove multiple noninterference theorems for modalities of a monadic and comonadic flavour. The common machinery behind our theorems stems from the the fact that classified sets are a (weak) model of Lawvere’s theory of axiomatic cohesion. In the process, we show how cohesion can be used for reasoning about multi-modal settings. This leads to the conclusion that cohesion is a particularly useful setting for the study of both information flow, but also modalities in type theory and programming languages at large.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>G. A.</first_name>
          <last_name>Kavvos</last_name>
          <affiliation>Wesleyan University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.lambdabetaeta.eu</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>0293151f-a02a-4874-9055-1fa576282f19</subevent_id>
    <title>POPL Research Papers: Program Analysis II</title>
    <timeslot>
      <slot_id>f2411cad-5091-4c3c-a6b8-661f374b4dff</slot_id>
      <title>Session: POPL Research Papers - Program Analysis II</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/18</date>
      <start_time>16:37</start_time>
      <end_time>17:43</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala II</room>
    <date>2019/01/18</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>3736fc60-5266-4440-8255-70d2ac077ed7</slot_id>
      <title>Efficient Parameterized Algorithms for Data Packing</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/18</date>
      <start_time>16:59</start_time>
      <end_time>17:21</end_time>
      <description>There is a huge gap between the speeds of modern caches and main memories, and therefore cache misses account for a considerable loss of efficiency in programs. The predominant technique to address this issue has been Data Packing: data elements that are frequently accessed within time proximity are packed into the same cache block, thereby minimizing accesses to the main memory. We consider the algorithmic problem of Data Packing on a two-level memory system. Given a reference sequence $R$ of accesses to data elements, the task is to partition the elements into cache blocks such that the number of cache misses on $R$ is minimized. The problem is notoriously difficult: it is NP-hard even when the cache has size $1$, and is hard to approximate for any cache size larger than $4$. Therefore, all existing techniques for Data Packing are based on heuristics and lack theoretical guarantees. 
In this work, we present the first positive theoretical results for Data Packing, along with new and stronger negative results. We consider the problem under the lens of the underlying access hypergraphs, which are hypergraphs of affinities between the data elements, where the order of an access hypergraph corresponds to the size of the affinity group. We study the problem parameterized by the treewidth of access hypergraphs, which is a standard notion in graph theory to measure the closeness of a graph to a tree. Our main results are as follows: we show that there is a number $q^$ depending on the cache parameters such that (a) if the access hypergraph of order $q^$ has constant treewidth, then there is a linear-time algorithm for Data Packing; (b) the Data Packing problem remains NP-hard even if the access hypergraph of order $q^-1$ has constant treewidth. Thus, we establish a fine-grained dichotomy depending on a single parameter, namely, the highest order among access hypegraphs that have constant treewidth; and establish the optimal value $q^$ of this parameter. 
Finally, we present an experimental evaluation of a prototype implementation of our algorithm. Our results demonstrate that, in practice, access hypergraphs of many commonly-used algorithms have small treewidth. We compare our approach with several state-of-the-art heuristic-based algorithms and show that our algorithm leads to significantly fewer cache-misses.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Krishnendu</first_name>
          <last_name>Chatterjee</last_name>
          <affiliation>IST Austria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pub.ist.ac.at/~kchatterjee/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Amir</first_name>
          <last_name>Kafshdar Goharshady</last_name>
          <affiliation>IST Austria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pub.ist.ac.at/~akafshda/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Nastaran</first_name>
          <last_name>Okati</last_name>
          <affiliation>Ferdowsi University of Mashhad</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Andreas</first_name>
          <last_name>Pavlogiannis</last_name>
          <affiliation>EPFL, Switzerland</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9a21dbbd-54eb-4b15-9d9a-3caf0a88945a</slot_id>
      <title>Fast and exact analysis for LRU caches</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/18</date>
      <start_time>17:21</start_time>
      <end_time>17:43</end_time>
      <description>For applications in worst-case execution time analysis and in security, it is desirable to statically classify memory accesses into those that result in cache hits, and those that result in cache misses. Among cache replacement policies, the least recently used (LRU) policy has been studied the most and is considered to be the most predictable. 
The state-of-the-art in LRU cache analysis presents a tradeoff between precision and analysis efficiency: The classical approach to analyzing programs running on LRU caches, an abstract interpretation based on an range abstraction, is very fast but can be imprecise. An exact analysis was recently presented, but, as a last resort, it calls a model checker, which is expensive. 
In this paper, we develop an analysis based on abstract interpretation that comes close to the efficiency of the classical approach, while achieving exact classification of all memory accesses as the model-checking approach. Compared with the model-checking approach we observe speedups of several orders of magnitude. As a secondary contribution we show that LRU cache analysis problems are in general NP-complete.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Valentin</first_name>
          <last_name>Touzeau</last_name>
          <affiliation>Univ. Grenoble Alpes</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Claire</first_name>
          <last_name>Maiza</last_name>
          <affiliation>Verimag, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www-verimag.imag.fr/~maiza/spip</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>David</first_name>
          <last_name>Monniaux</last_name>
          <affiliation>CNRS, VERIMAG</affiliation>
          <bio>David Monniaux obtained his PhD in 2001 in Paris under Prof Patrick Cousot; his dissertation was on the static analysis of probabilistic programs by abstract interpretation. He then joined CNRS as a junior researcher and first worked on the Astrée static analyzer, still in Paris. In 2007 he transferred to VERIMAG in Grenoble, where he works on various aspects of program verification (decision procedures, abstract interpretation…). 
He now is a senior researcher at CNRS and an adjunct professor at École polytechnique.</bio>
          <homepage_url>http://www-verimag.imag.fr/~monniaux/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/davidmonniaux/d285baca-8e32-4918-b3c6-c724e98fc7b3/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jan</first_name>
          <last_name>Reineke</last_name>
          <affiliation>Saarland University</affiliation>
          <bio>Jan Reineke is a professor of computer science at Saarland University. Before joining Saarland University in 2012, he has been a postdoctoral scholar at UC Berkeley in the Ptolemy group from 2009 to 2011. He completed his MSc and PhD in Computer Science at Saarland University in 2005 and 2008, respectively, and his BSc in Computing Science at the University of Oldenburg in 2003. 
His research interests include static analysis by abstract interpretation with applications to the verification of cyber-physical systems, static timing analysis, shape analysis, and side-channel analysis. He is also interested in automatic methods to obtain faithful models of microarchitectures and in the design of timing-predictable microarchitectures for use in hard real-time systems. 
In 2012, he was selected as an Intel Early Career Faculty Honor Program awardee. He was the PC chair of EMSOFT 2014, the International Conference on Embedded Software, a Topic co-chair at DATE 2016 and the PC chair of WCET 2017, the International Workshop on Worst-Case Execution Time Analysis. His papers have been awarded 5 outstanding paper awards and one best-paper nomination at conferences including RTSS and ECRTS.</bio>
          <homepage_url>http://embedded.cs.uni-saarland.de/reineke.php</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e6b3b91b-c7f4-4642-9e25-898564fefabc</slot_id>
      <title>Efficient Automated Repair of High Floating-Point Errors in Numerical Libraries</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/18</date>
      <start_time>16:37</start_time>
      <end_time>16:59</end_time>
      <description>Floating point computation is by nature inexact, and numerical libraries that intensively involve floating-point computations may encounter high floating-point errors. Due to the wide use of numerical libraries, it is highly desired to reduce high floating-point errors in them. Using higher precision will degrade performance and may also introduce extra errors for certain precision-specific operations in numerical libraries. Using mathematical rewriting that mostly focuses on rearranging floating-point expressions or taking Taylor expansions may not fit for reducing high floating-point errors evoked by ill-conditioned problems that are in the nature of the mathematical feature of many numerical programs in numerical libraries. 
In this paper, we propose a novel approach for efficient automated repair of high floating-point errors in numerical libraries. Our main idea is to make use of the mathematical feature of a numerical program for detecting and reducing high floating-point errors. The key components include a detecting method based on two algorithms for detecting high floating-point errors and a repair method for deriving an approximation of a mathematical function to generate patch to satisfy a given repair criterion. We implement our approach by constructing a new tool called AutoRNP. Our experiments are conducted on 20 numerical programs in GNU Scientific Library (GSL). Experimental results show that our approach can efficiently repair (with $100%$ accuracy over all randomly sampled points) high floating-point errors for 19 of the 20 numerical programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Xin</first_name>
          <last_name>Yi</last_name>
          <affiliation>National University of Defense Technology</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Liqian</first_name>
          <last_name>Chen</last_name>
          <affiliation>National University of Defense Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://lqchen.github.io/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Xiaoguang</first_name>
          <last_name>Mao</last_name>
          <affiliation>National University of Defense Technology</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Tao</first_name>
          <last_name>Ji</last_name>
          <affiliation>National University of Defense Technology</affiliation>
          <bio>PhD student</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>23e2d670-0968-4aff-a564-58d1f8031d1c</subevent_id>
    <title>POPL Research Papers: Verified Compilation and Concurrency</title>
    <timeslot>
      <slot_id>f4def2a6-6494-40e9-84e6-3f5e95c8ad23</slot_id>
      <title>Session: POPL Research Papers - Verified Compilation and Concurrency</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/18</date>
      <start_time>16:37</start_time>
      <end_time>17:43</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala I</room>
    <date>2019/01/18</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>6d56c4be-5dfd-440f-be9b-5d4ac8b9733b</slot_id>
      <title>A Calculus for Esterel: If can, can. If no can, no can.</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/18</date>
      <start_time>16:37</start_time>
      <end_time>16:59</end_time>
      <description>The language Esterel has found success in many safety-critical applications, such as fly-by-wire systems and nuclear power plant control software. Its imperative style is natural to programmers building such systems and its precise semantics makes it work well for reasoning about programs. 
Existing semantics of Esterel generally fall into two categories: translation to Boolean circuits, or operational semantics that give a procedure for running a whole program. In contrast, equational theories enable reasoning about program behavior via equational rewrites at the source level. Such theories form the basis for proofs of transformations inside compilers or for program refactorings, and defining program evaluation syntactically. 
This paper presents the first such equational calculus for Esterel. It also illustrates the calculus’s usefulness with a series of example equivalences and discuss how it enabled us to find bugs in Esterel implementations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Spencer P.</first_name>
          <last_name>Florence</last_name>
          <affiliation>Northwestern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://florence.io/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/spencerpflorence/e3e98e1c-983d-4d21-bce9-d9bd196711ba/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Shu-Hung</first_name>
          <last_name>You</last_name>
          <affiliation>Northwestern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://eecs.northwestern.edu/u/shu-hung.you/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Jesse A.</first_name>
          <last_name>Tov</last_name>
          <affiliation>Northwestern University, Department of Electrical Engineering and Computer Science</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Robby</first_name>
          <last_name>Findler</last_name>
          <affiliation>Northwestern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.eecs.northwestern.edu/~robby/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/robbyfindler/1c5789be-fa0c-482b-a237-e7e575ac257e/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>78f3e04d-cb3b-4068-9ded-01bc64e9d588</slot_id>
      <title>A Verified, Efficient Embedding of a Verifiable Assembly Language</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/18</date>
      <start_time>17:21</start_time>
      <end_time>17:43</end_time>
      <description>High-performance cryptographic libraries often mix code written in a high-level language with code written in assembly. To support formally verifying the correctness and security of such hybrid programs, this paper presents an embedding of a subset of x64 assembly language in F* that allows efficient verification of both assembly and its interoperation with C code generated from F*. The key idea is to use the computational power of a dependent type system’s type checker to run a verified verification-condition generator during type checking. This allows the embedding to customize the verification condition sent by the type checker to an SMT solver. By combining our proof-by-reflection style with SMT solving, we demonstrate improved automation for proving the correctness of assembly-language code. This approach has allowed us to complete the first-ever proof of correctness of an optimized implementation of AES-GCM, a cryptographic routine used by 90% of secure Internet traffic.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aymeric</first_name>
          <last_name>Fromherz</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nick</first_name>
          <last_name>Giannarakis</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.princeton.edu/~ng8</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/nickgiannarakis/e0437606-eed1-41d3-8eb7-bba7cb8fc111/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Chris</first_name>
          <last_name>Hawblitzel</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.microsoft.com/en-us/research/people/chrishaw/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/chrishawblitzel/cccf2ce8-1bc7-4e25-9838-ba9084f596b0/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Bryan</first_name>
          <last_name>Parno</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Aseem</first_name>
          <last_name>Rastogi</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.microsoft.com/en-us/research/people/aseemr/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/aseemrastogi/60be692f-f2e1-4eef-ac4a-85f7accdba8e/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Nikhil</first_name>
          <last_name>Swamy</last_name>
          <affiliation>Microsoft Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://research.microsoft.com/~nswamy</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/nikhilswamy/fcdbbbd2-b390-4c57-a305-b77c7386f260/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fb55bc43-b14a-4a6b-8a2b-4b1a5fc3357c</slot_id>
      <title>An Abstract Stack Based Approach to Verified Compositional Compilation to Machine Code</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/18</date>
      <start_time>16:59</start_time>
      <end_time>17:21</end_time>
      <description>A key ingredient contributing to the success of CompCert, the state-of-the-art verified compiler for C, is its block-based memory model, which is used uniformly for all of its languages and their verified compilation. However, CompCert’s memory model lacks an explicit notion of stack. Its target assembly language represents the runtime stack as an unbounded list of memory blocks, making further compilation of CompCert assembly into more realistic machine code difficult since it is not possible to merge these blocks into a finite and continuous stack. Furthermore, various notions of verified compositional compilation rely on some kind of mechanism for protecting private stack data and enabling modification to the public stack-allocated data, which is lacking in the original CompCert. These problems have been investigated but not fully addressed before, in the sense that some advanced optimization passes that significantly change the ways stack blocks are (de-)allocated, such as tailcall recognition and inlining, are often omitted. 
We propose a lightweight and complete solution to the above problems. It is based on the enrichment of CompCert’s memory model with an abstract stack that keeps track of the history of stack frames to bound the stack consumption and that enforces a uniform stack access policy by assigning fine-grained permissions to stack memory. Using this enriched memory model for all the languages of CompCert, we are able to reprove the correctness of the full compilation chain of CompCert, including all the optimization passes. In the end, we get Stack-Aware CompCert, a complete extension of CompCert that enforces the finiteness of the stack and fine-grained stack permissions. 
Based on Stack-Aware CompCert, we develop CompCertMC, the first extension of CompCert that compiles into a low-level language with flat memory spaces. Based on CompCertMC, we develop Stack-Aware CompCertX, a complete extension of CompCert that supports a notion of compositional compilation that we call contextual compilation by exploiting the uniform stack access policy provided by the abstract stack.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yuting</first_name>
          <last_name>Wang</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.yale.edu/homes/wang-yuting/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Pierre</first_name>
          <last_name>Wilke</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Zhong</first_name>
          <last_name>Shao</last_name>
          <affiliation>Yale University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.yale.edu/homes/shao/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/zhongshao/18a2973a-020f-46ed-9073-85bd70626116/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>ac21ba12-416f-443a-881e-e3f5b1617dd0</subevent_id>
    <title>POPL Research Papers: Program Analysis I</title>
    <timeslot>
      <slot_id>1d222634-e53b-4bba-8203-d0ce9936a305</slot_id>
      <title>Session: POPL Research Papers - Program Analysis I</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/18</date>
      <start_time>15:21</start_time>
      <end_time>16:27</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala II</room>
    <date>2019/01/18</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>0a593d17-cee5-43fa-86bb-1dc2fca17682</slot_id>
      <title>Decidable Verification of Uninterpreted Programs</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/18</date>
      <start_time>15:21</start_time>
      <end_time>15:43</end_time>
      <description>We study the problem of completely automatically verifying uninterpreted programs— programs that work over arbitrary data models that provide an interpretation for the constants, functions and relations the program uses. The verification problem asks whether a given program satisfies a postcondition written using quantifier-free formulas with equality on the final state, with no loop invariants, contracts, etc. being provided. We show that this problem is undecidable in general. The main contribution of this paper is a subclass of programs, called coherent programs that admits decidable verification, and can be decided in PSPACE. We then extend this class of programs to classes of programs that are k-coherent, where k is a natural number, obtained by (automatically) adding k ghost variables and assignments that make them coherent. We also extend the decidability result to programs with recursive function calls and prove several undecidability results that show why our restrictions to obtain decidability seem necessary.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Umang</first_name>
          <last_name>Mathur</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://umathur3.web.engr.illinois.edu</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/umangmathur/3f83afaf-6ef3-41c4-9599-b35a06186d73/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>P.</first_name>
          <last_name>Madhusudan</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://madhu.cs.illinois.edu</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/pmadhusudan/3775a90b-eb5d-4825-86d8-2a91a1e68fdf/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Mahesh</first_name>
          <last_name>Viswanathan</last_name>
          <affiliation>University of Illinois at Urbana-Champaign</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>bd5b0065-e919-4d15-8fd5-bad2afc47316</slot_id>
      <title>Context-, Flow- and Field-Sensitive Data-Flow Analysis using Synchronized Pushdown Systems</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/18</date>
      <start_time>16:05</start_time>
      <end_time>16:27</end_time>
      <description>Precise static analyses are context-, field- and flow-sensitive. Context- and field-sensitivity are both expressible as context-free language (CFL) reachability problems. Solving both CFL problems along the same data-flow path is undecidable, which is why most flow-sensitive data-flow analyses over-approximate field-sensitivity through k-limited access-path, or through access graphs. Unfortunately, as our experience and this paper show, both representations do not scale very well when used to analyze programs with recursive data structures. 
Any single CFL-reachablity problem is efficiently solvable, by means of a pushdown system. This work thus introduces the concept of synchronized pushdown systems (SPDS). SPDS encode both procedure calls/returns and field stores/loads as separate but synchronized CFL reachability problems. An SPDS solves both individual problems precisely, and approximation occurs only in corner cases that are apparently rare in practice: at statements where both problems are satisfied but not along the same data-flow path. 
SPDS are also efficient: formal complexity analysis shows that SPDS shift the complexity from |F|^{3k} under $k$-limiting to |S||F|^2, where F is the set of fields and S the set of statements involved in a data-flow. Our evaluation using DaCapo shows this shift to pay off in practice: SPDS are almost as efficient as k-limiting with k=1 although their precision equals the case k is infinite. For a typestate analysis SPDS accelerate the analysis up to 83x for data-flows of objects that involve many field accesses but span rather few methods. 
We conclude that SPDS can provide high precision and further improve scalability, in particularly when used in analyses that expose rather local data flows.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Johannes</first_name>
          <last_name>Späth</last_name>
          <affiliation>Fraunhofer IEM</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.johspaeth.de</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/johannesspath/d1badf6e-21bc-40b7-ad61-77db02919168/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Karim</first_name>
          <last_name>Ali</last_name>
          <affiliation>University of Alberta</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://karimali.ca</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/karimali/460ecc0b-764d-462b-a93e-66a3270d72ef/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Eric</first_name>
          <last_name>Bodden</last_name>
          <affiliation>Heinz Nixdorf Institut, Paderborn University and Fraunhofer IEM</affiliation>
          <bio>Eric Bodden is one of the leading experts on secure software engineering, with a specialty in building highly precise tools for automated program analysis. He is Professor for Software Engineering at Paderborn University and co-director of Fraunhofer IEM. Further, he is a member of the directorate of the Collaborative Research Center CROSSING at TU Darmstadt. 
At Fraunhofer IEM, Bodden is heading the Attract-Group on Secure Software Engineering. In this function he is developing code analysis technology for security, in collaboration with the leading national and international software development companies. In 2014, the DFG awarded Bodden the Heinz Maier-Leibnitz-Preis. In 2013, BITKOM elected him into their mentoring program BITKOM Management Club. 
Bodden is one of the chief maintainers of the Soot program analysis and optimization framework, a contributor to the AspectBench Compiler, the open research compiler for AspectJ, the inventor of the Clara and TamiFlex frameworks. Together with his research group, he has created the FlowDroid analysis framework for Android and the DroidBench benchmark suite.</bio>
          <homepage_url>http://www.bodden.de/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/ericbodden/b948ca2e-c54b-474c-be50-fb796d2b6d02/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>fab714a8-be2d-4eac-a578-7c0aa22c7701</slot_id>
      <title>Inferring frame conditions with static correlation analysis</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/18</date>
      <start_time>15:43</start_time>
      <end_time>16:05</end_time>
      <description>We introduce the abstract domain of correlations to denote equality relations between parts of inputs and outputs of programs. We formalise the theory of correlations, and mechanically verify their semantic properties. We design a static inter-procedural dataflow analysis for automatically inferring correlations for programs written in a first-order language equipped with algebraic data-types and arrays. The analysis, its precision and execution cost, have been evaluated on the code and functional specification of an industrial-size micro-kernel. We exploit the inferred correlations to automatically discharge two thirds of the proof obligations related to the preservation of invariants for this micro-kernel.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Oana-Fabiana</first_name>
          <last_name>Andreescu</last_name>
          <affiliation>Internet of Trust</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Thomas P.</first_name>
          <last_name>Jensen</last_name>
          <affiliation>INRIA Rennes</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.irisa.fr/celtique/jensen/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/thomaspjensen/88563f7d-114a-474a-aa4d-4eb39db60f73/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Stéphane</first_name>
          <last_name>Lescuyer</last_name>
          <affiliation>Prove &amp; Run</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Benoît</first_name>
          <last_name>Montagu</last_name>
          <affiliation>Prove &amp; Run</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>58aca39a-c5fd-43af-bffd-d450d82f0d39</subevent_id>
    <title>POPL Research Papers: Capabilities and Session Types I</title>
    <timeslot>
      <slot_id>0a43c80f-6605-4989-9706-26bcd48c7b9b</slot_id>
      <title>Session: POPL Research Papers - Capabilities and Session Types I</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/16</date>
      <start_time>15:21</start_time>
      <end_time>16:27</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala II</room>
    <date>2019/01/16</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>40e4d662-6e8b-4c23-aa4e-66d5d9ea176d</slot_id>
      <title>Two sides of the same coin: Session Types and Game Semantics</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/16</date>
      <start_time>15:43</start_time>
      <end_time>16:05</end_time>
      <description>Game semantics and session types are two formalisations of the same concept: message-passing open programs following certain protocols. Game semantics represents protocols as games, and programs as strategies; while session types specify protocols, and well-typed pi-calculus processes model programs. Giving faithful models of the pi-calculus and giving a precise description of strategies as a programming language are two fundamental, but notoriously hard problems. In this paper, we show how these two problems can be tackled at the same time by building an accurate game semantics model of the session pi-calculus. 
Our main contribution is to fill a semantic gap between the synchrony of the (session) pi-calculus and the asynchrony of game semantics, by developing an event-structure based game semantics for synchronous concurrent computation. This model supports the first truly concurrent fully abstract (for barbed congruence) interpretation of the synchronous (session) pi-calculus. We further strengthen this correspondence, establishing finite definability of asynchronous strategies by the internal session pi-calculus. As an application of these results, we propose an faithful encoding of synchronous strategies into asynchronous strategies by call-return protocols, which induces automatically an encoding at the level of processes. Our results bring session types and game semantics into the same picture, proposing the session calculus as a programming language for strategies, and the strategies as a very accurate model of the session calculus. We implement a prototype which computes the interpretation of session processes as synchronous strategies.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Simon</first_name>
          <last_name>Castelan</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Nobuko</first_name>
          <last_name>Yoshida</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/nobukoyoshida/a9ea01da-964f-4c83-965d-6ae91079fc37/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>64b06f96-ba1b-489c-b612-14fabadd8ea9</slot_id>
      <title>StkTokens: Enforcing Well-Bracketed Control Flow and Stack Encapsulation Using Linear Capabilities</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/16</date>
      <start_time>15:21</start_time>
      <end_time>15:43</end_time>
      <description>We propose and study StkTokens: a new calling convention that provably enforces well-bracketed control flow and local state encapsulation on a capability machine. The calling convention is based on linear capabilities: a type of capabilities that are prevented from being duplicated by the hardware. In addition to designing and formalizing this new calling convention, we also contribute a new way to formalize and prove that it effectively enforces well-bracketed control flow and local state encapsulation using what we call a fully abstract overlay semantics.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Lau</first_name>
          <last_name>Skorstengaard</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/lauskorstengaard/6a1a6472-515b-41d4-943f-7de81373ecb3/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dominique</first_name>
          <last_name>Devriese</last_name>
          <affiliation>Vrije Universiteit Brussel, Belgium</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://soft.vub.ac.be/~dodevrie/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/dominiquedevriese/08b1fc2d-d157-4905-9c9a-e1ff279ab345/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Lars</first_name>
          <last_name>Birkedal</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.au.dk/~birke/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a782977f-00f7-47f3-9334-838e79ba528b</slot_id>
      <title>Exceptional Asynchronous Session Types: Session Types without Tiers</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/16</date>
      <start_time>16:05</start_time>
      <end_time>16:27</end_time>
      <description>Session types statically guarantee that communication complies with a protocol. However, most accounts of session typing do not account for failure, which means they are of limited use in real applications—especially distributed applications—where failure is pervasive. 
We present the first formal integration of asynchronous session types with exception handling in a functional programming language. We define a core calculus which satisfies preservation and progress properties, is deadlock free, confluent, and terminating. 
We provide the first implementation of session types with exception handling for a fully-fledged functional programming language, by extending the Links web programming language; our implementation draws on existing work on effect handlers. We illustrate our approach through a running example of two-factor authentication, and a larger example of a session-based chat application where communication occurs over session-typed channels and disconnections are handled gracefully.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Simon</first_name>
          <last_name>Fowler</last_name>
          <affiliation>The University of Edinburgh</affiliation>
          <bio>PhD student at the University of Edinburgh.</bio>
          <homepage_url>http://www.simonjf.com</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/simonfowler/8da87b62-b333-4c60-ac4a-27594510d4b1/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sam</first_name>
          <last_name>Lindley</last_name>
          <affiliation>University of Edinburgh, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homepages.inf.ed.ac.uk/slindley</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/samlindley/144f1f69-c839-48e3-8ba4-58a84018aa48/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>J. Garrett</first_name>
          <last_name>Morris</last_name>
          <affiliation>University of Kansas, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://jgbm.github.io</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/jgarrettmorris/bfd0d5b6-e65e-403e-882f-089258565ed5/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Sara</first_name>
          <last_name>Décova</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6496d43c-e507-4f6c-b414-053de1df48da</subevent_id>
    <title>POPL Research Papers: Welcome &amp; Keynote I</title>
    <timeslot>
      <slot_id>57bfadd7-103d-47b6-bc26-ee3808cc7d5f</slot_id>
      <title>Session: POPL Research Papers - Welcome &amp; Keynote I</title>
      <room>Hotel Cascais Miragem | Sala I + II</room>
      <date>2019/01/16</date>
      <start_time>09:00</start_time>
      <end_time>10:05</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala I + II</room>
    <date>2019/01/16</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>5c50b693-d588-4c7a-866f-f172c11586db</slot_id>
      <title>Welcome</title>
      <room>Hotel Cascais Miragem | Sala I + II</room>
      <date>2019/01/16</date>
      <start_time>09:00</start_time>
      <end_time>09:05</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>General Chair</role>
          <sort_key>1</sort_key>
          <first_name>Fritz</first_name>
          <last_name>Henglein</last_name>
          <affiliation>Department of Computer Science, University of Copenhagen (DIKU)</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.diku.dk/~henglein</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/fritzhenglein/4984918d-01be-497a-b867-fbf1a77100e8/small.jpg</picture_url>
        </person>
        <person>
          <role>PC Chair</role>
          <sort_key>2</sort_key>
          <first_name>Stephanie</first_name>
          <last_name>Weirich</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cis.upenn.edu/~sweirich/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/stephanieweirich/1f63ace9-e52a-4efc-b20b-ee75b5d7d091/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f7479e0f-0c44-45eb-bce7-0bdae6238fe1</slot_id>
      <title>Automated Fault-Finding and Fixing at Facebook</title>
      <room>Hotel Cascais Miragem | Sala I + II</room>
      <date>2019/01/16</date>
      <start_time>09:05</start_time>
      <end_time>10:05</end_time>
      <description>This talk will describe the deployment of Sapienz, a system for automated test case design that uses Search Based Software Engineering (SBSE) and which has been deployed at Facebook since October 2017 to design test cases, localise and triage faults to developers and to monitor their fixes (and, since August 2018, also to automate the process of fixing some of these faults). The talk will also cover the way in which we combine static and dynamic analysis for fault-finding and fixing at Facebook, concluding with a discussion of some open problems for static and dynamic analysis and challenges in deploying them at scale. This keynote is an account of the joint work of the whole Sapienz team and its partners and collaborators at Facebook.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Mark</first_name>
          <last_name>Harman</last_name>
          <affiliation>Facebook and University College London</affiliation>
          <bio>Mark Harman is an engineering manager at Facebook London, where he manages the Sapienz team, working on Search Based Software Engineering (SBSE) for automated test case design and fault fixing. Sapienz has been deployed to continuously test Facebook’s Android and iOS apps, leading to thousands of bugs being automatically found and fixed (mostly by developers, but more recently, some of these faults have also been automatically fixed by Sapienz). The software tackled by Sapienz consists of tens of millions of lines of code; apps that are among the largest and most complex in the app store and that are used by over a billion people worldwide every day for communication, social networking and community building. Mark is also a part time professor of Software Engineering in the Department of Computer Science at University College London, where he directed the CREST centre for ten years (2006-2017) and was Head of Software Systems Engineering (2012-2017). He is known for his scientific work on SBSE, source code analysis, software testing, app store analysis and empirical software engineering. He was the co-founder of the field SBSE, which has grown rapidly with over 1,700 scientific publications from authors spread over more than 40 countries. SBSE research and practice is now the primary focus of his current work in both the industrial and scientific communities. In addition to Facebook itself, Mark’s scientific work is also supported by an ERC advanced fellowship grant and by the UK EPSRC funding council.</bio>
          <homepage_url>http://www0.cs.ucl.ac.uk/staff/M.Harman/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/markharman/7be6a7bb-dfb2-49cc-8879-270bd1bbcf2f/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>532badf5-2d3a-48e9-8083-376955ee7721</subevent_id>
    <title>POPL Research Papers: Type Inference II</title>
    <timeslot>
      <slot_id>bc7eb677-3bc1-476e-a3d7-cc75697f9914</slot_id>
      <title>Session: POPL Research Papers - Type Inference II</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/17</date>
      <start_time>15:21</start_time>
      <end_time>16:49</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala I</room>
    <date>2019/01/17</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>004870a1-d64e-49f5-aa52-43d48989daf7</slot_id>
      <title>Dynamic Type Inference for Gradual Hindley–Milner Typing</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/17</date>
      <start_time>15:21</start_time>
      <end_time>15:43</end_time>
      <description>Garcia and Cimini study a type inference problem for the ITGL, an implicitly and gradually typed language with let-polymorphism, and develop a sound and complete inference algorithm for it. Soundness and completeness mean that, if the algorithm succeeds, the input term can be translated to a well-typed term of an explicitly typed blame calculus by cast insertion and vice versa. However, in general, there are many possible translations depending on how type variables that were left undecided by static type inference are instantiated with concrete static types. Worse, the translated terms may behave differently—some evaluate to values but others raise blame. 
In this paper, we propose and formalize a new blame calculus $\lambda^{\textsf{DTI}}{\textsf{B}}$ that avoids such divergence as an intermediate language for the ITGL. A main idea is to allow a term to contain type variables (that have not been instantiated during static type inference) and defer instantiation of these type variables to run time. We introduce dynamic type inference (DTI) into the semantics of $\lambda^{\textsf{DTI}}{\textsf{B}}$ so that type variables are instantiated along reduction. The DTI-based semantics not only avoids the divergence described above but also is sound and complete with respect to the semantics of fully instantiated terms in the following sense: if the evaluation of a term succeeds (i.e., terminates with a value) in the DTI-based semantics, then there is a fully instantiated version of the term that also succeeds in the explicitly typed blame calculus and vice versa. 
Finally, we prove the gradual guarantee, which is an important correctness criterion of a gradually typed language, for the ITGL.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Yusuke</first_name>
          <last_name>Miyazaki</last_name>
          <affiliation>Kyoto University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fos.kuis.kyoto-u.ac.jp/~miyazaki/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Taro</first_name>
          <last_name>Sekiyama</last_name>
          <affiliation>National Institute of Informatics</affiliation>
          <bio>I’m an assistant professor at National Institute of Informatics in Japan. I am interested in theory and applications of programming languages, such as type theory, program verification, type inference, program reasoning, and so on.</bio>
          <homepage_url>http://researcher.ibm.com/researcher/view.php?person=jp-SEKIYM</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/tarosekiyama/dd6fb4ca-8161-4bbd-9392-01e4b94374e6/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Atsushi</first_name>
          <last_name>Igarashi</last_name>
          <affiliation>Kyoto University, Japan</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.fos.kuis.kyoto-u.ac.jp/~igarashi/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/atsushiigarashi/bbac1695-343a-4091-b33c-b7f01dea73da/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>2c0f90dc-f518-41f0-a811-a87acb8a43df</slot_id>
      <title>Gradual Typing: A New Perspective</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/17</date>
      <start_time>15:43</start_time>
      <end_time>16:05</end_time>
      <description>We define a new, more semantic interpretation of gradual types and use it to “gradualize” two forms of polymorphism: subtyping polymorphism and implicit parametric polymorphism. 
In particular, we use the new interpretation to define two preorders on types, subtyping and materialization, and we employ these preorders to define three gradual type systems —Hindley-Milner, with subtyping, and with union and intersection types— which we present in two different forms: declaratively and algorithmically. 
The declarative presentation consists in adding two subsumption-like rules, one for each preorder, to the existing standard rules of the type system. This yields clearer, more intelligible, and streamlined definitions; it also shows a direct correlation between cast insertion and materialization that suggests a logical interpretation of the cast calculus, an essential component of gradual typing systems. For the algorithmic presentation, we show how it can be defined by using already existing constraint solving algorithms simply by adding some pre-/post-processing steps. We relate corresponding declarative and algorithmic presentations by soundness and completeness results. 
As customary, the semantics of the various gradually-typed languages is given in terms of a compilation into cast calculi that use blame labels to pinpoint cast failures. To that end, we show how to define the operational semantics for casts in the presence of unions and intersections, which is an important and far-from-obvious result. We also show a direct correlation between the safety of a cast and the “polarity” of its blame label, allowing for a simpler formulation of the so-called blame safety property.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Giuseppe</first_name>
          <last_name>Castagna</last_name>
          <affiliation>CNRS, France / University of Paris Diderot, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.irif.fr/~gc/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/giuseppecastagna/ca2a9ac8-d149-4486-87ed-b55ceb154a17/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Victor</first_name>
          <last_name>Lanvin</last_name>
          <affiliation>ENS Cachan, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.dptinfo.ens-cachan.fr/~vlanvin/en.php</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Tommaso</first_name>
          <last_name>Petrucciani</last_name>
          <affiliation>DIBRIS, Università di Genova, Italy &amp; IRIF, Université Paris Diderot, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://dibris.unige.it/petrucciani-tommaso</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/tommasopetrucciani/757aad12-2deb-4368-8683-be668c4bc957/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Jeremy G.</first_name>
          <last_name>Siek</last_name>
          <affiliation>Indiana University, USA</affiliation>
          <bio>Jeremy Siek is an Associate Professor at Indiana University Bloomington. Jeremy’s areas of research include programming language design, type systems, mechanized theorem proving using proof assistants, and optimizing compilers. Jeremy’s Ph.D. thesis explored foundations for constrained templates, aka the “concepts” proposal for C++. Prior to that, Jeremy developed the Boost Graph Library, a C++ generic library for graph algorithms and data structures. Jeremy post-doc’d at Rice University where he developed the idea of gradual typing: a type system that integrates both dynamic and static typing in the same programming language. Jeremy is currently working on several open questions regarding gradual typing. Is the polymorphic blame calculus really parametric? How should gradual typing be combined with other features such as dependent types? What is the formal criteria for gradually typed languages? Is it possible to create a high-performance implementation of a gradually-typed languages? In 2009 Jeremy received the NSF CAREER award to fund his project: “Bridging the Gap Between Prototyping and Production”. In 2010 and again in 2015, Jeremy was awarded a Distinguished Visiting Fellowship from the Scottish Informatics &amp;amp; Computer Science Alliance.</bio>
          <homepage_url>http://homes.soic.indiana.edu/jsiek/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/jeremysiek/4365edf9-715f-46e0-8867-4ea5fb6341ad/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>759fbbb1-0b48-4190-8ba7-5f7bc9e36595</slot_id>
      <title>Principality and Approximation under Dimensional Bound</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/17</date>
      <start_time>16:27</start_time>
      <end_time>16:49</end_time>
      <description>We develop an algebraic and algorithmic theory of principality for the recently introduced framework of intersection type calculi with dimensional bound. The theory enables inference of principal type information under dimensional bound, it provides an algebraic and algorithmic theory of approximation of classical principal types in terms of computable bases of abstract vector spaces (more precisely, semimodules), and it shows a systematic connection of dimensional calculi to the theory of approximants. Finite, computable bases are shown to span standard principal typings of a given term for sufficiently high dimension, thereby providing an approximation to standard principality by type inference, and capturing it precisely for sufficiently large dimensional parameter. Subsidiary results include decidability of principal inhabitation for intersection types (given a type does there exist a normal form for which the type is principal?). Remarkably, combining bounded type inference with principal inhabitation allows us to compute approximate normal forms of arbitrary terms without using beta-reduction.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Andrej</first_name>
          <last_name>Dudenhefner</last_name>
          <affiliation>Technical University Dortmund</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jakob</first_name>
          <last_name>Rehof</last_name>
          <affiliation>Technical University Dortmund</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>844c4c2d-8f9a-41a4-82c2-68e4fda042b6</slot_id>
      <title>Intersection Types and Runtime Errors in the Pi-Calculus</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/17</date>
      <start_time>16:05</start_time>
      <end_time>16:27</end_time>
      <description>We introduce a type system for the $\pi$-calculus which is designed to guarantee that typable processes are well-behaved, namely they never produce a run-time error and, even if they may diverge, there is always a chance for them to “finish their work”, i.e. to reduce to an idle process. The introduced type system is based on non-idempotent intersections, and is thus very powerful as for the class of processes it can capture. Indeed, despite the fact that the underlying property is $\Pi^0_2$-complete, there is a way to show that the system is complete, i.e., that any well-behaved process is typable, although for obvious reasons infinitely many derivations need to be considered.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Ugo</first_name>
          <last_name>Dal Lago</last_name>
          <affiliation>University of Bologna, Italy / Inria, France</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.unibo.it/~dallago/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/ugodallago/446eb4fe-dc38-4ed0-85ba-5f746abe1550/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marc</first_name>
          <last_name>De Visme</last_name>
          <affiliation>ENS Lyon</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Damiano</first_name>
          <last_name>Mazza</last_name>
          <affiliation>CNRS</affiliation>
          <bio>I am chargé de recherche (resarcher) at CNRS, working at the Laboratoire d’Informatique de Paris Nord, Université Paris 13. I’ve held this position since 2008. Previously, I was post-doc at Preuves, Programmes et Systèmes and at LIPN. I did my Ph.D. thesis (which I defended in 2006) at the Institut de Mathématiques de Luminy, in Marseille. Before that, I studied CS Engineering in Rome, Italy (which is where I am from).</bio>
          <homepage_url>http://lipn.univ-paris13.fr/~mazza</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/damianomazza/f50f3f4f-0c19-4250-9bbd-c1e3d9a275f1/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Akira</first_name>
          <last_name>Yoshimizu</last_name>
          <affiliation>INRIA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.unibo.it/~akira.yoshimizu/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>54e41838-9db9-4ce2-a471-66afe5cb71f5</subevent_id>
    <title>POPL Research Papers: Wednesday Lunch</title>
    <timeslot>
      <slot_id>c51f9a95-809a-4801-93ce-42a2670a0207</slot_id>
      <title>Session: POPL Research Papers - Wednesday Lunch</title>
      <room>Hotel Cascais Miragem | Lunch Room</room>
      <date>2019/01/16</date>
      <start_time>12:03</start_time>
      <end_time>13:45</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Lunch Room</room>
    <date>2019/01/16</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>4723a4bc-09d1-49db-98c7-aaa27e4e44d9</slot_id>
      <title>Lunch</title>
      <room>Hotel Cascais Miragem | Lunch Room</room>
      <date>2019/01/16</date>
      <start_time>12:03</start_time>
      <end_time>13:45</end_time>
      <description>undefined</description>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>8268e462-4e0e-469a-b7f4-053ba292e894</subevent_id>
    <title>POPL Research Papers: Machine Learning and Linear Algebra</title>
    <timeslot>
      <slot_id>b26b9e41-1512-4d0e-b227-8004721b6178</slot_id>
      <title>Session: POPL Research Papers - Machine Learning and Linear Algebra</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/16</date>
      <start_time>15:21</start_time>
      <end_time>16:27</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala I</room>
    <date>2019/01/16</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>1029c029-a83c-4ea5-ad37-5e6007374398</slot_id>
      <title>Closed Forms for Numerical Loops</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/16</date>
      <start_time>16:05</start_time>
      <end_time>16:27</end_time>
      <description>This paper investigates the problem of reasoning about non-linear behavior of simple numerical loops. Our approach builds on classical techniques for analyzing the behavior of linear dynamical systems. It is well-known that a closed-form representation of the behavior of a linear dynamical system can always be expressed using algebraic numbers, but such an approach can create formulas that present an obstacle for automated-reasoning tools. This paper characterizes when linear loops have closed forms in simpler theories that are more amenable to automated reasoning. The algorithms for computing closed forms described in the paper avoid the use of algebraic numbers, and produce closed forms expressed using polynomials and exponentials over rational numbers. We show that the logic for expressing closed forms is decidable, yielding decision procedures for verifying safety and termination of a class of numerical loops over rational numbers. We also show that the procedure for computing closed forms for this class of numerical loops can be used to over-approximate the behavior of arbitrary numerical programs (with unrestricted control flow, non-deterministic assignments, and recursive procedures).</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Zachary</first_name>
          <last_name>Kincaid</last_name>
          <affiliation>Princeton University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.princeton.edu/~zkincaid</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/zacharykincaid/a26b486e-94a5-45f1-a8b3-9a2221495ff7/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jason</first_name>
          <last_name>Breck</last_name>
          <affiliation>University of Wisconsin - Madison</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>John</first_name>
          <last_name>Cyphert</last_name>
          <affiliation>University of Wisconsin - Madison</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Reps</last_name>
          <affiliation>University of Wisconsin - Madison and GrammaTech, Inc.</affiliation>
          <bio>Thomas W. Reps is the J. Barkley Rosser Professor &amp;amp; Rajiv and Ritu Batra Chair in the Computer Sciences Department of the University of Wisconsin, which he joined in 1985. Reps is the author or co-author of four books and more than one hundred seventy-five papers describing his research (see http://pages.cs.wisc.edu/~reps/). His work has concerned a wide variety of topics, including program slicing, dataflow analysis, pointer analysis, model checking, computer security, code instrumentation, language-based program-development environments, the use of program profiling in software testing, software renovation, incremental algorithms, and attribute grammars. 
His collaboration with Professor Tim Teitelbaum at Cornell University from 1978 to 1985 led to the creation of two systems—the Cornell Program Synthesizer and the Synthesizer Generator—that explored how to build interactive programming tools that incorporate knowledge about the programming language being supported. The systems that they created were similar to modern program-development environments, such as Microsoft Visual Studio and Eclipse, but pre-dated them by more than two decades. Reps is President of GrammaTech, Inc., which he and Teitelbaum founded in 1988 to commercialize this work. 
At Wisconsin, Professor Reps and collaborator Professor Susan Horwitz carried out many investigations of program slicing and its applications in software engineering. Reps’s most recent work concerns program analysis, computer security, and software model checking. 
In 1996, Reps served as a consultant to DARPA to help them plan a project aimed at reducing the impact of the Year 2000 Problem on the U.S. Department of Defense. In 2003, he served on the F/A-22 Avionics Advisory Team, which provided advice to the U.S. Department of Defense about problems uncovered during integration testing of the plane’s avionics software. 
Professor Reps received his Ph.D. in Computer Science from Cornell University in 1982. His Ph.D. dissertation won the 1983 ACM Doctoral Dissertation Award. 
Reps’s 1988 paper on interprocedural slicing, with Susan Horwitz and his then-student David Binkley, was selected as one of the 50 most influential papers from the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI), 1979-99. According to Google Scholar, the 1988 paper and the subsequent journal version have received over 1,780 citations. 
His 2004 paper about analysis of assembly code, with his student Gogul Balakrishnan, received the ETAPS Best-Paper Award for 2004 from the European Association for Programming Languages and Systems (EAPLS). His 2008 paper about a system for generating static analyzers for machine instructions, with his student Junghee Lim, received the ETAPS Best-Paper Award for 2008 from EAPLS. In 2010, his 1984 paper “The Synthesizer Generator,” with Tim Teitelbaum, received an ACM SIGSOFT Retrospective Impact Paper Award. In 2011, his 1994 paper “Speeding up slicing,” with Susan Horwitz, Mooly Sagiv, and Genevieve Rosay, also received an ACM SIGSOFT Retrospective Impact Paper Award. 
Four of his students, Gogul Balakrishnan, Akash Lal, Junghee Lim, and Aditya Thakur, have been recipients of the Outstanding Graduate Student Research Award given by the University of Wisconsin Computer Sciences Department. Akash Lal was also a co-recipient of the 2009 SIGPLAN Outstanding Doctoral Dissertation Award, and he was named as one of the 18 awardees selected for the 2011 India TR-35 list (top innovators under 35). 
Reps has also been the recipient of an NSF Presidential Young Investigator Award (1986), a Packard Fellowship (1988), a Humboldt Research Award (2000), and a Guggenheim Fellowship (2000). He is also an ACM Fellow (2005). In 2013, Reps was elected a foreign member of Academia Europaea. 
Reps has held visiting positions at the Institut National de Recherche en Informatique et en Automatique (INRIA) in Rocquencourt, France (1982-83), the University of Copenhagen, Denmark (1993-94), the Consiglio Nazionale delle Ricerche in Pisa, Italy (2000-2001), and the University Paris Diderot—Paris 7 (2007-2008).</bio>
          <homepage_url>http://pages.cs.wisc.edu/~reps/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/thomasreps/bc5323a6-d318-42c9-a136-d3252ecda280/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>408ad18e-a595-4d78-bec8-38161b114794</slot_id>
      <title>An Abstract Domain for Certifying Neural Networks</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/16</date>
      <start_time>15:43</start_time>
      <end_time>16:05</end_time>
      <description>We present a novel method for scalable and precise certification of deep neural networks. The key technical insight behind our approach is a new abstract domain which combines floating point polyhedra with intervals and is equipped with abstract transformers specifically tailored to the domain of neural networks. Concretely, we introduce new transformers for the affine transform, the rectified linear unit (ReLU) activation, sigmoid, tanh, and maxpool functions. 
We implemented our method in a system called DeepPoly and evaluated it extensively on a range of datasets, neural architectures, and specifications. Our experimental results indicate that DeepPoly is more precise than prior work while scaling to large networks. We also show how to combine DeepPoly with abstraction refinement in order to prove, for the first time, robustness of the given input (e.g., an image) to complex perturbations such as rotations.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gagandeep</first_name>
          <last_name>Singh</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Timon</first_name>
          <last_name>Gehr</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Markus</first_name>
          <last_name>Püschel</last_name>
          <affiliation>ETH Zürich</affiliation>
          <bio>Markus Püschel is a Professor and former Department Head of Computer Science at ETH Zurich, Switzerland. Before, he was a Professor of Electrical and Computer Engineering at Carnegie Mellon University, where he still has an adjunct status. He received his Diploma (M.Sc.) in Mathematics and his Doctorate (Ph.D.) in Computer Science, in 1995 and 1998, respectively, both from the University of Karlsruhe, Germany.</bio>
          <homepage_url>http://people.inf.ethz.ch/markusp/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/markuspuschel/531dfe05-df8b-4f25-acb6-59ea5e4e59ea/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Martin</first_name>
          <last_name>Vechev</last_name>
          <affiliation>ETH Zürich</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.srl.inf.ethz.ch/vechev.php</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/martinvechev/4ae74bfd-22ac-4e29-a171-3fc706a85e3a/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>4be9ce3f-e467-445a-a8b2-a74283532ba7</slot_id>
      <title>code2vec: Learning Distributed Representations of Code</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/16</date>
      <start_time>15:21</start_time>
      <end_time>15:43</end_time>
      <description>We present a neural model for representing snippets of code as continuous distributed vectors (``code embeddings''). The main idea is to represent a code snippet as a single fixed-length code vector, which can be used to predict semantic properties of the snippet. This is performed by decomposing code to a collection of paths in its abstract syntax tree, and learning the atomic representation of each path simultaneously with learning how to aggregate a set of them. 
We demonstrate the effectiveness of our approach by using it to predict a method’s name from the vector representation of its body. We evaluate our approach by training a model on a dataset of 14M methods. We show that code vectors trained on this dataset can predict method names from files that were completely unobserved during training. Furthermore, we show that our model learns useful method name vectors that capture semantic similarities, combinations, and analogies. 
Comparing previous techniques over the same data set, our approach obtains a relative improvement of over 75%, being the first to successfully predict method names based on a large, cross-project, corpus. Our trained model, visualizations and vector similarities are available as an interactive online demo at http://code2vec.org. The code, data and trained models are available at https://github.com/tech-srl/code2vec.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Uri</first_name>
          <last_name>Alon</last_name>
          <affiliation>Technion</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.technion.ac.il/~urialon/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/urialon/a0488e4f-5173-472b-af25-10666c27e3d4/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Meital</first_name>
          <last_name>Zilberstein</last_name>
          <affiliation>Technion</affiliation>
          <bio>I’m a PhD student at the Computer Science Department of the Technion in Israel, working with Prof. Eran Yahav. 
My research focuses on the use of Machine and Deep Learning techniques for Programming tasks, a field we call Programming Language Processing. Our goal is to ease the life of those who write code and to increase the amount of people who can code. I also lead a R&amp;amp;D team that investigates new algorithms and technologies.</bio>
          <homepage_url>http://www.cs.technion.ac.il/~mbs</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/meitalzilberstein/f1bb4a07-3bfd-4444-985a-0dc5c23fb87a/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Omer</first_name>
          <last_name>Levy</last_name>
          <affiliation>University of Washington, USA</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Eran</first_name>
          <last_name>Yahav</last_name>
          <affiliation>Technion</affiliation>
          <bio>Eran Yahav is an associate professor at the Computer Science Department, Technion, Israel. Prior to that, he was a research staff member at the IBM T.J. Watson Research Center (2004-2010). He received his Ph.D. from Tel Aviv University (2005) and his B.Sc. from the Technion in 1996. His research interests include program analysis, program synthesis and program verification. Eran is a recipient of the prestigious Alon Fellowship for Outstanding Young Researchers, the Andre Deloro Career Advancement Chair in Engineering, the ERC Consolidator Grant as well as multiple best paper awards at various conferences.</bio>
          <homepage_url>http://www.cs.technion.ac.il/~yahave/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/eranyahav/e77d8b4b-d267-4659-969c-6542a0d385b3/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>134b2b6c-156c-438c-a475-7f4c25b41225</subevent_id>
    <title>POPL Research Papers: Model Checking</title>
    <timeslot>
      <slot_id>d521f32a-85aa-46dc-8c50-e6a9e4b59a48</slot_id>
      <title>Session: POPL Research Papers - Model Checking</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/18</date>
      <start_time>13:45</start_time>
      <end_time>14:51</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala II</room>
    <date>2019/01/18</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>6869412b-515c-4e73-a623-7c61e57e351d</slot_id>
      <title>Bounded Model Checking of Signal Temporal Logic Properties Using Syntactic Separation</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/18</date>
      <start_time>14:07</start_time>
      <end_time>14:29</end_time>
      <description>Signal temporal logic (STL) is a temporal logic formalism for specifying properties of continuous signals. STL is widely used for analyzing programs in cyber-physical systems (CPS) that interact with physical entities. However, existing methods for analyzing STL properties are incomplete even for bounded signals, and thus cannot guarantee the correctness of CPS programs. This paper presents a new symbolic model checking algorithm for CPS programs that is refutationally complete for general STL properties of bounded signals. To address the difficulties of dealing with an infinite state space over a continuous time domain, we first propose a syntactic separation of STL, which decomposes an STL formula into an equivalent formula so that each subformula depends only on one of the disjoint segments of a signal. Using the syntactic separation, an STL model checking problem can be reduced to the satisfiability of a first-order logic formula, which is decidable for CPS programs with polynomial dynamics using satisfiability modulo theories (SMT). Unlike the previous methods, our method can verify the correctness of CPS programs for STL properties up to given bounds.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kyungmin</first_name>
          <last_name>Bae</last_name>
          <affiliation>Pohang University of Science and Technology (POSTECH)</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://sevlab.postech.ac.kr/~kmbae/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/kyungminbae/90492841-67e2-4c95-a864-8470d1af9564/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jia</first_name>
          <last_name>Lee</last_name>
          <affiliation>Pohang University of Science and Technology (POSTECH)</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>a2abac4b-1927-4e6e-9f60-39b03e67880a</slot_id>
      <title>Decision Procedures for Path Feasibility of String-Manipulating Programs with Complex Operations</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/18</date>
      <start_time>13:45</start_time>
      <end_time>14:07</end_time>
      <description>The design and implementation of decision procedures for checking path feasibility in string-manipulating programs is an important problem, with such applications as symbolic executions of programs with strings and automated detection of cross-site scripting (XSS) vulnerabilities in web applications. A (symbolic) path is given as a finite sequence of assignments and assertions (i.e. without loops), and checking its feasibility amounts to determining the existence of inputs that yields a successful execution. Modern programming languages (e.g. JavaScript, PHP, and Python) support many complex string operations, and strings are also often implicitly modified during a computation in some intricate fashion (e.g. by some autoescaping mechanisms). 
In this paper we provide two general semantic conditions which together ensure the decidability of path feasibility: (1) each assertion admits regular monadic decomposition (i.e. is an effectively recognisable relation), and (2) each assignment uses a (possibly nondeterministic) function whose inverse relation preserves regularity. We show that the semantic conditions are expressive since they are satisfied by a multitude of string operations including concatenation, one-way and two-way finite-state transducers, replace-all functions (where the replacement string could contain variables), string-reverse functions, regular-expression matching, and some (restricted) forms of letter-counting/length functions. The semantic conditions also strictly subsume existing decidable string theories (e.g. straight-line fragments, and acyclic logics), and most existing benchmarks (e.g. most of Kaluza’s, and all of SLOG’s, Stranger’s, and SLOTH’s benchmarks). Our semantic conditions also yield a conceptually simple decision procedure, as well as an extensible architecture of a string solver in that a user may easily incorporate his/her own string functions into the solver by simply providing code for the pre-image computation without worrying about other parts of the solver. Despite these, the semantic conditions are unfortunately too general to provide a fast and complete decision procedure. We provide strong theoretical evidence for this in the form of complexity results.To rectify this problem, we propose two solutions. Our main solution is to allow only partial string functions (i.e., prohibit nondeterminism) in condition (2). This restriction is satisfied in many cases in practice, and yields decision procedures that are effective in both theory and practice. Whenever nondeterministic functions are still needed (e.g. the string function split), our second solution is to provide a syntactic fragment that provides a support of nondeterministic functions, and operations like one-way transducers, replace-all (with constant replacement string), the string-reverse function, concatenation, and regular-expression matching. We show that this fragment can be reduced to an existing solver SLOTH that exploits fast model checking algorithms like IC3. 
We provide an efficient implementation of our decision procedure (assuming our first solution above, i.e., deterministic partial string functions) in a new string solver OSTRICH. Our implementation provides in-built support for concatenation, reverse, transducers, and replace-all and provides a framework for extensibility to support further string functions. We demonstrate the efficacy of our new solver against other competitive solvers.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Taolue</first_name>
          <last_name>Chen</last_name>
          <affiliation>Birkbeck, University of London</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Hague</last_name>
          <affiliation>Royal Holloway, University of London</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Anthony Widjaja</first_name>
          <last_name>Lin</last_name>
          <affiliation>Oxford University</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://anthonywlin.github.io/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/anthonywidjajalin/de8e94c9-268b-45b3-9436-54dcca280b28/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Philipp</first_name>
          <last_name>Ruemmer</last_name>
          <affiliation>Uppsala University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.philipp.ruemmer.org</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/philippruemmer/c563ff7b-5e11-4bb5-85bc-e1e4cb75bf8b/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Zhilin</first_name>
          <last_name>Wu</last_name>
          <affiliation>State Key Laboratory of Computer Science, Institute of Software, Chinese Academy of Sciences</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ce37342f-cf47-49b7-b037-68a24a4fa6c9</slot_id>
      <title>Adventures in Monitorability: From Branching to Linear Time and Back Again</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/18</date>
      <start_time>14:29</start_time>
      <end_time>14:51</end_time>
      <description>This paper establishes a comprehensive theory of runtime monitorability for Hennessy-Milner logic with recursion, a very expressive variant of the modal μ-calculus. It investigates the monitorability of that logic with a linear-time semantics and then compares the obtained results with ones that were previously presented in the literature for a branching-time setting. Our work establishes an expressiveness hierarchy of monitorable fragments of Hennessy-Milner logic with recursion in a linear-time setting and exactly identifies what kinds of guarantees can be given using runtime monitors for each fragment in the hierarchy. Each fragment is shown to be complete, in the sense that it can express all properties that can be monitored under the corresponding guarantees. The study is carried out using a principled approach to monitoring that connects the semantics of the logic and the operational semantics of monitors. The proposed framework supports the automatic, compositional synthesis of correct monitors from monitorable properties.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Luca</first_name>
          <last_name>Aceto</last_name>
          <affiliation>Reykjavik University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Antonis</first_name>
          <last_name>Achilleos</last_name>
          <affiliation>Reykjavik University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Adrian</first_name>
          <last_name>Francalanza</last_name>
          <affiliation>University of Malta</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://staff.um.edu.mt/afra1/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/adrianfrancalanza/6e6d0dd9-c580-4596-abde-30e3716ea961/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Anna</first_name>
          <last_name>Ingolfsdottir</last_name>
          <affiliation>Reykjavik University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Karoliina</first_name>
          <last_name>Lehtinen</last_name>
          <affiliation>University of Kiel and University of Liverpool</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>f9eeca22-829b-4f45-9e0c-a16d3ceadd5c</subevent_id>
    <title>POPL Research Papers: Friday Lunch</title>
    <timeslot>
      <slot_id>a32800d4-0964-433c-b5ab-d88a55961190</slot_id>
      <title>Session: POPL Research Papers - Friday Lunch</title>
      <room>Hotel Cascais Miragem | Lunch Room</room>
      <date>2019/01/18</date>
      <start_time>12:03</start_time>
      <end_time>13:45</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Lunch Room</room>
    <date>2019/01/18</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>b65d3617-8ecb-4c20-98aa-b76ad0c4131a</slot_id>
      <title>Lunch</title>
      <room>Hotel Cascais Miragem | Lunch Room</room>
      <date>2019/01/18</date>
      <start_time>12:03</start_time>
      <end_time>13:45</end_time>
      <description>undefined</description>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>9fb14f2d-fc1a-45b6-86a2-1a14e9bd7a82</subevent_id>
    <title>POPL Research Papers: Sunday Lunch</title>
    <timeslot>
      <slot_id>21421e49-203a-4505-9e13-bf7289cd581c</slot_id>
      <title>Session: POPL Research Papers - Sunday Lunch</title>
      <room>Hotel Cascais Miragem | Lunch Room</room>
      <date>2019/01/13</date>
      <start_time>12:30</start_time>
      <end_time>14:00</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Lunch Room</room>
    <date>2019/01/13</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>bf86a770-4769-435d-bedf-88fa48b162fe</slot_id>
      <title>Lunch</title>
      <room>Hotel Cascais Miragem | Lunch Room</room>
      <date>2019/01/13</date>
      <start_time>12:30</start_time>
      <end_time>14:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>dcba617c-5923-4dc0-a680-a0a5c0e4fba0</subevent_id>
    <title>POPL Research Papers: Monday Social Hour</title>
    <timeslot>
      <slot_id>79b7be71-8457-44a6-b415-ca5b72c74a38</slot_id>
      <title>Session: POPL Research Papers - Monday Social Hour</title>
      <room>Hotel Cascais Miragem | Galeria</room>
      <date>2019/01/14</date>
      <start_time>17:30</start_time>
      <end_time>18:30</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Galeria</room>
    <date>2019/01/14</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>f6ebc93f-4d28-4e95-ae8b-eca455f9f945</slot_id>
      <title>Social Hour</title>
      <room>Hotel Cascais Miragem | Galeria</room>
      <date>2019/01/14</date>
      <start_time>17:30</start_time>
      <end_time>18:30</end_time>
      <description>undefined</description>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>32e14fc6-0f09-44e4-9b68-51c8e21b6606</subevent_id>
    <title>POPL Research Papers: Business Meeting</title>
    <timeslot>
      <slot_id>70b00457-782a-4286-ad42-7661f2f1de1e</slot_id>
      <title>Session: POPL Research Papers - Business Meeting</title>
      <room>Hotel Cascais Miragem | Sala I + II</room>
      <date>2019/01/17</date>
      <start_time>17:00</start_time>
      <end_time>18:00</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala I + II</room>
    <date>2019/01/17</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>096573cc-c043-4dcb-b285-4783509c836d</slot_id>
      <title>POPL 2020 Announcement</title>
      <room>Hotel Cascais Miragem | Sala I + II</room>
      <date>2019/01/17</date>
      <start_time>17:25</start_time>
      <end_time>17:30</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Presenter</role>
          <sort_key>1</sort_key>
          <first_name>Brigitte</first_name>
          <last_name>Pientka</last_name>
          <affiliation>McGill University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.mcgill.ca/~bpientka/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/brigittepientka/de1fcba2-a8fd-4b6e-a4f2-b7d397fef2cf/small.jpg</picture_url>
        </person>
        <person>
          <role>Presenter</role>
          <sort_key>2</sort_key>
          <first_name>Lars</first_name>
          <last_name>Birkedal</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.au.dk/~birke/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>33ee9ba5-c702-4f99-a936-d90c990e3553</slot_id>
      <title>PC Chair Report</title>
      <room>Hotel Cascais Miragem | Sala I + II</room>
      <date>2019/01/17</date>
      <start_time>17:00</start_time>
      <end_time>17:15</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>PC Chair</role>
          <sort_key>1</sort_key>
          <first_name>Stephanie</first_name>
          <last_name>Weirich</last_name>
          <affiliation>University of Pennsylvania, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cis.upenn.edu/~sweirich/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/stephanieweirich/1f63ace9-e52a-4efc-b20b-ee75b5d7d091/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>6031916f-9b33-4c96-a591-f9f0a9bb2e67</slot_id>
      <title>State of SIGPLAN</title>
      <room>Hotel Cascais Miragem | Sala I + II</room>
      <date>2019/01/17</date>
      <start_time>17:50</start_time>
      <end_time>18:00</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>SIGPLAN Chair</role>
          <sort_key>1</sort_key>
          <first_name>Jens</first_name>
          <last_name>Palsberg</last_name>
          <affiliation>University of California, Los Angeles (UCLA)</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.ucla.edu/~palsberg</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/jenspalsberg/9e470c6a-532d-472c-9fea-253b7fa22c7c/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c558648c-c6f1-4102-ac32-ee93836fe871</slot_id>
      <title>NSF funding for PL</title>
      <room>Hotel Cascais Miragem | Sala I + II</room>
      <date>2019/01/17</date>
      <start_time>17:30</start_time>
      <end_time>17:40</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Presenter</role>
          <sort_key>1</sort_key>
          <first_name>Rance</first_name>
          <last_name>Cleaveland</last_name>
          <affiliation>University of Maryland</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d70bcca4-d5b9-4d56-97f8-9e28228fcdaa</slot_id>
      <title>SIGPLAN Climate Committee Report</title>
      <room>Hotel Cascais Miragem | Sala I + II</room>
      <date>2019/01/17</date>
      <start_time>17:40</start_time>
      <end_time>17:50</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Presenter</role>
          <sort_key>1</sort_key>
          <first_name>Benjamin C.</first_name>
          <last_name>Pierce</last_name>
          <affiliation>University of Pennsylvania</affiliation>
          <bio>Benjamin Pierce is Henry Salvatori Professor of Computer and Information Science at the University of Pennsylvania and a Fellow of the ACM. His research interests include programming languages, type systems, language-based security, computer-assisted formal verification, differential privacy, and synchronization technologies. He is the author of the widely used graduate textbooks Types and Programming Languages and Software Foundations. He has served as co-Editor in Chief of the Journal of Functional Programming, as Managing Editor for Logical Methods in Computer Science, and as editorial board member of Mathematical Structures in Computer Science, Formal Aspects of Computing, and ACM Transactions on Programming Languages and Systems. He is also the lead designer of the popular Unison file synchronizer.</bio>
          <homepage_url>http://www.cis.upenn.edu/~bcpierce/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/benjamincpierce/f2ee6f41-5bf7-4a0d-9b8d-71de6a666b1b/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f41ffc3f-8489-4c4d-891f-c65ab3ced39a</slot_id>
      <title>SIGPLAN Awards</title>
      <room>Hotel Cascais Miragem | Sala I + II</room>
      <date>2019/01/17</date>
      <start_time>17:15</start_time>
      <end_time>17:25</end_time>
      <description>undefined</description>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>6afb998e-ec56-4486-87c7-b524631c03d9</subevent_id>
    <title>POPL Research Papers: Reasoning about Probabilistic Programs</title>
    <timeslot>
      <slot_id>2b5f82ce-8d45-4782-bbe4-1a07b86fcf50</slot_id>
      <title>Session: POPL Research Papers - Reasoning about Probabilistic Programs</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/16</date>
      <start_time>10:35</start_time>
      <end_time>12:03</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala I</room>
    <date>2019/01/16</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>b57f713c-f8ea-45dc-94ff-a70798419655</slot_id>
      <title>Trace Abstraction Modulo Probability</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/16</date>
      <start_time>11:41</start_time>
      <end_time>12:03</end_time>
      <description>We propose trace abstraction modulo probability, a proof technique for verifying high-probability accuracy guarantees of probabilistic programs. Our proofs overapproximate the set of program traces using the new notion of failure automata, finite-state automata that upper bound the probability of failing to satisfy a target specification. We automate proof construction by reducing probabilistic reasoning to logical reasoning: (i) we exploit program synthesis methods to select and instantiate axioms about sampling instructions, and then (ii) utilize Craig interpolation to show that traces failing the target specification occur with small probability. Our logical method naturally handles programs with unknown inputs, parameterized distributions, infinite state spaces, and parameterized specifications. We evaluate our technique on a range of randomized algorithms drawn from the differential privacy literature and beyond. To our knowledge, our approach is the first to be able to automatically establish accuracy properties of such sophisticated algorithms.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Calvin</first_name>
          <last_name>Smith</last_name>
          <affiliation>University of Wisconsin - Madison</affiliation>
          <bio>5th-year graduate student at UW-Madison.</bio>
          <homepage_url>http://pages.cs.wisc.edu/~cjsmith/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/calvinsmith/8ae2632c-ffa7-46b2-8e30-67769165ea83/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Justin</first_name>
          <last_name>Hsu</last_name>
          <affiliation>University of Wisconsin-Madison, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.justinh.su</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/justinhsu/a2c25b60-0dc3-48ad-a41d-238071e3fbab/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Aws</first_name>
          <last_name>Albarghouthi</last_name>
          <affiliation>University of Wisconsin-Madison</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/awsalbarghouthi/3a3382aa-47f5-4e02-ac71-509eb94703ff/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c59a6ffd-35a8-4315-a3aa-29792aea275b</slot_id>
      <title>Formal verification of higher-order probabilistic programs</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/16</date>
      <start_time>10:35</start_time>
      <end_time>10:57</end_time>
      <description>Probabilistic programming provides a convenient lingua franca for writing succinct and rigorous descriptions of probabilistic models and inference tasks. Several probabilistic programming languages, including Anglican, Church or Hakaru, derive their expressiveness from a powerful combination of continuous distributions, conditioning, and higher-order functions. Although very important for practical applications, these combined features raise fundamental challenges for program semantics and verification. Several recent works offer promising answers to these challenges, but their primary focus is on semantical issues. 
In this paper, we take a step further and we develop a set of program logics, named PPV for proving properties of programs written in an expressive probabilistic higher-order language with continuous distributions and operators for conditioning distributions by real-valued functions. Pleasingly, our program logics retain the comfortable reasoning style of informal proofs thanks to carefully selected axiomatizations of key results from probability theory. The versatility of our logics is illustrated through the formal verification of several intricate examples from statistics, probabilistic inference, and machine learning. We further show the expressiveness of our logics by giving sound embeddings of existing logics. In particular, we do this in a parametric way by showing how the semantics idea of (unary and relational) $\top\top$-lifting can be internalized in our logics. The soundness of PPV follows by interpreting programs and assertions in quasi-Borel spaces (QBS), a recently proposed variant of Borel spaces with a good structure for interpreting higher order probabilistic programs.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tetsuya</first_name>
          <last_name>Sato</last_name>
          <affiliation>University at Buffalo, SUNY, USA</affiliation>
          <bio>Dr. Tetsuya Sato is a postdoctoral associate in the Computer Science and Engineering Department, University at Buffalo, SUNY. His research interests are semantics of probabilistic programming language, formal verification, and differential privacy.</bio>
          <homepage_url>http://www.acsu.buffalo.edu/~tetsuyas/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Alejandro</first_name>
          <last_name>Aguirre</last_name>
          <affiliation>IMDEA Software Institute, Spain</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Gilles</first_name>
          <last_name>Barthe</last_name>
          <affiliation>IMDEA Software Institute</affiliation>
          <bio>Bio: Gilles Barthe received a Ph.D. in Mathematics from the University of Manchester, UK, in 1993, and an Habilitation à diriger les recherches in Computer Science from the University of Nice, France, in 2004. He joined the IMDEA Software Institute in April 2008. Previously, he was head of the Everest team on formal methods and security at INRIA Sophia-Antipolis Méditerranée, France. He also held positions at the University of Minho, Portugal; Chalmers University, Sweden; CWI, Netherlands; University of Nijmegen, Netherlands. He has published more than 100 refereed scientific papers. He has been coordinator/principal investigator of many national and European projects, and served as the scientific coordinator of the FP6 FET integrated project “MOBIUS: Mobility, Ubiquity and Security” for enabling proof-carrying code for Java on mobile devices (2005-2009). He has been a PC member of many conferences (CSF, ESORICS, FM, ICALP, ITP…), and served as PC (co-)chair of VMCAI’10, ESOP’11, FAST’11, and SEFM’11. He is a member of the editorial board of the Journal of Automated Reasoning. His research interests include formal methods, programming languages and program verification, software and system security, and cryptography, and foundations of mathematics and computer science.</bio>
          <homepage_url>http://software.imdea.org/~gbarthe/index.html</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/gillesbarthe/2df0b5e3-48a5-4e9c-8579-0ae0ce02da15/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Marco</first_name>
          <last_name>Gaboardi</last_name>
          <affiliation>University at Buffalo, SUNY</affiliation>
          <bio>Marco Gaboardi is an assistant professor in the Department of Computer Science and Engineering at the University at Buffalo, SUNY. Previously, he was a faculty at the University of Dundee, Scotland. He received his PhD from the University of Torino, Italy, and the Institute National Polytechnique de Lorraine, France. He was a visitor scholar at the University of Pennsylvania and at Harvard’s CRCS center. He has been the recipient of a EU Marie Curie Fellowship. His research is in programming languages, differential privacy, and logic.</bio>
          <homepage_url>http://www.buffalo.edu/~gaboardi</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/marcogaboardi/76ff8963-9672-4f16-87bc-3f0d75ce589b/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Deepak</first_name>
          <last_name>Garg</last_name>
          <affiliation>Max Planck Institute for Software Systems</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-sws.org/~dg</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/deepakgarg/2a70fd29-76c7-4771-98ce-7d8c591f4e69/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Justin</first_name>
          <last_name>Hsu</last_name>
          <affiliation>University of Wisconsin-Madison, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.justinh.su</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/justinhsu/a2c25b60-0dc3-48ad-a41d-238071e3fbab/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>d1840726-40e6-432d-a310-e47b2f647ea8</slot_id>
      <title>Quantitative Separation Logic - A Logic for Reasoning about Probabilistic Pointer Programs</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/16</date>
      <start_time>11:19</start_time>
      <end_time>11:41</end_time>
      <description>We present quantitative separation logic ($\mathsf{QSL}$). In contrast to classical separation logic, $\mathsf{QSL}$ employs quantities which evaluate to real numbers instead of predicates which evaluate to Boolean values. The connectives of classical separation logic, separating conjunction and separating implication, are lifted from predicates to quantities. This extension is conservative: Both connectives are backward compatible to their classical analogs and obey the same laws, e.g. modus ponens, adjointness, etc. 
Furthermore, we develop a weakest precondition calculus for quantitative reasoning about probabilistic pointer programs in $\mathsf{QSL}$. This calculus is a conservative extension of both Ishtiaq’s, O’Hearn’s, and Reynolds’ separation logic for heap-manipulating programs and Kozen’s / McIver and Morgan’s weakest preexpectations for probabilistic programs. Soundness is proven with respect to an operational semantics based on Markov decision processes. Our calculus preserves O’Hearn’s frame rule, which enables local reasoning. We demonstrate that our calculus enables reasoning about quantities such as the probability of terminating with an empty heap, the probability of reaching a certain array permutation, or the expected length of a list.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kevin</first_name>
          <last_name>Batz</last_name>
          <affiliation>RWTH Aachen University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Benjamin Lucien</first_name>
          <last_name>Kaminski</last_name>
          <affiliation>RWTH Aachen University; University College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://moves.rwth-aachen.de/people/kaminski/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Joost-Pieter</first_name>
          <last_name>Katoen</last_name>
          <affiliation>RWTH Aachen University</affiliation>
          <bio>I am full professor at the RWTH Aachen University in the Software Modeling and Verification (MOVES) group and part-time associated to the Formal Methods &amp;amp; Tools group at the University of Twente. Since 2013, I hold a distinguished professorship at RWTH Aachen University and am member of the Academia Europaea.</bio>
          <homepage_url>http://www-i2.informatik.rwth-aachen.de/~katoen/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/joostpieterkatoen/1ea5c4a0-80d3-4a86-be9a-daf5471ea24d/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Christoph</first_name>
          <last_name>Matheja</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Noll</last_name>
          <affiliation>RWTH Aachen University</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f95966a6-b4d6-48c0-b6f1-2b5a813d640b</slot_id>
      <title>A Separation Logic for Concurrent Randomized Programs</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/16</date>
      <start_time>10:57</start_time>
      <end_time>11:19</end_time>
      <description>We present a concurrent separation logic with support for probabilistic reasoning. As part of our logic, we extend the idea of coupling, which underlies recent work on probabilistic relational logics, to the setting of programs with both probabilistic and non-deterministic choice. To demonstrate our logic, we verify a variant of a randomized concurrent counter algorithm and a two-level concurrent skip list. All of our results have been mechanized in Coq.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Joseph</first_name>
          <last_name>Tassarotti</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Robert</first_name>
          <last_name>Harper</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>317dce85-d2b5-4c94-a0df-0d5869f8d224</subevent_id>
    <title>POPL Research Papers: Weak Memory</title>
    <timeslot>
      <slot_id>261be015-0e3d-4ce6-87bc-31ea74f201ff</slot_id>
      <title>Session: POPL Research Papers - Weak Memory</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/17</date>
      <start_time>13:45</start_time>
      <end_time>14:51</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala II</room>
    <date>2019/01/17</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>0aca2241-88f2-4014-bc5f-a839d8369fec</slot_id>
      <title>On Library Correctness under Weak Memory Consistency</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/17</date>
      <start_time>13:45</start_time>
      <end_time>14:07</end_time>
      <description>Concurrent libraries are the building blocks for concurrency. They encompass a range of abstractions (e.g. locks, exchangers, stacks, queues, sets) built in a layered fashion: more advanced libraries are built out of simpler ones. While there has been a lot of work on verifying such libraries in a sequentially consistent (SC) environment, little is known about how to specify and verify them under weak memory consistency (WMC). 
We propose a general declarative framework that allows us to specify concurrent libraries declaratively, and to verify library implementations against their specifications compositionally. Our framework is sufficient to encode standard models such as SC, (R)C11 and TSO. Additionally, we specify several concurrent libraries, including mutual exclusion locks, reader-writer locks, exchangers, queues, stacks and sets. We then use our framework to verify multiple weakly consistent implementations of locks, exchangers, queues and stacks.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Azalea</first_name>
          <last_name>Raad</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.SoundAndComplete.org</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/azalearaad/180ee602-475f-483f-a01b-ea187c9e8ac1/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Marko</first_name>
          <last_name>Doko</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.mpi-sws.org/~mdoko</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/markodoko/38041f27-cdcb-4b49-a06f-67f95d945dd6/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Lovro</first_name>
          <last_name>Rožić</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Ori</first_name>
          <last_name>Lahav</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~orilahav/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/orilahav/89b656f6-7634-49d1-9917-4b74da70a976/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Viktor</first_name>
          <last_name>Vafeiadis</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>Viktor Vafeiadis is a tenured faculty at the Max Planck Institute for Software Systems (MPI-SWS) in Germany. He got his BA and PhD from the University of Cambridge, and held post-doctoral researcher positions at the University of Cambridge and at Microsoft Research Cambridge before joining MPI-SWS in October 2010.</bio>
          <homepage_url>http://www.mpi-sws.org/~viktor/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/viktorvafeiadis/6a063832-47ca-4c32-8047-4bf4f74ae764/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>225d6d8a-59a8-4470-8e7d-d3051341c799</slot_id>
      <title>Bridging the Gap Between Programming Languages and Hardware Weak Memory Models</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/17</date>
      <start_time>14:07</start_time>
      <end_time>14:29</end_time>
      <description>We develop a new intermediate weak memory model, IMM, as a way of modularizing the proofs of correctness of compilation from concurrent programming languages with weak memory consistency semantics to mainstream multi-core architectures, such as POWER and ARM. We use IMM to prove the correctness of compilation from the promising semantics of Kang et al. to POWER (thereby correcting and improving their result) and ARMv7, as well as to the recently revised ARMv8 model. Our results are mechanized in Coq, and to the best of our knowledge, these are the first machine-verified compilation correctness results for models that are weaker than x86-TSO.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Anton</first_name>
          <last_name>Podkopaev</last_name>
          <affiliation>Higher School of Economics, JetBrains Research</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://podkopaev.net</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/antonpodkopaev/b00dceb2-5b55-4c0b-afe0-17581b19dfee/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ori</first_name>
          <last_name>Lahav</last_name>
          <affiliation>Tel Aviv University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.tau.ac.il/~orilahav/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/orilahav/89b656f6-7634-49d1-9917-4b74da70a976/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Viktor</first_name>
          <last_name>Vafeiadis</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>Viktor Vafeiadis is a tenured faculty at the Max Planck Institute for Software Systems (MPI-SWS) in Germany. He got his BA and PhD from the University of Cambridge, and held post-doctoral researcher positions at the University of Cambridge and at Microsoft Research Cambridge before joining MPI-SWS in October 2010.</bio>
          <homepage_url>http://www.mpi-sws.org/~viktor/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/viktorvafeiadis/6a063832-47ca-4c32-8047-4bf4f74ae764/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>53665423-765a-4a95-b97b-5dc1ca2a64ee</slot_id>
      <title>Grounding Thin-Air Reads with Event Structures</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/17</date>
      <start_time>14:29</start_time>
      <end_time>14:51</end_time>
      <description>The key challenge in defining the concurrency semantics of a programming language is how to enable the most efficient compilation to existing hardware architectures, and yet forbid programs to reading thin-air values, i.e. ones that do not appear in the program. At POPL’17, Kang et al. achieved a major breakthrough by introducing the `promising’ semantics that came with results showing that it was a good candidate solution to the problem. Unfortunately, however, the promising semantics is rather complicated, and due to its complexity it contains some flaws and limitations that are very hard to address. 
In response, we present an alternative solution to this problem based on event structures. We show that it is indeed a solution by establishing the standard results about the semantics (DRF theorems, implementation and optimization correctness) as well as a formal connection to the semantics of Kang et al. Further, we show that it is easier to adapt, by extending the semantics to cover features (such as SC accesses) that are not supported by Kang et al. and to rule out some dubious behaviors admitted by the promising semantics.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Soham</first_name>
          <last_name>Chakraborty</last_name>
          <affiliation>Max Planck Institute for Software Systems</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/sohamchakraborty/76a07359-7afc-48c5-9970-f5773e742a42/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Viktor</first_name>
          <last_name>Vafeiadis</last_name>
          <affiliation>MPI-SWS, Germany</affiliation>
          <bio>Viktor Vafeiadis is a tenured faculty at the Max Planck Institute for Software Systems (MPI-SWS) in Germany. He got his BA and PhD from the University of Cambridge, and held post-doctoral researcher positions at the University of Cambridge and at Microsoft Research Cambridge before joining MPI-SWS in October 2010.</bio>
          <homepage_url>http://www.mpi-sws.org/~viktor/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/viktorvafeiadis/6a063832-47ca-4c32-8047-4bf4f74ae764/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>808d929c-b1f0-4ade-b194-f4709237def0</subevent_id>
    <title>POPL Research Papers: Gradual Types</title>
    <timeslot>
      <slot_id>9e26338b-f632-4a5e-9b56-da7b22251e46</slot_id>
      <title>Session: POPL Research Papers - Gradual Types</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/17</date>
      <start_time>10:36</start_time>
      <end_time>12:04</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala I</room>
    <date>2019/01/17</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>21d384cf-999e-4468-9583-5aad7f18fb30</slot_id>
      <title>Type-Driven Gradual Security with References</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/17</date>
      <start_time>10:36</start_time>
      <end_time>10:58</end_time>
      <description>In security-typed programming languages, types statically enforce noninterference between potentially conspiring values, such as the arguments and results of functions. But to adopt static security types, like other advanced type disciplines, programmers face a steep wholesale transition, often forcing them to refactor working code just to satisfy their type checker. To provide a gentler path to security typing that supports safe and stylish but hard-to-verify programming idioms, researchers have designed languages that blend static and dynamic checking of security types. Unfortunately most of the resulting languages only support static, type-based reasoning about noninterference if a program is entirely statically secured. This limitation substantially weakens the bene ts that dynamic enforcement brings to static security typing. Additionally, current proposals are focused on languages with explicit casts, and therefore do not ful ll the vision of gradual typing according to which the boundaries between static and dynamic checking only arise from the (im)precision of type annotations, and are transparently mediated by implicit checks. 
In this paper we present GSLRef, a gradual security-typed higher-order language with references. As a gradual language, GSLRef supports the range of static-to-dynamic security checking exclusively driven by type annotations, without resorting to explicit casts. Additionally, GSLRef lets programmers use types to reason statically about termination-insensitive noninterference in all programs, even those that enforce security dynamically. We prove that GSLRef satis es all but one of Siek et al.’s criteria for gradually-typed languages, which ensure that programs can seamlessly transition between simple typing and security typing. A notable exception regards the dynamic gradual guarantee, which some speci c programs need to violate if they are required to satisfy noninterference; it remains an open question whether such a language could fully satisfy the dynamic gradual guarantee. To realize this design, we were led to draw a sharp distinction between syntactic type safety and semantic type soundness, each of which constrains the design of the gradual language.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matías</first_name>
          <last_name>Toro</last_name>
          <affiliation>University of Chile</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ronald</first_name>
          <last_name>Garcia</last_name>
          <affiliation>University of British Columbia</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/ronaldgarcia/639c0132-c34e-4d0f-b2bb-2218d4c99377/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Éric</first_name>
          <last_name>Tanter</last_name>
          <affiliation>University of Chile &amp; Inria Paris</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pleiad.cl/people/etanter</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/etanter/9bd12954-3541-41ba-9fb4-9ca8e0701371/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>5a56b1d2-8835-4598-abc6-ee2880fd906e</slot_id>
      <title>Gradual Parametricity, Revisited</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/17</date>
      <start_time>11:20</start_time>
      <end_time>11:42</end_time>
      <description>Bringing the benefits of gradual typing to a language with parametric polymorphism like System F, while preserving relational parametricity, has proven extremely challenging: first attempts were formulated a decade ago, and several recent developments have been published in the past year. Among other issues, these proposals can however signal parametricity errors in unexpected situations, and improperly handle type instantiations when imprecise types are involved. These observations further suggest that existing polymorphic cast calculi are not well suited for supporting a gradual counterpart of System F. Consequently, we revisit the challenge of designing a gradual language with explicit parametric polymorphism, exploring the extent to which the Abstracting Gradual Typing methodology helps us derive such a language, GSF. We present the design and metatheory of GSF. In addition to avoiding the uncovered semantic issues, GSF satisfies all the expected properties of a gradual parametric language, save for one property: the dynamic gradual guarantee, which was left as conjecture in all prior work, is here proven to be simply incompatible with parametricity. We nevertheless establish a weaker property that allows us to disprove several claims about gradual free theorems, clarifying the kind of reasoning supported by gradual parametricity.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Matías</first_name>
          <last_name>Toro</last_name>
          <affiliation>University of Chile</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Elizabeth</first_name>
          <last_name>Labrada</last_name>
          <affiliation>University of Chile</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Éric</first_name>
          <last_name>Tanter</last_name>
          <affiliation>University of Chile &amp; Inria Paris</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://pleiad.cl/people/etanter</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/etanter/9bd12954-3541-41ba-9fb4-9ca8e0701371/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>64dc325e-8934-4b19-a916-e85fca78b805</slot_id>
      <title>Gradual Type Theory</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/17</date>
      <start_time>10:58</start_time>
      <end_time>11:20</end_time>
      <description>Gradually typed languages are designed to support both dynamically typed and statically typed programming styles while preserving the benefits of each. While existing gradual type soundness theorems for these languages aim to show that type-based reasoning is preserved when moving from the fully static setting to a gradual one, these theorems do not imply that correctness of type-based refactorings and optimizations is preserved. Establishing correctness of program transformations is technically difficult, because it requires reasoning about program equivalence, and is often neglected in the metatheory of gradual languages. 
In this paper, we propose an axiomatic account of program equivalence in a gradual cast calculus, which we formalize in a logic we call gradual type theory (GTT). Based on Levy’s call-by-push-value, GTT gives an axiomatic account of both call-by-value and call-by-name gradual languages. Based on our axiomatic account we prove many theorems that justify optimizations and refactorings in gradually typed languages. For example, uniqueness principles for gradual type connectives show that if the $\beta\eta$ laws hold for a connective, then casts between that connective must be equivalent to the so-called “lazy” cast semantics. Contrapositively, this shows that “eager” cast semantics violates the extensionality of function types. As another example, we show that gradual upcasts are pure functions and, dually, gradual downcasts are strict functions. We show the consistency and applicability of our axiomatic theory by proving that a contract-based implementation using the lazy cast semantics gives a logical relations model of our type theory, where equivalence in GTT implies contextual equivalence of the programs. Since GTT also axiomatizes the dynamic gradual guarantee, our model also establishes this central theorem of gradual typing. The model is parametrized by the implementation of the dynamic types, and so gives a family of implementations that validate type-based optimization and the gradual guarantee.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Max S.</first_name>
          <last_name>New</last_name>
          <affiliation>Northeastern University</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/maxsnew/1163996d-1238-4a22-b6fd-db91cdf692ac/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Dan</first_name>
          <last_name>Licata</last_name>
          <affiliation>Wesleyan University</affiliation>
          <bio>I am an assistant professor at Wesleyan University. I received my PhD from Carnegie Mellon University in 2011, and was a postdoc at the Institute for Advanced Study in 2012-2013.</bio>
          <homepage_url>http://dlicata.web.wesleyan.edu</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/danlicata/0b1942ed-7b74-4b6b-b624-03ded7f26a62/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Amal</first_name>
          <last_name>Ahmed</last_name>
          <affiliation>Northeastern University, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.ccs.neu.edu/home/amal/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/amalahmed/301fd92b-d4ae-4998-8f6b-82cf081da653/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>cc90d6db-471d-486f-ba43-56dd36287979</slot_id>
      <title>Live Functional Programming with Typed Holes</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/17</date>
      <start_time>11:42</start_time>
      <end_time>12:04</end_time>
      <description>Live programming environments aim to provide programmers (and sometimes audiences) with continuous feedback about a program’s dynamic behavior as it is being edited. The problem is that programming languages typically assign dynamic meaning only to programs that are complete, i.e. syntactically well-formed and free of type errors. Consequently, live feedback presented to the programmer exhibits temporal or perceptive gaps. 
This paper confronts this “gap problem” from type-theoretic first principles by developing a dynamic semantics for incomplete functional programs, starting from the static semantics of Omar et al. [2017a]. We model incomplete functional programs as expressions with holes, with empty holes standing for missing expressions or types, and non-empty holes operating as membranes around static and dynamic type inconsistencies. Rather than aborting when evaluation encounters any of these holes as in some existing systems, evaluation proceeds around holes, tracking the closure around each hole instance as it flows through the remainder of the program. Editor services can use the information in these hole closures to help the programmer develop and confirm their mental model of the behavior of the complete portions of the program as they decide how to fill the remaining holes. Hole closures also enable a fill-and-resume operation that avoids the need to restart evaluation after edits that amount to hole filling. Formally, the semantics borrows machinery from both gradual type theory (which supplies the basis for handling unfilled type holes) and contextual modal type theory (which supplies a logical basis for hole closures), combining these and developing additional machinery necessary to continue evaluation past holes while maintaining type safety. We have mechanized the metatheory of the core calculus, called Hazelnut Live, using the Agda proof assistant. 
We have also implemented these ideas into the Hazel programming environment. The implementation inserts holes automatically, following the Hazelnut edit action calculus of Omar et al. [2017a], to guarantee that every editor state has some (possibly incomplete) type. Taken together with this paper’s type safety property, the result is a proof-of-concept live programming environment where rich dynamic feedback is truly available without gaps, i.e. for every reachable editor state.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Cyrus</first_name>
          <last_name>Omar</last_name>
          <affiliation>University of Chicago</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~comar</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/cyrusomar/6f85cfe7-5130-42cf-9976-450725051201/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ian</first_name>
          <last_name>Voysey</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.cmu.edu/~iev</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/ianvoysey/74b47e65-ac6a-44b1-94cb-217c6fecdeb5/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ravi</first_name>
          <last_name>Chugh</last_name>
          <affiliation>University of Chicago</affiliation>
          <bio>I am an Assistant Professor at the University of Chicago. I enjoy developing and deploying programming language technology — type systems, synthesis algorithms, and other program analysis techniques — for applications in software engineering and human-computer interaction.</bio>
          <homepage_url>http://people.cs.uchicago.edu/~rchugh</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/ravichugh/ea931b20-b1e1-4e07-b209-ba0b568e315d/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Matthew</first_name>
          <last_name>Hammer</last_name>
          <affiliation>University of Colorado, Boulder</affiliation>
          <bio>I’m interested in designing PL-based abstractions for settings in which humans and computers cooperate to create and process information. In particular, I’ve co-created abstractions for Incremental Computing (See Adapton for details) and for Secure Multiparty Computation (See Wysteria for details). 
I am an assistant professor in the Department of Computer Science at University of Colorado Boulder. I am a co-director of the CU Programming Languages and Verification group (CUPLV). Before joining CU, I was a postdoc researcher working with Michael Hicks, Jeff Foster, David Van Horn and the PLUM group at the University of Maryland. As a PhD student, I was advised by Umut Acar.</bio>
          <homepage_url>http://matthewhammer.org</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/matthewahammer/0f8bb7ab-bcde-4522-beb0-8fb15d612e1b/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>91989419-ca61-49a9-8ce6-79762c2c42bf</subevent_id>
    <title>POPL Research Papers: Categories</title>
    <timeslot>
      <slot_id>ce60041a-6206-42a1-a9e0-21306588ab17</slot_id>
      <title>Session: POPL Research Papers - Categories</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/16</date>
      <start_time>13:45</start_time>
      <end_time>14:51</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala II</room>
    <date>2019/01/16</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>1659023e-ef5c-4c84-8b91-0017f0b0f9e9</slot_id>
      <title>Categorical combinatorics of scheduling and synchronization in game semantics</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/16</date>
      <start_time>14:29</start_time>
      <end_time>14:51</end_time>
      <description>Game semantics is the art of interpreting types as \emph{games} and programs as strategies interacting in space and time with their environment. In order to reflect the interactive behavior of programs, strategies are required to follow specific scheduling policies. Typically, in the case of a purely sequential programming language, the program (Player) and its environment (Opponent) will play one after the other, in a strictly alternating way. On the other hand, in the case of a concurrent language, Player and Opponent will be allowed to play several moves in a row, in a non-alternating way. In both cases, the scheduling policy is designed very carefully in order to ensure that the strategies synchronize properly and compose well when plugged together. A longstanding conceptual problem has been to understand when and why a given scheduling policy works and is compositional in that sense. In this paper, we exhibit a number of simple and fundamental combinatorial structures which ensure that a given scheduling policy encoded as \emph{synchronization template} defines a symmetric monoidal closed (and in fact $\ast$-autonomous) bicategory of games, strategies and simulations. To that purpose, we choose to work at a very general level, and illustrate our method by constructing two template game models of linear logic with different flavors (alternating and non-alternating) using the same categorical combinatorics, performed in the category of small categories. As a whole, the paper may be seen as a hymn in praise of synchronization, building on the notion of synchronization algebra in process calculi and adapting it smoothly to programming language semantics, using a combination of ideas at the converging point of game semantics and categorical algebra.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>undefined</first_name>
          <last_name>Mellies</last_name>
          <affiliation>CNRS and University Paris Diderot</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9e62e11d-873e-4aad-a064-e42eb5b66679</slot_id>
      <title>Bindings as Bounded Natural Functors</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/16</date>
      <start_time>14:07</start_time>
      <end_time>14:29</end_time>
      <description>We present a general framework for specifying and reasoning about syntax with bindings. Abstract binder types are modeled using a universe of functors on sets, subject to a number of operations that can be used to construct complex binding patterns and binding-aware datatypes, including non-well-founded and infinitely branching types, in a modular fashion. Despite not committing to any syntactic format, the framework is “concrete” enough to provide definitions of the fundamental operators on terms (free variables, alpha-equivalence, and capture-avoiding substitution) and reasoning and definition principles. This work is compatible with classical higher-order logic and has been formalized in the proof assistant Isabelle/HOL.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Jasmin Christian</first_name>
          <last_name>Blanchette</last_name>
          <affiliation>Vrije Universiteit Amsterdam</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.vu.nl/~jbe248/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/jasminblanchette/9e79875a-976b-43a7-9453-18e510e97ae7/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Lorenzo</first_name>
          <last_name>Gheri</last_name>
          <affiliation>Middlesex University London</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Andrei</first_name>
          <last_name>Popescu</last_name>
          <affiliation>Middlesex University, London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.andreipopescu.uk/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/andreipopescu/4c35986e-7c13-4d2c-9e25-4de4c785ba36/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Dmitriy</first_name>
          <last_name>Traytel</last_name>
          <affiliation>ETH Zurich</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://people.inf.ethz.ch/trayteld/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/dmitriytraytel/8bbd70fd-409d-4088-bce0-24fa055cf5c4/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ffc896fb-ba51-4cab-b42c-f2cb5059beb5</slot_id>
      <title>Familial monads and structural operational semantics</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/16</date>
      <start_time>13:45</start_time>
      <end_time>14:07</end_time>
      <description>We propose an abstract framework for structural operational semantics, in which we prove that under suitable hypotheses bisimilarity is a congruence. We then refine the framework to prove soundness of bisimulation up to context, an efficient method for reducing the size of bisimulation relations. Finally, we demonstrate the flexibility of our approach by reproving known results about congruence of bisimilarity and soundness of bisimulation up to context, in three variants of the π-calculus.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Tom</first_name>
          <last_name>Hirschowitz</last_name>
          <affiliation>Univ. Grenoble Alpes, Univ. Savoie Mont Blanc, CNRS, LAMA, 73000 Chambéry</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.lama.univ-savoie.fr/pagesmembres/hirschowitz</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/tomhirschowitz/2bb0c8a9-9f5a-42ab-bcc3-5258751560f2/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>a97dd584-220e-4166-ad22-6ed536e02c29</subevent_id>
    <title>POPL Research Papers: Type Inference I</title>
    <timeslot>
      <slot_id>c23065f8-864c-4d83-b888-b8c8c3587785</slot_id>
      <title>Session: POPL Research Papers - Type Inference I</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/17</date>
      <start_time>13:45</start_time>
      <end_time>14:51</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala I</room>
    <date>2019/01/17</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>5d0b89c6-7e44-4cc3-ac3b-8a7b7189e3ea</slot_id>
      <title>Polymorphic Symmetric Multiple Dispatch with Variance</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/17</date>
      <start_time>14:29</start_time>
      <end_time>14:51</end_time>
      <description>Many object-oriented languages provide method overloading, which allows multiple method declarations with the same name. For a given method invocation, in order to choose what method declaration to invoke, multiple dispatch considers the run-time types of the arguments. While multiple dispatch can support binary methods (such as mathematical operators) intuitively and consistently, it is difficult to guarantee that calls will be neither ambiguous nor undefined at run time, especially in the presence of expressive language features such as multiple inheritance and parametric polymorphism. Previous efforts have formalized languages that include such features by using overloading rules that guarantee a unique and type-sound resolution of each overloaded method call; in many cases, such rules resolve ambiguity by treating the arguments asymmetrically. Here we present the first formal specification of a strongly typed object-oriented language with symmetric multiple dispatch, multiple inheritance, and parametric polymorphism with variance. We define both a static (type-checking) semantics and a dynamic (dispatching) semantics and prove the type soundness of the language, thus demonstrating that our novel dynamic dispatch algorithm is consistent with the static semantics. Details of our dynamic dispatch algorithm address certain technical challenges that arise from structural asymmetries inherent in object-oriented languages (e.g., classes typically declare ancestors explicitly but not descendants).</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gyunghee</first_name>
          <last_name>Park</last_name>
          <affiliation>KAIST, Oracle Labs</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jaemin</first_name>
          <last_name>Hong</last_name>
          <affiliation>KAIST, South Korea</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/jaeminhong/9f2d16f7-8529-44c1-bb9d-a6667b3bc435/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Guy L.</first_name>
          <last_name>Steele Jr.</last_name>
          <affiliation>Oracle Labs</affiliation>
          <bio>Guy L. Steele Jr. (A.B., 1975, Harvard College; S.M., 1977, and Ph.D., 1980, MIT) is a Software Architect at Oracle Labs. He has taught at Carnegie-Mellon University, and worked for Tartan Laboratories, Thinking Machines Corporation, and Sun Microsystems. 
He is author or co-author of five books: Common Lisp: The Language, C: A Reference Manual, The Hacker’s Dictionary, The High Performance Fortran Handbook, and The Java Language Specification. He has published more than two dozen papers on the subject of the Lisp language and Lisp implementation, including a series with Gerald Jay Sussman that defined the Scheme dialect of Lisp. His paper “Data Parallel Algorithms” with W. Daniel Hillis (December 1986) has been cited more than 1100 times. 
He has been given the Grace Murray Hopper Award (1988), the ACM SIGPLAN Programming Languages Achievement Award (1996), and the Harry H. Goode Memorial Award (2007). He is an ACM Fellow, IEEE Fellow, Fellow of the American Academy of Arts and Sciences, and a Member of the National Academy of Engineering of the United States of America. 
He has served on accredited standards committees X3J11 (C language) and X3J3 (Fortran), and served as chairman of X3J13 (Common Lisp). He was also a member of the IEEE committee that produced the IEEE Standard for the Scheme Programming Language, IEEE Std 1178-1990. At Thinking Machines Corporation he co-developed the languages Connection Machine Lisp, C*, and Connection Machine Fortran. At Sun Microsystems (and now at Oracle) he has advised the evolution of the Java programming language; he also led the design of Fortress, an object-oriented mathematical language intended to support high-performance computing. He designed the original EMACS command set and was the first person to port TeX. 
He is a member of Tech Squares, the Plus-level Modern Western Square Dance club at MIT, and a square dance caller (currently Mainstream through C3A). At SPLASH 2011 he gave a presentation and demonstration on the structure of square-dance singing calls. 
At Oracle labs, he is responsible for research in language design and implementation strategies, and architectural and software support for programming languages.</bio>
          <homepage_url>https://labs.oracle.com/pls/apex/f?p=labs:bio:0:120</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/guylsteelejr/9c36bdda-9de1-43c9-a239-3143cf32ae57/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Sukyoung</first_name>
          <last_name>Ryu</last_name>
          <affiliation>KAIST, South Korea</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://plrg.kaist.ac.kr/ryu</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/sukyoungryu/3bdcd232-f3d4-4610-9953-30b513926e54/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>901779dc-2f3b-4351-aacb-ea1a687f4b9c</slot_id>
      <title>Abstracting Extensible Data Types; Or, Rows By Any Other Name</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/17</date>
      <start_time>14:07</start_time>
      <end_time>14:29</end_time>
      <description>We present a novel typed language for extensible data types, generalizing and abstracting existing systems of row types and row polymorphism. Extensible data types are a powerful addition to traditional functional programming languages, capturing ideas from OOP-like record extension and polymorphism to modular compositional interpreters. We introduce row theories, a monoidal generalization of row types, giving a general account of record concatenation and projection (dually, variant injection and branching). We realize them via qualified types, abstracting the interpretation of records and variants over different row theories. Our approach naturally types terms untypable in other systems of extensible data types, while maintaining strong metatheoretic properties, such as coherence and principal types. Evidence for type qualifiers has computational content, determining the implementation of record and variant operations; we demonstrate this in giving a modular translation from our calculus, instantiated with various row theories, to polymorphic λ-calculus.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>J. Garrett</first_name>
          <last_name>Morris</last_name>
          <affiliation>University of Kansas, USA</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://jgbm.github.io</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/jgarrettmorris/bfd0d5b6-e65e-403e-882f-089258565ed5/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>James</first_name>
          <last_name>McKinna</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9774d09b-6133-47d4-bd36-b0a0334cf69d</slot_id>
      <title>Sound and Complete Bidirectional Typechecking for Higher-Rank Polymorphism with Existentials and Indexed Types</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/17</date>
      <start_time>13:45</start_time>
      <end_time>14:07</end_time>
      <description>Bidirectional typechecking, in which terms either synthesize a type or are checked against a known type, has become popular for its applicability to a variety of type systems, its error reporting, and its ease of implementation. Following principles from proof theory, bidirectional typing can be applied to many type constructs. The principles underlying a bidirectional approach to indexed types (generalized algebraic datatypes) are less clear. Building on proof-theoretic treatments of equality, we give a declarative specification of typing based on focalization. This approach permits declarative rules for coverage of pattern matching, as well as support for first-class existential types using a focalized subtyping judgment. We use refinement types to avoid explicitly passing equality proofs in our term syntax, making our calculus similar to languages such as Haskell and OCaml. We also extend the declarative specification with an explicit rules for deducing when a type is principal, permitting us to give a complete declarative specification for a rich type system with significant type inference. We also give a set of algorithmic typing rules, and prove that it is sound and complete with respect to the declarative system. The proof requires a number of technical innovations, including proving soundness and completeness in a mutually recursive fashion.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Joshua</first_name>
          <last_name>Dunfield</last_name>
          <affiliation>Queen's University, Kingston, Ontario</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.queensu.ca/~joshuad/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/joshuadunfield/f5a87919-7384-43f2-80b5-bb1362598687/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Neelakantan R.</first_name>
          <last_name>Krishnaswami</last_name>
          <affiliation>Computer Laboratory, University of Cambridge</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cl.cam.ac.uk/~nk480</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/neelakantankrishnaswami/45f309fe-1177-4f2f-b017-0f7a9333bda4/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>b63c10b3-eaff-4444-8ad0-af8a50574560</subevent_id>
    <title>POPL Research Papers: Thursday Lunch</title>
    <timeslot>
      <slot_id>c745f897-00bc-4029-91db-977bde2f646d</slot_id>
      <title>Session: POPL Research Papers - Thursday Lunch</title>
      <room>Hotel Cascais Miragem | Lunch Room</room>
      <date>2019/01/17</date>
      <start_time>12:04</start_time>
      <end_time>13:45</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Lunch Room</room>
    <date>2019/01/17</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>8504681c-8656-4194-b38a-1fff4007b866</slot_id>
      <title>Lunch</title>
      <room>Hotel Cascais Miragem | Lunch Room</room>
      <date>2019/01/17</date>
      <start_time>12:04</start_time>
      <end_time>13:45</end_time>
      <description>undefined</description>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>c089415a-f60b-421a-a466-88e10ace1a4e</subevent_id>
    <title>POPL Research Papers: Friday Social Hour</title>
    <timeslot>
      <slot_id>e2d93f5d-e533-4793-87e9-3272fd58554e</slot_id>
      <title>Session: POPL Research Papers - Friday Social Hour</title>
      <room>Hotel Cascais Miragem | Galeria</room>
      <date>2019/01/18</date>
      <start_time>17:45</start_time>
      <end_time>18:45</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Galeria</room>
    <date>2019/01/18</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>02eb1b5d-3a20-469d-a1f5-cab853e058c2</slot_id>
      <title>Social Hour</title>
      <room>Hotel Cascais Miragem | Galeria</room>
      <date>2019/01/18</date>
      <start_time>17:45</start_time>
      <end_time>18:45</end_time>
      <description>undefined</description>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>66760c74-66a3-4101-b1ce-72c458e87e77</subevent_id>
    <title>POPL Research Papers: Dependent Types</title>
    <timeslot>
      <slot_id>4eecd27d-298d-456c-a03f-31b259c370fa</slot_id>
      <title>Session: POPL Research Papers - Dependent Types</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/18</date>
      <start_time>10:35</start_time>
      <end_time>12:03</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala I</room>
    <date>2019/01/18</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>8c458956-eab6-4732-8e54-a09cf0ec97a7</slot_id>
      <title>Higher Inductive Types in Cubical Computational Type Theory</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/18</date>
      <start_time>10:35</start_time>
      <end_time>10:57</end_time>
      <description>Homotopy type theory proposes higher inductive types (HITs) as a means of defining and reasoning about inductively-generated objects with higher-dimensional structure. As with the univalence axiom, however, homotopy type theory does not specify the computational behavior of HITs. Computational interpretations have now been provided for univalence and specific HITs by way of cubical type theories, which use a judgmental infrastructure of dimension variables. We extend the cartesian cubical computational type theory introduced by Angiuli et al. with a schema for indexed cubical inductive types (CITs), an adaptation of higher inductive types to the cubical setting. In doing so, we isolate the canonical values of a cubical inductive type and prove a canonicity theorem with respect to these values.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Evan</first_name>
          <last_name>Cavallo</last_name>
          <affiliation>Carnegie Mellon University</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Robert</first_name>
          <last_name>Harper</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>9b8e9889-b9ad-4d15-8680-7156ba64f0ba</slot_id>
      <title>Definitional Proof-Irrelevance without K</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/18</date>
      <start_time>11:19</start_time>
      <end_time>11:41</end_time>
      <description>Definitional equality—or conversion—for a type theory with a decidable type checking is the simplest tool to prove that two objects are the same, letting the system decide just using computation. Therefore, the more things are equal by conversion, the simpler it is to use a language based on type theory. Proof-irrelevance, stating that any two proofs of the same proposition are equal, is a possible way to extend conversion to make a type theory more powerful. However, this new power comes at a price if we integrate it naively, either by making type checking undecidable or by realizing new axioms—such as uniqueness of identity proofs (UIP)—that are incompatible with other extensions, such as univalence. In this paper, taking inspiration from homotopy type theory, we propose a general way to extend a type theory with definitional proof irrelevance, in a way that keeps type checking decidable and is compatible with univalence. We provide a new criterion to decide whether a proposition can be eliminated over a type (correcting and improving the so-called singleton elimination of Coq) by using techniques coming from recent development on dependent pattern matching without UIP. We show the generality of our approach by providing implementations for both Coq and Agda, both of which are planned to be integrated in future versions of those proof assistants.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Gaetan</first_name>
          <last_name>Gilbert</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Jesper</first_name>
          <last_name>Cockx</last_name>
          <affiliation>Chalmers | University of Gothenburg</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://jesper.sikanda.be</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/jespercockx/113f5ec5-aa52-443e-93e2-e7d8d136577b/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Matthieu</first_name>
          <last_name>Sozeau</last_name>
          <affiliation>Inria</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.pps.univ-paris-diderot.fr/~sozeau/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/matthieusozeau/d1a3ad89-73f4-44cc-8f0b-830f395d9953/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Nicolas</first_name>
          <last_name>Tabareau</last_name>
          <affiliation>Inria</affiliation>
          <bio>Nicolas Tabareau is a junior researcher at Inria, head of the Gallinette team (http://gallinette.inria.fr/). He conducts research on programming languages and proof assistants in order to provide better tools for proofs formalization both to computer scientists and mathematicians.</bio>
          <homepage_url>http://tabareau.fr</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/nicolastabareau/9008d3aa-ff81-41b4-92b9-6c24266ef793/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ca2b81ed-4fd1-454c-932b-7b961aba1ad9</slot_id>
      <title>Constructing Quotient Inductive-Inductive Types</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/18</date>
      <start_time>10:57</start_time>
      <end_time>11:19</end_time>
      <description>Quotient inductive-inductive types (QIITs) generalise inductive types in two ways: a QIIT can have more than one sort and the later sorts can be indexed over the previous ones. In addition, equality constructors are also allowed. We work in a setting with uniqueness of identity proofs, hence we use the term QIIT instead of higher inductive-inductive type. An example of a QIIT is the well-typed (intrinsic) syntax of type theory quotiented by conversion. In this paper first we specify finitary QIITs using a domain-specific type theory which we call the theory of signatures. The syntax of the theory of signatures is given by a QIIT as well. Then, using this syntax we show that all specified QIITs exist and they have a dependent elimination principle. We also show that algebras of a signature form a category with families (CwF) and use the internal language of this CwF to show that dependent elimination is equivalent to initiality.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Thorsten</first_name>
          <last_name>Altenkirch</last_name>
          <affiliation>University of Nottingham</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Ambrus</first_name>
          <last_name>Kaposi</last_name>
          <affiliation>University of Nottingham</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>András</first_name>
          <last_name>Kovács</last_name>
          <affiliation>Eötvös Loránd University</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>f327dbdc-2887-4547-b844-b72452df8d50</slot_id>
      <title>Bisimulation as path type for guarded recursive types</title>
      <room>Hotel Cascais Miragem | Sala I</room>
      <date>2019/01/18</date>
      <start_time>11:41</start_time>
      <end_time>12:03</end_time>
      <description>In type theory, coinductive types are used to represent processes, and are thus crucial for the formal verification of non-terminating reactive programs in proof assistants based on type theory, such as Coq and Agda. Currently, programming and reasoning about coinductive types is difficult for two reasons: The need for recursive definitions to be productive, and the lack of coincidence of the built-in identity types and the important notion of bisimilarity. 
Guarded recursion in the sense of Nakano has recently been suggested as a possible approach for dealing with the problem of productivity, allowing this to be encoded in types. Indeed, coinductive types can be encoded using a combination of guarded recursion and universal quantification over clocks. This paper studies the notion of bisimilarity for coinductive types in Ticked Cubical Type Theory, an extension of Cubical Type Theory with guarded recursion. We prove that, for any functor, an abstract, category theoretic notion of bisimilarity for the final guarded coalgebra is equivalent (in the sense of homotopy type theory) to path equality (the primitive notion of equality in cubical type theory). As a worked example we study a guarded notion of labelled transition systems, and show that, as a special case of the general theorem, path equality coincides with an adaptation of the usual notion of bisimulation for processes. In particular, this implies that guarded recursion can be used to give simple equational reasoning proofs of bisimilarity. This work should be seen as a step towards obtaining bisimilarity as path equality for coinductive types using the encodings mentioned above.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Rasmus Ejlers</first_name>
          <last_name>Møgelberg</last_name>
          <affiliation>IT University of Copenhagen</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.itu.dk/~mogel/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/rasmusejlersmgelberg/11af8597-c43e-41ec-9aca-42de56d754c7/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Niccolò</first_name>
          <last_name>Veltri</last_name>
          <affiliation>IT University of Copenhagen</affiliation>
          <bio>undefined</bio>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>2430fa88-5b03-413c-aebe-b53d6c73eed1</subevent_id>
    <title>POPL Research Papers: SRC Announcement &amp; Keynote II</title>
    <timeslot>
      <slot_id>b4b539e4-3353-4b2b-92bc-f1d6adc0d344</slot_id>
      <title>Session: POPL Research Papers - SRC Announcement &amp; Keynote II</title>
      <room>Hotel Cascais Miragem | Sala I + II</room>
      <date>2019/01/18</date>
      <start_time>09:00</start_time>
      <end_time>10:05</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala I + II</room>
    <date>2019/01/18</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>d44e2703-8ec3-4bf1-8d73-fc0a09cbfe1a</slot_id>
      <title>SRC Announcement</title>
      <room>Hotel Cascais Miragem | Sala I + II</room>
      <date>2019/01/18</date>
      <start_time>09:00</start_time>
      <end_time>09:05</end_time>
      <description>undefined</description>
      <persons>
        <person>
          <role>Student Research Competition Chair</role>
          <sort_key>1</sort_key>
          <first_name>Niki</first_name>
          <last_name>Vazou</last_name>
          <affiliation>IMDEA Software Institute</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://nikivazou.github.io/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/nikivazou/8cc6ddec-154b-47e9-b40d-c66e78476391/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Student Research Competition</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e8b25445-3181-43f4-91be-9ea678409f53</slot_id>
      <title> Mechanized Metatheory - The Next Chapter</title>
      <room>Hotel Cascais Miragem | Sala I + II</room>
      <date>2019/01/18</date>
      <start_time>09:05</start_time>
      <end_time>10:05</end_time>
      <description>Mechanizing formal systems and proofs about them plays an important role in establishing trust in programming languages and verifying software systems in general. Over the past decades, we have seen significant progress and success: the POPLMark challenge popularized the use of proof assistants in mechanizing the metatheory of programming languages; the development of the first verified compiler in Coq demonstrated the feasibility and value of building verified compilers. Today, mechanizing proofs is a stable fixture in the daily life of programming languages researchers. 
One might be tempted to assume that all is well – yet, the reality is that we seem to accept the status quo and focus on engineering solutions to get the next job done, although mechanizations can be time consuming and require substantial (sometimes heroic) effort. In this talk I will argue that we should strive to develop high-level abstractions, primitives, and tools to standardize common tasks and operations arising when working with formal systems and proofs about them. 
Taking a look back at some of the foundational theoretical ideas and choices that underly type-theoretic proof environments today, I will survey recent achievements and sketch a dependently typed language that would make it easier to represent, maintain, and communicate formal systems and proofs about them – an elegant proof language for a more civilized age.</description>
      <persons>
        <person>
          <role>Keynote Speaker</role>
          <sort_key>1</sort_key>
          <first_name>Brigitte</first_name>
          <last_name>Pientka</last_name>
          <affiliation>McGill University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.mcgill.ca/~bpientka/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/brigittepientka/de1fcba2-a8fd-4b6e-a4f2-b7d397fef2cf/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>cd269d64-c040-4c75-990a-b596b6a613a7</subevent_id>
    <title>POPL Research Papers: Separation Logic and Memory Semantics</title>
    <timeslot>
      <slot_id>a40f1f82-fdc5-4c86-8431-011f55982aab</slot_id>
      <title>Session: POPL Research Papers - Separation Logic and Memory Semantics</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/17</date>
      <start_time>10:36</start_time>
      <end_time>12:04</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala II</room>
    <date>2019/01/17</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>43c92720-78bb-4a22-8287-26ffbc42735b</slot_id>
      <title>JaVerT 2.0: Compositional Symbolic Execution for JavaScript</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/17</date>
      <start_time>10:58</start_time>
      <end_time>11:20</end_time>
      <description>We propose a novel, unified approach to the development of compositional symbolic execution tools, bridging the gap between classical symbolic execution and compositional program reasoning based on separation logic. Using this approach, we build a new analysis tool for JavaScript that follows the semantics of the language without any simplifications, with support for whole-program symbolic testing, verification, and, for the first time, automatic compositional testing based on bi-abduction. The meta-theory underpinning the tool is developed in a modular way, streamlining the proofs and informing the implementation. Our explicit treatment of symbolic execution errors allows us to give meaningful feedback to the developer during whole-program symbolic testing and guides the inference of resource of the bi-abductive execution. We evaluate the performance of our tool on a number of JavaScript data-structure libraries, demonstrating the scalability of whole-program symbolic testing, an improvement over our previous work on JavaScript verification, and automatic creation of useful specifications using bi-abduction.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>José Fragoso</first_name>
          <last_name>Santos</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Petar</first_name>
          <last_name>Maksimović</last_name>
          <affiliation>Imperial College London, UK and Mathematical Institute of the Serbian Academy of Sciences and Arts, Serbia</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/petarmaksimovic/10dfc861-3a11-48a5-8af6-f58fd86389e3/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Gabriela</first_name>
          <last_name>Sampaio</last_name>
          <affiliation>Imperial College London, UK</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Philippa</first_name>
          <last_name>Gardner</last_name>
          <affiliation>Imperial College London</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.doc.ic.ac.uk/~pg/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>70bb0a0a-88cf-444b-89cc-86424760a63a</slot_id>
      <title>Exploring C Semantics and Pointer Provenance</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/17</date>
      <start_time>11:42</start_time>
      <end_time>12:04</end_time>
      <description>The semantics of pointers and memory objects in C has been a vexed question for many years. C values cannot be treated as either purely abstract or purely concrete entities: the language exposes their representations, but compiler optimisations rely on analyses that reason about provenance and initialisation status, not just runtime representations. The ISO WG14 standard leaves much of this unclear, and in some respects differs with de facto standard usage — which itself is difficult to investigate. 
In this paper we explore the possible source-language semantics for memory objects and pointers, in ISO C and in C as it is used and implemented in practice, focussing especially on pointer provenance. We aim to, as far as possible, reconcile the ISO C standard, mainstream compiler behaviour, and the semantics relied on by the corpus of existing C code. We present two coherent proposals, tracking provenance via integers and not; both address many design questions. We highlight some pros and cons and open questions, and illustrate the discussion with a library of test cases. We make our semantics executable as a test oracle, integrating it with the Cerberus semantics for much of the rest of C, which we have made substantially more complete and robust, and equipped with a web-interface GUI. This allows us to experimentally assess our proposals on those test cases. To assess their viability with respect to larger bodies of C code, we analyse the changes required and the resulting behaviour for a port of FreeBSD to CHERI, a research architecture supporting hardware capabilities, which (roughly speaking) traps on the memory safety violations which our proposals deem undefined behaviour. We also develop a new runtime instrumentation tool to detect possible provenance violations in normal C code, and apply it to some of the SPEC benchmarks. We compare our proposal with a source-language variant of the twin-allocation LLVM semantics proposal of Lee et al. Finally, we describe ongoing interactions with WG14, exploring how our proposals could be incorporated into the ISO standard.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Kayvan</first_name>
          <last_name>Memarian</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cl.cam.ac.uk/~km569</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Victor B. F.</first_name>
          <last_name>Gomes</last_name>
          <affiliation>University of Cambridge, UK</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://victorgomes.co.uk</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Brooks</first_name>
          <last_name>Davis</last_name>
          <affiliation>SRI International</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Stephen</first_name>
          <last_name>Kell</last_name>
          <affiliation>University of Kent</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cs.kent.ac.uk/people/staff/srk21</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/stephenkell/53088184-3e8c-4a2c-b34f-b2a290cff411/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Alexander</first_name>
          <last_name>Richardson</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Robert N. M.</first_name>
          <last_name>Watson</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Peter</first_name>
          <last_name>Sewell</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cl.cam.ac.uk/~pes20/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/petersewell/ba28b120-f5b2-42d2-90b8-0559f144abee/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>ab923b19-ba38-49ae-9a71-16bccd9d7756</slot_id>
      <title>ISA Semantics for ARMv8-A, RISC-V, and CHERI-MIPS</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/17</date>
      <start_time>11:20</start_time>
      <end_time>11:42</end_time>
      <description>Architecture specifications notionally define the fundamental interface between hardware and software: the envelope of allowed behaviour for processor implementations, and the basic assumptions for software development and verification. But in practice, they are typically prose and pseudocode documents, not rigorous or executable artifacts, leaving software and verification on shaky ground. 
In this paper, we present rigorous semantic models for the sequential behaviour of large parts of the mainstream ARMv8-A, RISC-V, and MIPS architectures, and the research CHERI-MIPS architecture, that are complete enough to boot operating systems, variously Linux, FreeBSD, or seL4. Our ARMv8-A models are automatically translated from authoritative ARM-internal definitions, and (in one variant) tested against the ARM Architecture Validation Suite. 
We do this using a custom language for ISA semantics, Sail, with a lightweight dependent type system, that supports automatic generation of emulator code in C and OCaml, and automatic generation of proof-assistant definitions for Isabelle, HOL4, and (currently only for MIPS) Coq. We use the former for validation, and to assess specification coverage. To demonstrate the usability of the latter, we prove (in Isabelle) correctness of a purely functional characterisation of ARMv8-A address translation. We moreover integrate the RISC-V model into the RMEM tool for (user-mode) relaxed-memory concurrency exploration. We prove (on paper) the soundness of the core Sail type system. 
We thereby take a big step towards making the architectural abstraction actually well-defined, establishing foundations for verification and reasoning.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Alasdair</first_name>
          <last_name>Armstrong</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Thomas</first_name>
          <last_name>Bauereiss</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Brian</first_name>
          <last_name>Campbell</last_name>
          <affiliation>University of Edinburgh</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Alastair</first_name>
          <last_name>Reid</last_name>
          <affiliation>Arm Ltd</affiliation>
          <bio>Researcher at Arm Ltd (UK) since 2004 
 
 model checking processor pipelines (newest) 
 formal architecture specifications 
 wide SIMD instruction set 
 pipeline parallelism 
 software defined radio 
 vectorising compilers (oldest) 
 
Researcher at University of Utah (USA), 1998-2004 
 
 component based operating system kernels 
 
Researcher at Yale University (USA), 1994-1998 
 
 Haskell foreign function interface 
 Functional Reactive Programming 
 Visual Tracking in Haskell 
 Haskell library/compiler development 
 
Researcher at University of Glasgow (UK), 1988-1994 
 
 Formal Specification and Verification 
 GHC foreign function interface 
</bio>
          <homepage_url>https://alastairreid.github.io</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/alastairreid/abeed76b-bca7-4e3e-9339-f5cdf8c7db80/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Kathryn E.</first_name>
          <last_name>Gray</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>6</sort_key>
          <first_name>Robert M.</first_name>
          <last_name>Norton</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>7</sort_key>
          <first_name>Prashanth</first_name>
          <last_name>Mundkur</last_name>
          <affiliation>SRI International</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>8</sort_key>
          <first_name>Mark</first_name>
          <last_name>Wassell</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cl.cam.ac.uk/~mpew2/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>9</sort_key>
          <first_name>Jon</first_name>
          <last_name>French</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>10</sort_key>
          <first_name>Christopher</first_name>
          <last_name>Pulte</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.cl.cam.ac.uk/~cp526/</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>11</sort_key>
          <first_name>Shaked</first_name>
          <last_name>Flur</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>12</sort_key>
          <first_name>Ian</first_name>
          <last_name>Stark</last_name>
          <affiliation>The University of Edinburgh</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://homepages.ed.ac.uk/stark</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/ianstark/c408cf23-1944-4e5b-803d-4e7001511ec8/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>13</sort_key>
          <first_name>Neelakantan R.</first_name>
          <last_name>Krishnaswami</last_name>
          <affiliation>Computer Laboratory, University of Cambridge</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cl.cam.ac.uk/~nk480</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/neelakantankrishnaswami/45f309fe-1177-4f2f-b017-0f7a9333bda4/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>14</sort_key>
          <first_name>Peter</first_name>
          <last_name>Sewell</last_name>
          <affiliation>University of Cambridge</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://www.cl.cam.ac.uk/~pes20/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/petersewell/ba28b120-f5b2-42d2-90b8-0559f144abee/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>e629dd45-67ed-42e7-b7a8-11646eabbfdf</slot_id>
      <title>Iron: Managing Obligations in Higher-Order Concurrent Separation Logic</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/17</date>
      <start_time>10:36</start_time>
      <end_time>10:58</end_time>
      <description>Precise management of resources and the obligations they impose, such as the need to dispose of memory, close locks, and release file handles, is hard—especially in the presence of concurrency, when some resources are shared, and different threads operate on them concurrently. We present Iron, a novel higher-order concurrent separation logic that allows for precise reasoning about resources that are transferable among dynamically allocated threads. In particular, Iron can be used to show the correctness of challenging examples, where the reclamation of memory is delegated to a forked-off thread. We show soundness of Iron by means of a model of Iron, defined on top of the Iris base logic, and we use this model to prove that memory resources are accounted for precisely and not leaked. We have formalized all of the developments in the Coq proof assistant.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Aleš</first_name>
          <last_name>Bizjak</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.au.dk/~abizjak/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/alesbizjak/c86f8b66-c762-4ff5-9b76-3b2377003936/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Daniel</first_name>
          <last_name>Gratzer</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Robbert</first_name>
          <last_name>Krebbers</last_name>
          <affiliation>Delft University of Technology</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://robbertkrebbers.nl</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/robbertkrebbers/c7fa7d6a-4f5e-4a65-893c-055c924fab02/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Lars</first_name>
          <last_name>Birkedal</last_name>
          <affiliation>Aarhus University</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://cs.au.dk/~birke/</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>dcbe8064-f059-4ffd-a72c-b40e295aece6</subevent_id>
    <title>POPL Research Papers: Saturday Lunch</title>
    <timeslot>
      <slot_id>9f1340ad-d414-47da-b97a-3a3dbd1c70c9</slot_id>
      <title>Session: POPL Research Papers - Saturday Lunch</title>
      <room>Hotel Cascais Miragem | Lunch Room</room>
      <date>2019/01/19</date>
      <start_time>12:30</start_time>
      <end_time>14:00</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Lunch Room</room>
    <date>2019/01/19</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>1d490cfe-4bb6-402a-9f39-457b418ae41e</slot_id>
      <title>Lunch</title>
      <room>Hotel Cascais Miragem | Lunch Room</room>
      <date>2019/01/19</date>
      <start_time>12:30</start_time>
      <end_time>14:00</end_time>
      <description>undefined</description>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>694e76cf-3d21-4e75-8ec5-8eb6be71e265</subevent_id>
    <title>POPL Research Papers: Tuesday Social Hour</title>
    <timeslot>
      <slot_id>aaf7234d-33df-4b44-8561-d9cb10f9468b</slot_id>
      <title>Session: POPL Research Papers - Tuesday Social Hour</title>
      <room>Hotel Cascais Miragem | Galeria</room>
      <date>2019/01/15</date>
      <start_time>17:30</start_time>
      <end_time>18:30</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Galeria</room>
    <date>2019/01/15</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>9e81d564-15ab-46bb-9817-e5eb94f6eb68</slot_id>
      <title>Social Hour</title>
      <room>Hotel Cascais Miragem | Galeria</room>
      <date>2019/01/15</date>
      <start_time>17:30</start_time>
      <end_time>18:30</end_time>
      <description>undefined</description>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
  <subevent>
    <subevent_id>75743e7a-d54f-4889-8c1f-ed794749b23d</subevent_id>
    <title>POPL Research Papers: Concurrency</title>
    <timeslot>
      <slot_id>b058701a-6f92-4d86-b322-7ca06f9ca4b2</slot_id>
      <title>Session: POPL Research Papers - Concurrency</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/16</date>
      <start_time>10:35</start_time>
      <end_time>12:03</end_time>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <subevent_type type="regular"/>
    <room>Hotel Cascais Miragem | Sala II</room>
    <date>2019/01/16</date>
    <url>https://popl19.sigplan.org/track/POPL-2019-Research-Papers</url>
    <url_link_display>Research Papers</url_link_display>
    <tracks>
      <track>Research Papers</track>
    </tracks>
    <timeslot>
      <slot_id>11dd87b8-beac-40fb-b8d4-8355097a2f34</slot_id>
      <title>Decoupling Lock-Free Data Structures from Memory Reclamation for Static Analysis</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/16</date>
      <start_time>10:57</start_time>
      <end_time>11:19</end_time>
      <description>Verification of concurrent data structures is one of the most challenging tasks in software verification. The topic has received considerable attention over the course of the last decade. Nevertheless, human-driven techniques remain cumbersome and notoriously difficult while automated approaches suffer from limited applicability. The main obstacle for automation is the complexity of concurrent data structures. This is particularly true in the absence of garbage collection. The intricacy of lock-free memory management paired with the complexity of concurrent data structures makes automated verification prohibitive. 
In this work we present a method for verifying concurrent data structures and their memory management separately. We suggest two simpler verification tasks that imply the correctness of the data structure. The first task establishes an over-approximation of the reclamation behavior of the memory management. The second task exploits this over-approximation to verify the data structure without the need to consider the implementation of the memory management itself. To make the resulting verification tasks tractable for automated techniques, we establish a second result. We show that a verification tool needs to consider only executions where a single memory location is reused. We implemented our approach and were able to verify linearizability of Michael&amp;amp;Scott’s queue and the DGLM queue for both hazard pointers and epoch-based reclamation. To the best of our knowledge, we are the first to verify such implementations fully automatically.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Roland</first_name>
          <last_name>Meyer</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Sebastian</first_name>
          <last_name>Wolff</last_name>
          <affiliation>TU Braunschweig</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.tcs.cs.tu-bs.de/wolff.html</homepage_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>3d32ee16-31f5-469b-bc0f-2a470a6e5a38</slot_id>
      <title>A True Positives Theorem for a Static Race Detector</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/16</date>
      <start_time>10:35</start_time>
      <end_time>10:57</end_time>
      <description>RacerD is a static race detector that has been proven to be effective in engineering practice: it has seen thousands of data races fixed by developers before reaching production, and has supported the migration of Facebook’s Android app from a single-threaded to a multi-threaded architecture. We prove a True Positives Theorem stating that under certain assumptions, which reflect the way that product code (but not infrastructure code) uses concurrency, an idealized theoretical version of the analysis never reports a false positive. We also provide an empirical evaluation of an implementation of this analysis, versus the original RacerD. 
The theorem was motivated in the first case by the desire to understand the observation from production that RacerD was providing remarkably accurate signal to developers, and then the theorem guided further analyzer design decisions. Technically, our result can be seen as saying that the analysis computes an under-approximation of an over-approximation, which is the reverse of the more usual (over of under) situation in static analysis. We suggest that theorems of this variety might be generally useful in designing static analyses for bug catching.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Nikos</first_name>
          <last_name>Gorogiannis</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Peter W.</first_name>
          <last_name>O'Hearn</last_name>
          <affiliation>Facebook and University College London</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Ilya</first_name>
          <last_name>Sergey</last_name>
          <affiliation>Yale-NUS College</affiliation>
          <bio>I am a tenure-track Associate Professor at Yale-NUS College and NUS School of Computing (Singapore). 
Prior to joining Yale-NUS, I was a faculty at University College London. Before then, I was a postdoctoral researcher at IMDEA Software Institute (Madrid, Spain). I defended my PhD in 2012 in the DistriNet research group at the Department of Computer Sciences of KU Leuven (Belgium). Before that I received my MSc degree in Mathematics and Computer Science from Saint Petersburg State University (Russia) in 2008. 
My research interests dwell in the area of the design and implementation of programming languages, including but not limited to program semantics, certified programming, concurrency and abstract interpretation. I am particularly interested in developing verification techniques and static analyses for higher-order and concurrent programs.</bio>
          <homepage_url>http://ilyasergey.net</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/ilyasergey/b2941c89-4843-4194-852a-81c8a30814fa/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>b3f1100b-c414-4fa9-af43-f64d22de19c9</slot_id>
      <title>Pretend Synchrony: Synchronous Verification of Asynchronous Distributed Programs</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/16</date>
      <start_time>11:19</start_time>
      <end_time>11:41</end_time>
      <description>We present pretend synchrony, a new approach to verifying distributed systems, based on the observation that while distributed programs must execute asynchronously, we can often soundly treat them as if they were synchronous when verifying their correctness. To do so, we compute a synchronization, a semantically equivalent program where all sends, receives, and message bu ers, have been replaced by simple assignments, yielding a program that can be veri ed using Floyd-Hoare style Veri cation Conditions and SMT. We implement our approach as a framework for writing veri ed distributed programs in Go and evaluate it with four challenging case studies— the classic two-phase commit protocol, the Raft leader election protocol, single- decree Paxos protocol, and a Multi-Paxos based distributed key-value store. We find that pretend synchrony allows us to develop performant systems while making veri cation of functional correctness simpler by reducing manually speci ed invariants by a factor of 6, and faster, by reducing checking time by three orders of magnitude.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Klaus v.</first_name>
          <last_name>Gleissenthall</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>undefined</bio>
          <picture_url>https://popl19.sigplan.org/getProfileImage/klausvgleissenthall/f11eb63e-d7f2-4315-8554-76e822b482b9/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Rami Gökhan</first_name>
          <last_name>Kıcı</last_name>
          <affiliation>University of California at San Diego, USA</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>3</sort_key>
          <first_name>Alexander</first_name>
          <last_name>Bakst</last_name>
          <affiliation>undefined</affiliation>
          <bio>undefined</bio>
        </person>
        <person>
          <role>Author</role>
          <sort_key>4</sort_key>
          <first_name>Deian</first_name>
          <last_name>Stefan</last_name>
          <affiliation>University of California San Diego</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://cseweb.ucsd.edu/~dstefan/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/deianstefan/55e73d29-9671-4740-9ef2-3b45f485fc24/small.jpg</picture_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>5</sort_key>
          <first_name>Ranjit</first_name>
          <last_name>Jhala</last_name>
          <affiliation>University of California, San Diego</affiliation>
          <bio>Nom nom. Chomp. Burp.</bio>
          <homepage_url>http://ranjitjhala.github.io</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/ranjitjhala/afbdab69-ed23-4022-b7a4-2c57128f20ec/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
    <timeslot>
      <slot_id>c7152e7d-ab30-4c50-b387-8aa610502a72</slot_id>
      <title>Weak-Consistency Specification via Visibility Relaxation</title>
      <room>Hotel Cascais Miragem | Sala II</room>
      <date>2019/01/16</date>
      <start_time>11:41</start_time>
      <end_time>12:03</end_time>
      <description>Effective software specifications enable modular reasoning, allowing clients to establish program properties without knowing the details of module implementations. While some modules’ operations behave atomically, others admit weaker consistencies to increase performance. Consequently, since current methodologies do not capture the guarantees provided by operations of varying non-atomic consistencies, specifications are ineffective, forfeiting the ability to establish properties of programs that invoke non-atomic operations. 
In this work we develop a methodology for specifying software modules whose operations satisfy multiple distinct consistency levels. In particular, we develop a simple annotation language for specifying weakly-consistent operations via visibility relaxation, wherein annotations impose varying constraints on the visibility among operations. To integrate with modern software platforms, we identify a novel characterization of consistency called sequential happens-before consistency, which admits effective validation. Empirically, we demonstrate the efficacy of our approach by deriving and validating relaxed-visibility specifications for Java concurrent objects. Furthermore, we demonstrate an optimality of our annotation language, empirically, by establishing that even finer-grained languages do not capture stronger specifications for Java objects.</description>
      <persons>
        <person>
          <role>Author</role>
          <sort_key>1</sort_key>
          <first_name>Michael</first_name>
          <last_name>Emmi</last_name>
          <affiliation>SRI International</affiliation>
          <bio>undefined</bio>
          <homepage_url>http://michael-emmi.github.io</homepage_url>
        </person>
        <person>
          <role>Author</role>
          <sort_key>2</sort_key>
          <first_name>Constantin</first_name>
          <last_name>Enea</last_name>
          <affiliation>Université Paris Diderot</affiliation>
          <bio>undefined</bio>
          <homepage_url>https://www.irif.fr/~cenea/</homepage_url>
          <picture_url>https://popl19.sigplan.org/getProfileImage/constantinenea/2dfe8bfe-ddfe-4012-a2e2-01cc8b953734/small.jpg</picture_url>
        </person>
      </persons>
      <tracks>
        <track>Research Papers</track>
      </tracks>
    </timeslot>
  </subevent>
</event>
